{
  "operations": [
    {
      "sql": {
        "up": "DO $$ BEGIN INSERT INTO public.users (id, created_at, created_by) SELECT DISTINCT user_name, NOW(), 'migration' FROM public.profile WHERE user_name NOT IN (SELECT id FROM public.users) ON CONFLICT (id) DO NOTHING; INSERT INTO public.users (id, created_at, created_by) SELECT DISTINCT user_name, NOW(), 'migration' FROM public.access_token WHERE user_name NOT IN (SELECT id FROM public.users) ON CONFLICT (id) DO NOTHING; IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'access_token' AND column_name = 'access_type') THEN DELETE FROM public.profile WHERE user_name IN (SELECT DISTINCT user_name FROM public.access_token WHERE access_type = 'SERVICE'); DELETE FROM public.ueks WHERE uid IN (SELECT DISTINCT user_name FROM public.access_token WHERE access_type = 'SERVICE'); DELETE FROM public.credential WHERE user_name IN (SELECT DISTINCT user_name FROM public.access_token WHERE access_type = 'SERVICE'); DELETE FROM public.access_token WHERE access_type = 'SERVICE'; END IF; IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'user_roles_user_id_role_name_key') THEN ALTER TABLE public.user_roles ADD CONSTRAINT user_roles_user_id_role_name_key UNIQUE (user_id, role_name); END IF; ALTER TABLE public.access_token DROP CONSTRAINT IF EXISTS access_token_pkey CASCADE; DELETE FROM public.access_token WHERE user_name NOT IN (SELECT id FROM public.users); ALTER TABLE public.access_token ADD PRIMARY KEY (user_name, token_name); IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'access_token_user_name_fkey') THEN ALTER TABLE public.access_token ADD CONSTRAINT access_token_user_name_fkey FOREIGN KEY (user_name) REFERENCES public.users(id) ON DELETE CASCADE; END IF; IF NOT EXISTS (SELECT 1 FROM pg_constraint c JOIN pg_namespace n ON c.connamespace = n.oid WHERE n.nspname = 'public' AND c.conrelid = 'public.access_token_roles'::regclass AND c.contype = 'p') THEN ALTER TABLE public.access_token_roles ADD PRIMARY KEY (user_name, token_name, user_role_id); END IF; IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'access_token_roles_token_fkey') THEN ALTER TABLE public.access_token_roles ADD CONSTRAINT access_token_roles_token_fkey FOREIGN KEY (user_name, token_name) REFERENCES public.access_token(user_name, token_name) ON DELETE CASCADE; END IF; IF NOT EXISTS (SELECT 1 FROM pg_constraint c JOIN pg_namespace n ON c.connamespace = n.oid WHERE n.nspname = 'public' AND c.conrelid = 'public.role_external_mappings'::regclass AND c.contype = 'p') THEN ALTER TABLE public.role_external_mappings ADD PRIMARY KEY (role_name, external_role); END IF; INSERT INTO public.role_external_mappings (role_name, external_role) SELECT name, name FROM public.roles ON CONFLICT (role_name, external_role) DO NOTHING; DELETE FROM public.profile WHERE user_name NOT IN (SELECT id FROM public.users); IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'profile_user_name_fkey') THEN ALTER TABLE public.profile ADD CONSTRAINT profile_user_name_fkey FOREIGN KEY (user_name) REFERENCES public.users(id) ON DELETE CASCADE; END IF; DELETE FROM public.ueks WHERE uid NOT IN (SELECT id FROM public.users); IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'ueks_uid_fkey') THEN ALTER TABLE public.ueks ADD CONSTRAINT ueks_uid_fkey FOREIGN KEY (uid) REFERENCES public.users(id) ON DELETE CASCADE; END IF; END $$"
      }
    }
  ]
}
