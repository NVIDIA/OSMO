/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

/**
 * Access token role assignment.
 */
export interface AccessTokenRole {
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * Response for listing access token roles.
 */
export interface AccessTokenRolesResponse {
  user_name: string;
  token_name: string;
  roles: AccessTokenRole[];
}

/**
 * Access Token with roles.
 */
export interface AccessTokenWithRoles {
  user_name: string;
  token_name: string;
  expires_at: string;
  description: string;
  roles?: string[];
}

/**
 * Request to assign a role to a user.
 */
export interface AssignRoleRequest {
  role_name: string;
}

/**
 * Store a public/private key pair 
 */
export interface AsymmetricKeyPair {
  public_key: string;
  private_key: string;
}

export type AuthenticationConfigKeys = {[key: string]: AsymmetricKeyPair};

/**
 * Store info needed to login 
 */
export interface LoginInfo {
  device_endpoint?: string;
  device_client_id?: string;
  browser_endpoint?: string;
  browser_client_id?: string;
  token_endpoint?: string;
  logout_endpoint?: string;
}

/**
 * Store info needed to generate and validate idtokens 
 */
export interface AuthenticationConfig {
  keys: AuthenticationConfigKeys;
  active_key: string;
  issuer: string;
  audience: string;
  user_roles?: string[];
  ctrl_roles?: string[];
  login_info?: LoginInfo;
  max_token_duration?: string;
}

/**
 * Defines the type of scheduler used by the backend 
 */
export type BackendSchedulerType = typeof BackendSchedulerType[keyof typeof BackendSchedulerType];


export const BackendSchedulerType = {
  kai: 'kai',
} as const;

/**
 * Settings that control the how pods are scheduled in a backend
 */
export interface BackendSchedulerSettings {
  scheduler_type?: BackendSchedulerType;
  scheduler_name?: string;
  scheduler_timeout?: number;
}

export type BackendNodeConditionsRules = {[key: string]: string};

/**
 * Settings for backend node conditions. 
 */
export interface BackendNodeConditions {
  rules?: BackendNodeConditionsRules;
  prefix?: string;
}

/**
 * Object storing backend info. 
 */
export interface Backend {
  name: string;
  description: string;
  version: string;
  k8s_uid: string;
  k8s_namespace: string;
  dashboard_url: string;
  grafana_url: string;
  tests: string[];
  scheduler_settings: BackendSchedulerSettings;
  node_conditions: BackendNodeConditions;
  last_heartbeat: string;
  created_date: string;
  router_address: string;
  online: boolean;
}

/**
 * Similar to connectors.Backend, but with optional fields.
 */
export interface BackendConfig {
  description?: string;
  k8s_uid?: string;
  dashboard_url?: string;
  grafana_url?: string;
  tests?: string[];
  scheduler_settings?: BackendSchedulerSettings;
  node_conditions?: BackendNodeConditions;
  router_address?: string;
}

/**
 * Resource type for BackendResource. 
 */
export type BackendResourceType = typeof BackendResourceType[keyof typeof BackendResourceType];


export const BackendResourceType = {
  RESERVED: 'RESERVED',
  SHARED: 'SHARED',
  UNUSED: 'UNUSED',
} as const;

export type BackendTestsParsedPodTemplate = { [key: string]: unknown };

/**
 * Represents a test config. 
 */
export interface BackendTests {
  /** @minLength 1 */
  name: string;
  description: string;
  /** @minLength 1 */
  cron_schedule: string;
  test_timeout?: string;
  /** @minItems 1 */
  node_conditions: string[];
  /** @minItems 1 */
  common_pod_template: string[];
  parsed_pod_template?: BackendTestsParsedPodTemplate;
}

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel = { [key: string]: unknown };

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata = { [key: string]: unknown };

export interface BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost {
  set_label?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel;
  set_metadata?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface DatasetStructure {
  /** @pattern ^[a-zA-Z0-9_-]+$ */
  name: string;
  /** @pattern ^([a-zA-Z0-9_-]*)$ */
  tag: string;
}

export interface BodyCreateCollectionApiBucketBucketDatasetNameCollectPost {
  datasets: DatasetStructure[];
}

/**
 * Static data credentials (i.e. credentials with access_key_id and access_key) for a data backend.
 */
export interface StaticDataCredential {
  /** The OSMO storage URI for the data service (e.g., s3://bucket) */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** HTTP endpoint URL override the storage URI (e.g., http://minio:9000) */
  override_url?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The encrypted authentication secret for a data backend */
  access_key: string;
}

/**
 * Class to store the name of the bucket and the dataset path
 */
export interface BucketConfig {
  /** @pattern (^swift://[^/,;*]+(/[^/,;*]+){2,}/*$|^s3://[^/,;*]+(/[^/,;*]+)*\/*$|^gs://[^/,;*]+(/[^/,;*]+)*\/*$|^tos://[^/,;*]+(/[^/,;*]+)+/*$|^azure://[^/,;*]+(/[^/,;*]+)+/*$) */
  dataset_path: string;
  region?: string;
  description?: string;
  mode?: string;
  default_credential?: StaticDataCredential;
}

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoEntry {
  path: string;
  description: string;
  mode: string;
  default_cred: boolean;
}

export type BucketInfoResponseBuckets = {[key: string]: BucketInfoEntry};

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoResponse {
  default?: string;
  buckets: BucketInfoResponseBuckets;
}

/**
 * Request to bulk assign a role to users.
 */
export interface BulkAssignRequest {
  user_ids: string[];
}

/**
 * Response for bulk role assignment.
 */
export interface BulkAssignResponse {
  role_name: string;
  assigned: string[];
  already_assigned: string[];
  failed: string[];
}

/**
 * Object storing workflow name. 
 */
export interface CancelResponse {
  name: string;
}

/**
 * Config for storing information regarding CLI storage. 
 */
export interface CliConfig {
  latest_version?: string;
  min_supported_version?: string;
  client_install_url?: string;
}

/**
 * Response body for config diff endpoint.
 */
export interface ConfigDiffResponse {
  first_data?: unknown;
  second_data?: unknown;
}

/**
 * Type of configs supported by config history 
 */
export type SrcLibUtilsConfigHistoryConfigHistoryType = typeof SrcLibUtilsConfigHistoryConfigHistoryType[keyof typeof SrcLibUtilsConfigHistoryConfigHistoryType];


export const SrcLibUtilsConfigHistoryConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  GROUP_TEMPLATE: 'GROUP_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

/**
 * Object storing config history.
 */
export interface ConfigHistory {
  config_type: SrcLibUtilsConfigHistoryConfigHistoryType;
  name: string;
  revision: number;
  username: string;
  created_at: string;
  description: string;
  tags?: string[];
  data?: unknown;
}

/**
 * Request body for updating configurations with history tracking metadata.
 */
export interface ConfigsRequest {
  description?: string;
  tags?: string[];
}

/**
 * Request to create a new user.
 */
export interface CreateUserRequest {
  id: string;
  roles?: string[];
}

/**
 * Stores registries/data which do not do validation 
 */
export interface CredentialConfig {
  disable_registry_validation?: string[];
  disable_data_validation?: string[];
}

export type CredentialGetResponseCredentialsItem = {[key: string]: string};

/**
 * Credential Response. 
 */
export interface CredentialGetResponse {
  credentials: CredentialGetResponseCredentialsItem[];
}

/**
 * Authentication information for a Docker registry. 
 */
export interface UserRegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth: string;
}

/**
 * Authentication information for a data service. 
 */
export interface UserDataCredential {
  /** The OSMO storage URI for the data service (e.g., s3://bucket) */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** HTTP endpoint URL override the storage URI (e.g., http://minio:9000) */
  override_url?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The authentication secret for a data backend */
  access_key: string;
}

/**
 * The credential dictionary that contains authentication information
 */
export type UserCredentialCredential = {[key: string]: string};

/**
 * Generic authentication information. 
 */
export interface UserCredential {
  /** The credential dictionary that contains authentication information */
  credential: UserCredentialCredential;
}

/**
 * Credential options 
 */
export interface CredentialOptions {
  /** Authentication information for a Docker registry */
  registry_credential?: UserRegistryCredential;
  /** Authentication information for a data service */
  data_credential?: UserDataCredential;
  /** Generic authentication information */
  generic_credential?: UserCredential;
}

/**
 * Object storing Tag Response. 
 */
export interface DataTagResponse {
  version_id: string;
  tags: string[];
}

export type DataMetadataResponseMetadata = { [key: string]: unknown };

/**
 * Object storing Label/Metadata Response. 
 */
export interface DataMetadataResponse {
  metadata: DataMetadataResponseMetadata;
}

/**
 * Object storing Tag/Label/Metadata Response. 
 */
export interface DataAttributeResponse {
  tag_response?: DataTagResponse;
  label_response?: DataMetadataResponse;
  metadata_response?: DataMetadataResponse;
}

/**
 * Type of Config to fetch or set 
 */
export type DownloadType = typeof DownloadType[keyof typeof DownloadType];


export const DownloadType = {
  download: 'download',
} as const;

/**
 * Config for storing information about data. 
 */
export interface DataConfig {
  credential?: StaticDataCredential;
  base_url?: string;
  websocket_timeout?: number;
  data_timeout?: number;
  download_type?: DownloadType;
}

/**
 * Object storing Info Element. 
 */
export interface DataInfoCollectionEntry {
  name: string;
  version: string;
  location: string;
  uri: string;
  hash_location?: string;
  size: number;
}

export type DataInfoDatasetEntryMetadata = { [key: string]: unknown };

/**
 * The status of a dataset / dataset version.
 */
export type DatasetStatus = typeof DatasetStatus[keyof typeof DatasetStatus];


export const DatasetStatus = {
  PENDING: 'PENDING',
  READY: 'READY',
  PENDING_DELETE: 'PENDING_DELETE',
  DELETED: 'DELETED',
} as const;

/**
 * Object storing Info Element. 
 */
export interface DataInfoDatasetEntry {
  name: string;
  version: string;
  status: DatasetStatus;
  created_by: string;
  created_date: string;
  last_used: string;
  size: number;
  checksum: string;
  location: string;
  uri: string;
  metadata: DataInfoDatasetEntryMetadata;
  tags: string[];
  collections: string[];
}

export type DataInfoResponseLabels = { [key: string]: unknown };

/**
 * An enumeration.
 */
export type DatasetType = typeof DatasetType[keyof typeof DatasetType];


export const DatasetType = {
  COLLECTION: 'COLLECTION',
  DATASET: 'DATASET',
} as const;

/**
 * Object storing Data Info Elements. 
 */
export interface DataInfoResponse {
  name: string;
  id: string;
  bucket: string;
  created_by?: string;
  created_date?: string;
  hash_location?: string;
  hash_location_size?: number;
  labels: DataInfoResponseLabels;
  type: DatasetType;
  versions: (DataInfoDatasetEntry | DataInfoCollectionEntry)[];
}

/**
 * Object storing Data List Element. 
 */
export interface DataListEntry {
  name: string;
  id: string;
  bucket: string;
  create_time: string;
  last_created?: string;
  hash_location?: string;
  hash_location_size?: number;
  version_id?: string;
  type: DatasetType;
}

/**
 * Object storing Data List Elements. 
 */
export interface DataListResponse {
  datasets: DataListEntry[];
}

/**
 * An enumeration.
 */
export type DatasetQueryType = typeof DatasetQueryType[keyof typeof DatasetQueryType];


export const DatasetQueryType = {
  VERSION: 'VERSION',
  DATASET: 'DATASET',
} as const;

/**
 * Object storing Dataset and Dataset Version Info. 
 */
export interface DataQueryResponse {
  type: DatasetQueryType;
  datasets: (DataInfoResponse | DataInfoDatasetEntry)[];
}

export type DatasetConfigBuckets = {[key: string]: BucketConfig};

/**
 * Stores any dataset configs External Admins control 
 */
export interface DatasetConfig {
  buckets?: DatasetConfigBuckets;
  default_bucket?: string;
}

/**
 * Request body for deleting a backend with history tracking metadata.
 */
export interface DeleteBackendRequest {
  description?: string;
  tags?: string[];
  force?: boolean;
}

export interface EditResponse {
  uuid: string;
  version: number;
  name: string;
  created_by: string;
  created_date: string;
}

/**
 * Represents the types of statuses a pool can have. 
 */
export type PoolStatus = typeof PoolStatus[keyof typeof PoolStatus];


export const PoolStatus = {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MAINTENANCE: 'MAINTENANCE',
} as const;

/**
 * Resources like GPU or CPU that have a discrete number. For guarantee and maximum, a value of -1
indicates that there is no limit.
 */
export interface PoolResourceCountable {
  guarantee?: number;
  maximum?: number;
  weight?: number;
}

/**
 * Resources allocated to the pool, for schedulers that support this feature 
 */
export interface PoolResources {
  gpu?: PoolResourceCountable;
}

/**
 * Defines a topology key for pool configuration
 */
export interface TopologyKey {
  key: string;
  label: string;
}

export type PlatformEditableDefaultVariables = { [key: string]: unknown };

/**
 * Single Platform Entry 
 */
export interface PlatformEditable {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_variables?: PlatformEditableDefaultVariables;
  resource_validations?: string[];
  override_pod_template?: string[];
}

export type PoolEditableDefaultExitActions = {[key: string]: string};

export type PoolEditableCommonDefaultVariables = { [key: string]: unknown };

export type PoolEditablePlatforms = {[key: string]: PlatformEditable};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolEditable {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolEditableDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  common_default_variables?: PoolEditableCommonDefaultVariables;
  common_resource_validations?: string[];
  common_pod_template?: string[];
  common_group_templates?: string[];
  platforms?: PoolEditablePlatforms;
}

export type EditablePoolConfigPools = {[key: string]: PoolEditable};

/**
 * Stores editable pool configs.
 */
export interface EditablePoolConfig {
  pools?: EditablePoolConfigPools;
}

/**
 * Response body for config history endpoint.
 */
export interface GetConfigsHistoryResponse {
  configs: ConfigHistory[];
}

/**
 * Represents the status of a task group 
 */
export type TaskGroupStatus = typeof TaskGroupStatus[keyof typeof TaskGroupStatus];


export const TaskGroupStatus = {
  SUBMITTING: 'SUBMITTING',
  WAITING: 'WAITING',
  PROCESSING: 'PROCESSING',
  SCHEDULING: 'SCHEDULING',
  INITIALIZING: 'INITIALIZING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  RESCHEDULED: 'RESCHEDULED',
  FAILED: 'FAILED',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_UPSTREAM: 'FAILED_UPSTREAM',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Represents the queryed group information. 
 */
export interface TaskQueryResponse {
  name: string;
  retry_id: number;
  status: TaskGroupStatus;
  failure_message?: string;
  exit_code?: number;
  logs: string;
  error_logs?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  events: string;
  start_time?: string;
  end_time?: string;
  input_download_start_time?: string;
  input_download_end_time?: string;
  output_upload_start_time?: string;
  dashboard_url?: string;
  pod_name: string;
  pod_ip?: string;
  task_uuid: string;
  node_name?: string;
  lead?: boolean;
}

/**
 * Represents the queryed task information. 
 */
export interface GroupQueryResponse {
  name: string;
  status: TaskGroupStatus;
  start_time?: string;
  end_time?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  remaining_upstream_groups?: string[];
  downstream_groups?: string[];
  failure_message?: string;
  tasks?: TaskQueryResponse[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Object storing info for all backends. 
 */
export interface ListBackendsResponse {
  backends: Backend[];
}

/**
 * Represents the list order for the database. 
 */
export type ListOrder = typeof ListOrder[keyof typeof ListOrder];


export const ListOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const;

/**
 * Entry for task list API results, aggregated by workflow. 
 */
export interface ListTaskAggregatedEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
  workflow_id: string;
}

export interface ListTaskAggregatedResponse {
  summaries: ListTaskAggregatedEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskEntry {
  user: string;
  workflow_id: string;
  workflow_uuid: string;
  task_name: string;
  retry_id: number;
  pool?: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  duration?: number;
  status: TaskGroupStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskResponse {
  tasks: ListTaskEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskSummaryEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskSummaryResponse {
  summaries: ListTaskSummaryEntry[];
}

/**
 * Config for storing information about data. 
 */
export interface LogConfig {
  credential?: StaticDataCredential;
}

/**
 * Single Platform Entry 
 */
export interface PlatformMinimal {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
}

export type PoolMinimalDefaultExitActions = {[key: string]: string};

export type PoolMinimalPlatforms = {[key: string]: PlatformMinimal};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolMinimal {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolMinimalDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  platforms?: PoolMinimalPlatforms;
}

export type MinimalPoolConfigPools = {[key: string]: PoolMinimal};

/**
 * Stores minimal pool configs.
 */
export interface MinimalPoolConfig {
  pools?: MinimalPoolConfigPools;
}

export interface SMTPConfig {
  host?: string;
  sender?: string;
  password?: string;
}

export interface NotificationConfig {
  slack_token?: string;
  smtp_settings?: SMTPConfig;
}

/**
 * An enumeration.
 */
export type OperatorType = typeof OperatorType[keyof typeof OperatorType];


export const OperatorType = {
  GT: 'GT',
  GE: 'GE',
  LT: 'LT',
  LE: 'LE',
  EQ: 'EQ',
} as const;

/**
 * Authentication information for a Docker registry. 
 */
export interface RegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth?: string;
}

/**
 * Dynamic Config for storing the image URLs for service images and the credentials needed
to pull them.
 */
export interface OsmoImageConfig {
  init?: string;
  client?: string;
  credential?: RegistryCredential;
}

export type PatchBackendTestRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a test with history tracking metadata.
 */
export interface PatchBackendTestRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchBackendTestRequestConfigsDict;
}

export type PatchConfigRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching configurations with history tracking metadata.
 */
export interface PatchConfigRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchConfigRequestConfigsDict;
}

export type PatchDatasetRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a dataset bucket configuration with history tracking metadata.
 */
export interface PatchDatasetRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchDatasetRequestConfigsDict;
}

export type PatchPoolRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a pool with history tracking metadata.
 */
export interface PatchPoolRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchPoolRequestConfigsDict;
}

export type PlatformLabels = {[key: string]: string};

export type PlatformDefaultVariables = { [key: string]: unknown };

export type PlatformParsedPodTemplate = { [key: string]: unknown };

/**
 * Single Toleration Entry 
 */
export interface Toleration {
  key: string;
  operator?: string;
  value?: string;
  effect?: string;
}

/**
 * Class for defining resource restrictions.
 */
export interface ResourceAssertion {
  operator: OperatorType;
  left_operand: string;
  right_operand: string;
  assert_message: string;
}

/**
 * Single Platform Entry 
 */
export interface Platform {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
  tolerations?: Toleration[];
  labels?: PlatformLabels;
  default_variables?: PlatformDefaultVariables;
  resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  override_pod_template?: string[];
  parsed_pod_template?: PlatformParsedPodTemplate;
}

/**
 * Stores a single allowed path for rsync 
 */
export interface RsyncAllowedPath {
  path: string;
  writable?: boolean;
}

export type RsyncConfigAllowedPaths = {[key: string]: RsyncAllowedPath};

/**
 * Stores all configs for rsync 
 */
export interface RsyncConfig {
  enabled?: boolean;
  enable_telemetry?: boolean;
  /**
   * User pod's rsync read bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  read_bandwidth_limit?: number;
  /**
   * User pod's rsync write bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  write_bandwidth_limit?: number;
  allowed_paths?: RsyncConfigAllowedPaths;
  /**
   * Daemon debounce delay for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_debounce_delay?: number;
  /**
   * Daemon poll interval for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_poll_interval?: number;
  /**
   * Daemon reconcile interval for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_reconcile_interval?: number;
  /**
   * Client upload rate limit for rsync in bytes per second, zero means no limit
   * @minimum 0
   */
  client_upload_rate_limit?: number;
}

/**
 * Stores any plugins configs 
 */
export interface PluginsConfig {
  rsync?: RsyncConfig;
}

/**
 * Effect of a policy statement: Allow or Deny. Deny takes precedence over Allow.
 */
export type PolicyEffect = typeof PolicyEffect[keyof typeof PolicyEffect];


export const PolicyEffect = {
  Allow: 'Allow',
  Deny: 'Deny',
} as const;

export type PoolDefaultExitActions = {[key: string]: string};

export type PoolCommonDefaultVariables = { [key: string]: unknown };

export type PoolParsedPodTemplate = { [key: string]: unknown };

export type PoolParsedGroupTemplatesItem = { [key: string]: unknown };

export type PoolPlatforms = {[key: string]: Platform};

/**
 * Single Pool Entry 
 */
export interface Pool {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  common_default_variables?: PoolCommonDefaultVariables;
  common_resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  common_pod_template?: string[];
  parsed_pod_template?: PoolParsedPodTemplate;
  common_group_templates?: string[];
  parsed_group_templates?: PoolParsedGroupTemplatesItem[];
  platforms?: PoolPlatforms;
  last_heartbeat?: string;
}

/**
 * Object storing resource usage information. 
 */
export interface ResourceUsage {
  quota_used: string;
  quota_free: string;
  quota_limit: string;
  total_usage: string;
  total_capacity: string;
  total_free: string;
}

export type PoolResourceUsageDefaultExitActions = {[key: string]: string};

export type PoolResourceUsagePlatforms = {[key: string]: PlatformMinimal};

/**
 * Object storing pool information. 
 */
export interface PoolResourceUsage {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolResourceUsageDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  platforms?: PoolResourceUsagePlatforms;
  resource_usage: ResourceUsage;
}

/**
 * Object storing pool node set information. 
 */
export interface PoolNodeSetResourceUsage {
  pools: PoolResourceUsage[];
}

export type PoolResourcesEntryUsageFields = { [key: string]: unknown };

export type PoolResourcesEntryAllocatableFields = { [key: string]: unknown };

/**
 * Entry for resources API results. 
 */
export interface PoolResourcesEntry {
  pool: string;
  platform: string;
  status: PoolStatus;
  usage_fields: PoolResourcesEntryUsageFields;
  allocatable_fields: PoolResourcesEntryAllocatableFields;
  backend: string;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface PoolResourcesResponse {
  pools: PoolResourcesEntry[];
}

/**
 * Object storing pool information. 
 */
export interface PoolResponse {
  node_sets: PoolNodeSetResourceUsage[];
  resource_sum: ResourceUsage;
}

/**
 * Request body for creating a new backend with history tracking metadata.
 */
export interface PostBackendRequest {
  description?: string;
  tags?: string[];
  configs: BackendConfig;
}

/**
 * Provides all User Profile Information 
 */
export interface UserProfile {
  username?: string;
  email_notification?: boolean;
  slack_notification?: boolean;
  bucket?: string;
  pool?: string;
}

/**
 * Identity when the request is authenticated with an access token. 
 */
export interface TokenIdentity {
  name: string;
  expires_at?: string;
}

/**
 * Profile and identity info. When token header is set, roles/pools are the
token's; otherwise they are the user's. JSON is self-explanatory for CLI.
 */
export interface ProfileResponse {
  profile: UserProfile;
  roles: string[];
  pools: string[];
  token?: TokenIdentity;
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestRequest {
  description?: string;
  tags?: string[];
  configs: BackendTests;
}

export type PutBackendTestsRequestConfigs = {[key: string]: BackendTests};

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestsRequest {
  description?: string;
  tags?: string[];
  configs: PutBackendTestsRequestConfigs;
}

/**
 * Request body for updating dataset configurations with history tracking metadata.
 */
export interface PutDatasetRequest {
  description?: string;
  tags?: string[];
  configs: DatasetConfig;
}

export type PutGroupTemplateRequestConfigs = { [key: string]: unknown };

/**
 * Request body for updating a group template with history tracking metadata.
 */
export interface PutGroupTemplateRequest {
  description?: string;
  tags?: string[];
  configs: PutGroupTemplateRequestConfigs;
}

export type PutGroupTemplatesRequestConfigs = {[key: string]: { [key: string]: unknown }};

/**
 * Request body for updating group templates with history tracking metadata.
 */
export interface PutGroupTemplatesRequest {
  description?: string;
  tags?: string[];
  configs: PutGroupTemplatesRequestConfigs;
}

export type PutPodTemplateRequestConfigs = { [key: string]: unknown };

/**
 * Request body for updating a pod template with history tracking metadata.
 */
export interface PutPodTemplateRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplateRequestConfigs;
}

export type PutPodTemplatesRequestConfigs = {[key: string]: { [key: string]: unknown }};

/**
 * Request body for updating pod templates with history tracking metadata.
 */
export interface PutPodTemplatesRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplatesRequestConfigs;
}

/**
 * Request body for updating a platform in a pool with history tracking metadata.
 */
export interface PutPoolPlatformRequest {
  description?: string;
  tags?: string[];
  configs: Platform;
}

/**
 * Request body for updating a pool with history tracking metadata.
 */
export interface PutPoolRequest {
  description?: string;
  tags?: string[];
  configs: Pool;
}

export type PutPoolsRequestConfigs = {[key: string]: Pool};

/**
 * Request body for updating pools with history tracking metadata.
 */
export interface PutPoolsRequest {
  description?: string;
  tags?: string[];
  configs: PutPoolsRequestConfigs;
}

export type PutResourceValidationRequestConfigsItem = { [key: string]: unknown };

/**
 * Request body for updating a resource validation with history tracking metadata.
 */
export interface PutResourceValidationRequest {
  description?: string;
  tags?: string[];
  configs: PutResourceValidationRequestConfigsItem[];
}

export type PutResourceValidationsRequestConfigsDictItem = { [key: string]: unknown };

export type PutResourceValidationsRequestConfigsDict = {[key: string]: PutResourceValidationsRequestConfigsDictItem[]};

/**
 * Request body for updating resource validations with history tracking metadata.
 */
export interface PutResourceValidationsRequest {
  description?: string;
  tags?: string[];
  configs_dict: PutResourceValidationsRequestConfigsDict;
}

/**
 * Single Role Policy Entry.

Contains a list of actions (semantic format "resource:Action") and optional
resources the policy applies to. If effect is Deny and the policy matches,
access is denied even if another policy allows it.

Actions are validated via regex; API/DB still use [{"action": "..."}] for
compatibility with the Go authz_sidecar.
 */
export interface RolePolicy {
  effect?: PolicyEffect;
  actions: string[];
  resources?: string[];
}

/**
 * Sync mode for role assignments.

- FORCE: Always apply this role to all users (e.g., for system roles)
- IMPORT: Role is imported from IDP claims or user_roles table (default)
- IGNORE: Ignore this role in IDP sync (role is managed manually)
 */
export type SyncMode = typeof SyncMode[keyof typeof SyncMode];


export const SyncMode = {
  force: 'force',
  import: 'import',
  ignore: 'ignore',
} as const;

/**
 * Single Role Entry.

Note: Authorization checking is now handled by the authz_sidecar (Go service).
This Python class is only used for role CRUD operations.
 */
export interface Role {
  name: string;
  description: string;
  policies: RolePolicy[];
  immutable?: boolean;
  sync_mode?: SyncMode;
  external_roles?: string[];
}

/**
 * Request body for updating a role with history tracking metadata.
 */
export interface PutRoleRequest {
  description?: string;
  tags?: string[];
  configs: Role;
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutRolesRequest {
  description?: string;
  tags?: string[];
  configs: Role[];
}

/**
 * Stores any configs OSMO Admins control 
 */
export interface ServiceConfig {
  service_base_url?: string;
  service_auth?: AuthenticationConfig;
  cli_config?: CliConfig;
  max_pod_restart_limit?: string;
  agent_queue_size?: number;
}

/**
 * Request body for updating service configurations with history tracking metadata.
 */
export interface PutServiceRequest {
  description?: string;
  tags?: string[];
  configs: ServiceConfig;
}

/**
 * Config for workflow storage info. 
 */
export interface WorkflowInfo {
  tags?: string[];
  max_name_length?: number;
}

/**
 * Stores workflow limits per user. Default is None, which means no limit.
If a limit is set, it must be greater than 0.
 */
export interface UserWorkflowLimitConfig {
  /** @exclusiveMinimum 0 */
  max_num_workflows?: number;
  /** @exclusiveMinimum 0 */
  max_num_tasks?: number;
  jinja_sandbox_workers?: number;
  jinja_sandbox_max_time?: number;
  jinja_sandbox_memory_limit?: number;
}

/**
 * Stores any workflow configs External Admins control 
 */
export interface WorkflowConfig {
  workflow_data?: DataConfig;
  workflow_log?: LogConfig;
  workflow_app?: LogConfig;
  workflow_info?: WorkflowInfo;
  backend_images?: OsmoImageConfig;
  workflow_alerts?: NotificationConfig;
  credential_config?: CredentialConfig;
  user_workflow_limits?: UserWorkflowLimitConfig;
  plugins_config?: PluginsConfig;
  max_num_tasks?: number;
  max_num_ports_per_task?: number;
  max_retry_per_task?: number;
  max_retry_per_job?: number;
  default_schedule_timeout?: number;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  force_cleanup_delay?: string;
  max_log_lines?: number;
  max_task_log_lines?: number;
  max_error_log_lines?: number;
  max_event_log_lines?: number;
  task_heartbeat_frequency?: string;
}

/**
 * Request body for updating workflow configurations with history tracking metadata.
 */
export interface PutWorkflowRequest {
  description?: string;
  tags?: string[];
  configs: WorkflowConfig;
}

/**
 * Request body for renaming a platform in a pool with history tracking metadata.
 */
export interface RenamePoolPlatformRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

/**
 * Request body for renaming a pool with history tracking metadata.
 */
export interface RenamePoolRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

export type ResourcesEntryExposedFields = { [key: string]: unknown };

export type ResourcesEntryTaintsItem = { [key: string]: unknown };

export type ResourcesEntryUsageFields = { [key: string]: unknown };

export type ResourcesEntryNonWorkflowUsageFields = { [key: string]: unknown };

export type ResourcesEntryAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAvailableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformWorkflowAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryConfigFields = { [key: string]: unknown };

export type ResourcesEntryLabelFields = { [key: string]: unknown };

export type ResourcesEntryPoolPlatformLabels = {[key: string]: string[]};

/**
 * Entry for resources API results. 
 */
export interface ResourcesEntry {
  hostname: string;
  exposed_fields: ResourcesEntryExposedFields;
  taints: ResourcesEntryTaintsItem[];
  usage_fields: ResourcesEntryUsageFields;
  conditions?: string[];
  non_workflow_usage_fields: ResourcesEntryNonWorkflowUsageFields;
  allocatable_fields: ResourcesEntryAllocatableFields;
  platform_allocatable_fields?: ResourcesEntryPlatformAllocatableFields;
  platform_available_fields?: ResourcesEntryPlatformAvailableFields;
  platform_workflow_allocatable_fields?: ResourcesEntryPlatformWorkflowAllocatableFields;
  config_fields?: ResourcesEntryConfigFields;
  backend: string;
  label_fields?: ResourcesEntryLabelFields;
  pool_platform_labels: ResourcesEntryPoolPlatformLabels;
  resource_type: BackendResourceType;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface ResourcesResponse {
  resources: ResourcesEntry[];
}

export type RoleUsersResponseUsersItem = { [key: string]: unknown };

/**
 * Response for listing users with a role.
 */
export interface RoleUsersResponse {
  role_name: string;
  users: RoleUsersResponseUsersItem[];
}

/**
 * Type of configs supported by config history 
 */
export type SrcUtilsConnectorsPostgresConfigHistoryType = typeof SrcUtilsConnectorsPostgresConfigHistoryType[keyof typeof SrcUtilsConnectorsPostgresConfigHistoryType];


export const SrcUtilsConnectorsPostgresConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  GROUP_TEMPLATE: 'GROUP_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

/**
 * Request body for config rollback endpoint.
 */
export interface RollbackConfigRequest {
  description?: string;
  tags?: string[];
  config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
  /**
   * Revision to roll back to
   * @exclusiveMinimum 0
   */
  revision: number;
}

/**
 * Router Information Response. 
 */
export interface RouterResponse {
  router_address: string;
  key: string;
  cookie: string;
}

/**
 * Object storing workflow name, logs, and spec after submission. 
 */
export interface SubmitResponse {
  name: string;
  overview?: string;
  logs?: string;
  spec?: string;
  dashboard_url?: string;
}

/**
 * Entry for task GET API result. 
 */
export interface TaskEntry {
  workflow_id: string;
  task_name: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  status: TaskGroupStatus;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
}

/**
 * Template Spec. 
 */
export interface TemplateSpec {
  file: string;
  set_variables?: string[];
  set_string_variables?: string[];
  uploaded_templated_spec?: string;
}

/**
 * Request body for updating config tags endpoint.
 */
export interface UpdateConfigTagsRequest {
  /** Tags to add to the config */
  set_tags?: string[];
  /** Tags to remove from the config */
  delete_tags?: string[];
}

/**
 * User record.
 */
export interface User {
  id: string;
  created_at?: string;
  created_by?: string;
}

/**
 * Response for listing users.
 */
export interface UserListResponse {
  total_results: number;
  start_index: number;
  items_per_page: number;
  users: User[];
}

/**
 * User role assignment.
 */
export interface UserRole {
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * User role assignment response.
 */
export interface UserRoleAssignment {
  user_id: string;
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * Response for listing user roles.
 */
export interface UserRolesResponse {
  user_id: string;
  roles: UserRole[];
}

/**
 * User record with role assignments.
 */
export interface UserWithRoles {
  id: string;
  created_at?: string;
  created_by?: string;
  roles?: UserRole[];
}

export type VerbosePoolConfigPools = {[key: string]: Pool};

/**
 * Stores verbose pool configs.
 */
export interface VerbosePoolConfig {
  pools?: VerbosePoolConfigPools;
}

/**
 * Represents the state of plugins in a workflow upon submission. 
 */
export interface WorkflowPlugins {
  rsync?: boolean;
}

/**
 * Scheduling priority for workflows
 */
export type WorkflowPriority = typeof WorkflowPriority[keyof typeof WorkflowPriority];


export const WorkflowPriority = {
  HIGH: 'HIGH',
  NORMAL: 'NORMAL',
  LOW: 'LOW',
} as const;

/**
 * Represents the status of a workflow. 
 */
export type WorkflowStatus = typeof WorkflowStatus[keyof typeof WorkflowStatus];


export const WorkflowStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  WAITING: 'WAITING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  FAILED_SUBMISSION: 'FAILED_SUBMISSION',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Represents the queryed workflow information. 
 */
export interface WorkflowQueryResponse {
  name: string;
  uuid: string;
  submitted_by: string;
  cancelled_by?: string;
  spec: string;
  template_spec: string;
  logs: string;
  events: string;
  overview: string;
  parent_name?: string;
  parent_job_id?: number;
  dashboard_url?: string;
  grafana_url?: string;
  tags?: string[];
  submit_time: string;
  start_time?: string;
  end_time?: string;
  exec_timeout?: number;
  queue_timeout?: number;
  duration?: number;
  queued_time: number;
  status: WorkflowStatus;
  outputs?: string;
  groups: GroupQueryResponse[];
  pool?: string;
  backend?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  plugins: WorkflowPlugins;
  priority: string;
}

export interface SrcServiceCoreAppObjectsListEntry {
  uuid: string;
  name: string;
  description: string;
  created_date: string;
  owner: string;
  latest_version: string;
}

export interface SrcServiceCoreAppObjectsListResponse {
  apps: SrcServiceCoreAppObjectsListEntry[];
  more_entries: boolean;
}

/**
 * Entry for list API results. 
 */
export interface SrcServiceCoreWorkflowObjectsListEntry {
  user: string;
  name: string;
  workflow_uuid: string;
  submit_time: string;
  start_time?: string;
  end_time?: string;
  queued_time: number;
  duration?: number;
  status: WorkflowStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  pool?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  priority: string;
}

export interface SrcServiceCoreWorkflowObjectsListResponse {
  workflows: SrcServiceCoreWorkflowObjectsListEntry[];
  more_entries: boolean;
}

export type PutServiceConfigsApiConfigsServicePut200 = { [key: string]: unknown };

export type PatchServiceConfigsApiConfigsServicePatch200 = { [key: string]: unknown };

export type PutWorkflowConfigsApiConfigsWorkflowPut200 = { [key: string]: unknown };

export type PatchWorkflowConfigsApiConfigsWorkflowPatch200 = { [key: string]: unknown };

export type PutDatasetConfigsApiConfigsDatasetPut200 = { [key: string]: unknown };

export type PatchDatasetConfigsApiConfigsDatasetPatch200 = { [key: string]: unknown };

export type PatchDatasetApiConfigsDatasetNamePatch200 = { [key: string]: unknown };

export type ListPoolsApiConfigsPoolGetParams = {
verbose?: boolean;
backend?: string;
};

export type ReadPoolApiConfigsPoolNameGetParams = {
verbose?: boolean;
};

export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams = {
verbose?: boolean;
};

export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams = {
verbose?: boolean;
};

export type GetConfigsHistoryApiConfigsHistoryGetParams = {
/**
 * Number of records to skip
 * @minimum 0
 */
offset?: number;
/**
 * Maximum number of records to return
 * @maximum 1000
 * @exclusiveMinimum 0
 */
limit?: number;
/**
 * Sort order by creation time
 */
order?: ListOrder;
/**
 * Filter by config types
 */
config_types?: SrcLibUtilsConfigHistoryConfigHistoryType[];
/**
 * Filter by config name
 */
name?: string;
/**
 * Filter by revision
 * @exclusiveMinimum 0
 */
revision?: number;
/**
 * Filter by tags
 */
tags?: string[];
/**
 * Filter by creation time before
 */
created_before?: string;
/**
 * Filter by creation time after
 */
created_after?: string;
/**
 * Get config state at specific timestamp
 */
at_timestamp?: string;
/**
 * Whether to omit data from the response
 */
omit_data?: boolean;
};

export type GetConfigDiffApiConfigsDiffGetParams = {
config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
/**
 * First revision to compare
 * @exclusiveMinimum 0
 */
first_revision: number;
/**
 * Second revision to compare
 * @exclusiveMinimum 0
 */
second_revision: number;
};

export type GetNewJwtTokenApiAuthJwtRefreshTokenGetParams = {
refresh_token: string;
workflow_id: string;
group_name: string;
task_name: string;
retry_id?: number;
};

export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams = {
access_token: string;
};

export type CreateAccessTokenApiAuthAccessTokenTokenNamePostParams = {
expires_at: string;
description?: string;
roles?: string[];
};

export type AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams = {
expires_at: string;
description?: string;
roles?: string[];
};

export type ListUsersApiAuthUserGetParams = {
start_index?: number;
count?: number;
id_prefix?: string;
roles?: string[];
};

export type ListAppsApiAppGetParams = {
name?: string;
users?: string[];
all_users?: boolean;
offset?: number;
limit?: number;
order?: ListOrder;
};

export type GetAppApiAppUserNameGetParams = {
version?: number;
limit?: number;
order?: ListOrder;
};

export type CreateAppApiAppUserNamePostParams = {
description: string;
};

export type DeleteAppApiAppUserNameDeleteParams = {
version?: number;
all_versions?: boolean;
};

export type DeleteAppApiAppUserNameDelete200 = {[key: string]: number[]};

export type GetAppContentApiAppUserNameSpecGetParams = {
version?: number;
};

export type CancelWorkflowApiWorkflowNameCancelPostParams = {
message?: string;
force?: boolean;
};

export type ListWorkflowApiWorkflowGetParams = {
users?: string[];
name?: string;
statuses?: WorkflowStatus[];
offset?: number;
limit?: number;
order?: ListOrder;
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
submitted_before?: string;
submitted_after?: string;
tags?: string[];
app?: string;
priority?: WorkflowPriority[];
};

export type ListTaskApiTaskGetParams = {
workflow_id?: string;
statuses?: TaskGroupStatus[];
users?: string[];
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
nodes?: string[];
started_after?: string;
started_before?: string;
offset?: number;
limit?: number;
order?: ListOrder;
summary?: boolean;
aggregate_by_workflow?: boolean;
priority?: WorkflowPriority[];
};

export type GetWorkflowApiWorkflowNameGetParams = {
skip_groups?: boolean;
verbose?: boolean;
};

export type GetWorkflowLogsApiWorkflowNameLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowPodConditionsApiWorkflowNameEventsGetParams = {
task_name?: string;
retry_id?: number;
};

export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowSpecApiWorkflowNameSpecGetParams = {
use_template?: boolean;
};

export type TagWorkflowApiWorkflowNameTagPostParams = {
add?: string[];
remove?: string[];
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams = {
entry_command: string;
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200 = {[key: string]: RouterResponse};

export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams = {
entry_command: string;
};

export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams = {
task_ports?: number[];
use_udp?: boolean;
};

export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams = {
task_port: number;
};

export type GetResourcesApiResourcesGetParams = {
pools?: string[];
platforms?: string[];
all_pools?: boolean;
concise?: boolean;
};

export type GetPoolsApiPoolGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type GetPoolQuotasApiPoolQuotaGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type SubmitWorkflowApiPoolPoolNameWorkflowPostParams = {
workflow_id?: string;
app_uuid?: string;
app_version?: number;
dry_run?: boolean;
validation_only?: boolean;
priority?: WorkflowPriority;
env_vars?: string[];
};

export type GetBucketInfoApiBucketGetParams = {
default_only?: boolean;
};

export type DeleteDatasetApiBucketBucketDatasetNameDeleteParams = {
tag?: string;
all_flag?: boolean;
finish?: boolean;
};

export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams = {
tag?: string;
new_name?: string;
set_tag?: string[];
delete_tag?: string[];
delete_label?: string[];
delete_metadata?: string[];
};

export type GetInfoApiBucketBucketDatasetNameInfoGetParams = {
tag?: string;
all_flag?: boolean;
count?: number;
order?: ListOrder;
};

export type ListDatasetFromBucketApiBucketListDatasetGetParams = {
name?: string;
user?: string[];
buckets?: string[];
dataset_type?: DatasetType;
latest_before?: string;
latest_after?: string;
all_users?: boolean;
order?: ListOrder;
count?: number;
};

export type QueryDatasetApiBucketBucketQueryGetParams = {
command?: string;
};

export type SetNotificationSettingsApiProfileSettingsPostParams = {
set_default_backend?: boolean;
};

/**
 * Read all the service configurations
 * @summary Read Service Configs
 */
export type readServiceConfigsApiConfigsServiceGetResponse200 = {
  data: string
  status: 200
}

export type readServiceConfigsApiConfigsServiceGetResponseSuccess = (readServiceConfigsApiConfigsServiceGetResponse200) & {
  headers: Headers;
};
;

export type readServiceConfigsApiConfigsServiceGetResponse = (readServiceConfigsApiConfigsServiceGetResponseSuccess)

export const getReadServiceConfigsApiConfigsServiceGetUrl = () => {


  

  return `/api/configs/service`
}

export const readServiceConfigsApiConfigsServiceGet = async ( options?: RequestInit): Promise<readServiceConfigsApiConfigsServiceGetResponse> => {
  
  const res = await fetch(getReadServiceConfigsApiConfigsServiceGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readServiceConfigsApiConfigsServiceGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readServiceConfigsApiConfigsServiceGetResponse
}
  


/**
 * Put service configurations
 * @summary Put Service Configs
 */
export type putServiceConfigsApiConfigsServicePutResponse200 = {
  data: PutServiceConfigsApiConfigsServicePut200
  status: 200
}

export type putServiceConfigsApiConfigsServicePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putServiceConfigsApiConfigsServicePutResponseSuccess = (putServiceConfigsApiConfigsServicePutResponse200) & {
  headers: Headers;
};
export type putServiceConfigsApiConfigsServicePutResponseError = (putServiceConfigsApiConfigsServicePutResponse422) & {
  headers: Headers;
};

export type putServiceConfigsApiConfigsServicePutResponse = (putServiceConfigsApiConfigsServicePutResponseSuccess | putServiceConfigsApiConfigsServicePutResponseError)

export const getPutServiceConfigsApiConfigsServicePutUrl = () => {


  

  return `/api/configs/service`
}

export const putServiceConfigsApiConfigsServicePut = async (putServiceRequest: PutServiceRequest, options?: RequestInit): Promise<putServiceConfigsApiConfigsServicePutResponse> => {
  
  const res = await fetch(getPutServiceConfigsApiConfigsServicePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putServiceRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putServiceConfigsApiConfigsServicePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putServiceConfigsApiConfigsServicePutResponse
}
  


/**
 * Patch service configurations
 * @summary Patch Service Configs
 */
export type patchServiceConfigsApiConfigsServicePatchResponse200 = {
  data: PatchServiceConfigsApiConfigsServicePatch200
  status: 200
}

export type patchServiceConfigsApiConfigsServicePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchServiceConfigsApiConfigsServicePatchResponseSuccess = (patchServiceConfigsApiConfigsServicePatchResponse200) & {
  headers: Headers;
};
export type patchServiceConfigsApiConfigsServicePatchResponseError = (patchServiceConfigsApiConfigsServicePatchResponse422) & {
  headers: Headers;
};

export type patchServiceConfigsApiConfigsServicePatchResponse = (patchServiceConfigsApiConfigsServicePatchResponseSuccess | patchServiceConfigsApiConfigsServicePatchResponseError)

export const getPatchServiceConfigsApiConfigsServicePatchUrl = () => {


  

  return `/api/configs/service`
}

export const patchServiceConfigsApiConfigsServicePatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchServiceConfigsApiConfigsServicePatchResponse> => {
  
  const res = await fetch(getPatchServiceConfigsApiConfigsServicePatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchServiceConfigsApiConfigsServicePatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchServiceConfigsApiConfigsServicePatchResponse
}
  


/**
 * Read all the workflow configurations
 * @summary Read Workflow Configs
 */
export type readWorkflowConfigsApiConfigsWorkflowGetResponse200 = {
  data: string
  status: 200
}

export type readWorkflowConfigsApiConfigsWorkflowGetResponseSuccess = (readWorkflowConfigsApiConfigsWorkflowGetResponse200) & {
  headers: Headers;
};
;

export type readWorkflowConfigsApiConfigsWorkflowGetResponse = (readWorkflowConfigsApiConfigsWorkflowGetResponseSuccess)

export const getReadWorkflowConfigsApiConfigsWorkflowGetUrl = () => {


  

  return `/api/configs/workflow`
}

export const readWorkflowConfigsApiConfigsWorkflowGet = async ( options?: RequestInit): Promise<readWorkflowConfigsApiConfigsWorkflowGetResponse> => {
  
  const res = await fetch(getReadWorkflowConfigsApiConfigsWorkflowGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readWorkflowConfigsApiConfigsWorkflowGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readWorkflowConfigsApiConfigsWorkflowGetResponse
}
  


/**
 * Put workflow configurations
 * @summary Put Workflow Configs
 */
export type putWorkflowConfigsApiConfigsWorkflowPutResponse200 = {
  data: PutWorkflowConfigsApiConfigsWorkflowPut200
  status: 200
}

export type putWorkflowConfigsApiConfigsWorkflowPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putWorkflowConfigsApiConfigsWorkflowPutResponseSuccess = (putWorkflowConfigsApiConfigsWorkflowPutResponse200) & {
  headers: Headers;
};
export type putWorkflowConfigsApiConfigsWorkflowPutResponseError = (putWorkflowConfigsApiConfigsWorkflowPutResponse422) & {
  headers: Headers;
};

export type putWorkflowConfigsApiConfigsWorkflowPutResponse = (putWorkflowConfigsApiConfigsWorkflowPutResponseSuccess | putWorkflowConfigsApiConfigsWorkflowPutResponseError)

export const getPutWorkflowConfigsApiConfigsWorkflowPutUrl = () => {


  

  return `/api/configs/workflow`
}

export const putWorkflowConfigsApiConfigsWorkflowPut = async (putWorkflowRequest: PutWorkflowRequest, options?: RequestInit): Promise<putWorkflowConfigsApiConfigsWorkflowPutResponse> => {
  
  const res = await fetch(getPutWorkflowConfigsApiConfigsWorkflowPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putWorkflowRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putWorkflowConfigsApiConfigsWorkflowPutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putWorkflowConfigsApiConfigsWorkflowPutResponse
}
  


/**
 * Patch workflow configurations
 * @summary Patch Workflow Configs
 */
export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse200 = {
  data: PatchWorkflowConfigsApiConfigsWorkflowPatch200
  status: 200
}

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponseSuccess = (patchWorkflowConfigsApiConfigsWorkflowPatchResponse200) & {
  headers: Headers;
};
export type patchWorkflowConfigsApiConfigsWorkflowPatchResponseError = (patchWorkflowConfigsApiConfigsWorkflowPatchResponse422) & {
  headers: Headers;
};

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse = (patchWorkflowConfigsApiConfigsWorkflowPatchResponseSuccess | patchWorkflowConfigsApiConfigsWorkflowPatchResponseError)

export const getPatchWorkflowConfigsApiConfigsWorkflowPatchUrl = () => {


  

  return `/api/configs/workflow`
}

export const patchWorkflowConfigsApiConfigsWorkflowPatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchWorkflowConfigsApiConfigsWorkflowPatchResponse> => {
  
  const res = await fetch(getPatchWorkflowConfigsApiConfigsWorkflowPatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchWorkflowConfigsApiConfigsWorkflowPatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchWorkflowConfigsApiConfigsWorkflowPatchResponse
}
  


/**
 * Read all the dataset configurations
 * @summary Read Dataset Configs
 */
export type readDatasetConfigsApiConfigsDatasetGetResponse200 = {
  data: string
  status: 200
}

export type readDatasetConfigsApiConfigsDatasetGetResponseSuccess = (readDatasetConfigsApiConfigsDatasetGetResponse200) & {
  headers: Headers;
};
;

export type readDatasetConfigsApiConfigsDatasetGetResponse = (readDatasetConfigsApiConfigsDatasetGetResponseSuccess)

export const getReadDatasetConfigsApiConfigsDatasetGetUrl = () => {


  

  return `/api/configs/dataset`
}

export const readDatasetConfigsApiConfigsDatasetGet = async ( options?: RequestInit): Promise<readDatasetConfigsApiConfigsDatasetGetResponse> => {
  
  const res = await fetch(getReadDatasetConfigsApiConfigsDatasetGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readDatasetConfigsApiConfigsDatasetGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readDatasetConfigsApiConfigsDatasetGetResponse
}
  


/**
 * Put dataset configurations
 * @summary Put Dataset Configs
 */
export type putDatasetConfigsApiConfigsDatasetPutResponse200 = {
  data: PutDatasetConfigsApiConfigsDatasetPut200
  status: 200
}

export type putDatasetConfigsApiConfigsDatasetPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putDatasetConfigsApiConfigsDatasetPutResponseSuccess = (putDatasetConfigsApiConfigsDatasetPutResponse200) & {
  headers: Headers;
};
export type putDatasetConfigsApiConfigsDatasetPutResponseError = (putDatasetConfigsApiConfigsDatasetPutResponse422) & {
  headers: Headers;
};

export type putDatasetConfigsApiConfigsDatasetPutResponse = (putDatasetConfigsApiConfigsDatasetPutResponseSuccess | putDatasetConfigsApiConfigsDatasetPutResponseError)

export const getPutDatasetConfigsApiConfigsDatasetPutUrl = () => {


  

  return `/api/configs/dataset`
}

export const putDatasetConfigsApiConfigsDatasetPut = async (putDatasetRequest: PutDatasetRequest, options?: RequestInit): Promise<putDatasetConfigsApiConfigsDatasetPutResponse> => {
  
  const res = await fetch(getPutDatasetConfigsApiConfigsDatasetPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putDatasetRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putDatasetConfigsApiConfigsDatasetPutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putDatasetConfigsApiConfigsDatasetPutResponse
}
  


/**
 * Patch dataset configurations
 * @summary Patch Dataset Configs
 */
export type patchDatasetConfigsApiConfigsDatasetPatchResponse200 = {
  data: PatchDatasetConfigsApiConfigsDatasetPatch200
  status: 200
}

export type patchDatasetConfigsApiConfigsDatasetPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchDatasetConfigsApiConfigsDatasetPatchResponseSuccess = (patchDatasetConfigsApiConfigsDatasetPatchResponse200) & {
  headers: Headers;
};
export type patchDatasetConfigsApiConfigsDatasetPatchResponseError = (patchDatasetConfigsApiConfigsDatasetPatchResponse422) & {
  headers: Headers;
};

export type patchDatasetConfigsApiConfigsDatasetPatchResponse = (patchDatasetConfigsApiConfigsDatasetPatchResponseSuccess | patchDatasetConfigsApiConfigsDatasetPatchResponseError)

export const getPatchDatasetConfigsApiConfigsDatasetPatchUrl = () => {


  

  return `/api/configs/dataset`
}

export const patchDatasetConfigsApiConfigsDatasetPatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchDatasetConfigsApiConfigsDatasetPatchResponse> => {
  
  const res = await fetch(getPatchDatasetConfigsApiConfigsDatasetPatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchDatasetConfigsApiConfigsDatasetPatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchDatasetConfigsApiConfigsDatasetPatchResponse
}
  


/**
 * Delete dataset configuration for a specific bucket
 * @summary Delete Dataset
 */
export type deleteDatasetApiConfigsDatasetNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteDatasetApiConfigsDatasetNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteDatasetApiConfigsDatasetNameDeleteResponseSuccess = (deleteDatasetApiConfigsDatasetNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteDatasetApiConfigsDatasetNameDeleteResponseError = (deleteDatasetApiConfigsDatasetNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteDatasetApiConfigsDatasetNameDeleteResponse = (deleteDatasetApiConfigsDatasetNameDeleteResponseSuccess | deleteDatasetApiConfigsDatasetNameDeleteResponseError)

export const getDeleteDatasetApiConfigsDatasetNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/dataset/${name}`
}

export const deleteDatasetApiConfigsDatasetNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteDatasetApiConfigsDatasetNameDeleteResponse> => {
  
  const res = await fetch(getDeleteDatasetApiConfigsDatasetNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDatasetApiConfigsDatasetNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDatasetApiConfigsDatasetNameDeleteResponse
}
  


/**
 * Patch dataset configuration for a specific bucket
 * @summary Patch Dataset
 */
export type patchDatasetApiConfigsDatasetNamePatchResponse200 = {
  data: PatchDatasetApiConfigsDatasetNamePatch200
  status: 200
}

export type patchDatasetApiConfigsDatasetNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchDatasetApiConfigsDatasetNamePatchResponseSuccess = (patchDatasetApiConfigsDatasetNamePatchResponse200) & {
  headers: Headers;
};
export type patchDatasetApiConfigsDatasetNamePatchResponseError = (patchDatasetApiConfigsDatasetNamePatchResponse422) & {
  headers: Headers;
};

export type patchDatasetApiConfigsDatasetNamePatchResponse = (patchDatasetApiConfigsDatasetNamePatchResponseSuccess | patchDatasetApiConfigsDatasetNamePatchResponseError)

export const getPatchDatasetApiConfigsDatasetNamePatchUrl = (name: string,) => {


  

  return `/api/configs/dataset/${name}`
}

export const patchDatasetApiConfigsDatasetNamePatch = async (name: string,
    patchDatasetRequest: PatchDatasetRequest, options?: RequestInit): Promise<patchDatasetApiConfigsDatasetNamePatchResponse> => {
  
  const res = await fetch(getPatchDatasetApiConfigsDatasetNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchDatasetRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchDatasetApiConfigsDatasetNamePatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchDatasetApiConfigsDatasetNamePatchResponse
}
  


/**
 * List all backends.
 * @summary List Backends
 */
export type listBackendsApiConfigsBackendGetResponse200 = {
  data: string
  status: 200
}

export type listBackendsApiConfigsBackendGetResponseSuccess = (listBackendsApiConfigsBackendGetResponse200) & {
  headers: Headers;
};
;

export type listBackendsApiConfigsBackendGetResponse = (listBackendsApiConfigsBackendGetResponseSuccess)

export const getListBackendsApiConfigsBackendGetUrl = () => {


  

  return `/api/configs/backend`
}

export const listBackendsApiConfigsBackendGet = async ( options?: RequestInit): Promise<listBackendsApiConfigsBackendGetResponse> => {
  
  const res = await fetch(getListBackendsApiConfigsBackendGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBackendsApiConfigsBackendGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBackendsApiConfigsBackendGetResponse
}
  


/**
 * Get info for a specific backend.
 * @summary Get Backend
 */
export type getBackendApiConfigsBackendNameGetResponse200 = {
  data: string
  status: 200
}

export type getBackendApiConfigsBackendNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getBackendApiConfigsBackendNameGetResponseSuccess = (getBackendApiConfigsBackendNameGetResponse200) & {
  headers: Headers;
};
export type getBackendApiConfigsBackendNameGetResponseError = (getBackendApiConfigsBackendNameGetResponse422) & {
  headers: Headers;
};

export type getBackendApiConfigsBackendNameGetResponse = (getBackendApiConfigsBackendNameGetResponseSuccess | getBackendApiConfigsBackendNameGetResponseError)

export const getGetBackendApiConfigsBackendNameGetUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const getBackendApiConfigsBackendNameGet = async (name: string, options?: RequestInit): Promise<getBackendApiConfigsBackendNameGetResponse> => {
  
  const res = await fetch(getGetBackendApiConfigsBackendNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getBackendApiConfigsBackendNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getBackendApiConfigsBackendNameGetResponse
}
  


/**
 * Override the config for a specific backend.
 * @summary Update Backend
 */
export type updateBackendApiConfigsBackendNamePostResponse200 = {
  data: unknown
  status: 200
}

export type updateBackendApiConfigsBackendNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateBackendApiConfigsBackendNamePostResponseSuccess = (updateBackendApiConfigsBackendNamePostResponse200) & {
  headers: Headers;
};
export type updateBackendApiConfigsBackendNamePostResponseError = (updateBackendApiConfigsBackendNamePostResponse422) & {
  headers: Headers;
};

export type updateBackendApiConfigsBackendNamePostResponse = (updateBackendApiConfigsBackendNamePostResponseSuccess | updateBackendApiConfigsBackendNamePostResponseError)

export const getUpdateBackendApiConfigsBackendNamePostUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const updateBackendApiConfigsBackendNamePost = async (name: string,
    postBackendRequest: PostBackendRequest, options?: RequestInit): Promise<updateBackendApiConfigsBackendNamePostResponse> => {
  
  const res = await fetch(getUpdateBackendApiConfigsBackendNamePostUrl(name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postBackendRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateBackendApiConfigsBackendNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateBackendApiConfigsBackendNamePostResponse
}
  


/**
 * Remove a backend.
 * @summary Delete Backend
 */
export type deleteBackendApiConfigsBackendNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteBackendApiConfigsBackendNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteBackendApiConfigsBackendNameDeleteResponseSuccess = (deleteBackendApiConfigsBackendNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteBackendApiConfigsBackendNameDeleteResponseError = (deleteBackendApiConfigsBackendNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteBackendApiConfigsBackendNameDeleteResponse = (deleteBackendApiConfigsBackendNameDeleteResponseSuccess | deleteBackendApiConfigsBackendNameDeleteResponseError)

export const getDeleteBackendApiConfigsBackendNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const deleteBackendApiConfigsBackendNameDelete = async (name: string,
    deleteBackendRequest: DeleteBackendRequest, options?: RequestInit): Promise<deleteBackendApiConfigsBackendNameDeleteResponse> => {
  
  const res = await fetch(getDeleteBackendApiConfigsBackendNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteBackendRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteBackendApiConfigsBackendNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteBackendApiConfigsBackendNameDeleteResponse
}
  


/**
 * List all Pools
 * @summary List Pools
 */
export type listPoolsApiConfigsPoolGetResponse200 = {
  data: string
  status: 200
}

export type listPoolsApiConfigsPoolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listPoolsApiConfigsPoolGetResponseSuccess = (listPoolsApiConfigsPoolGetResponse200) & {
  headers: Headers;
};
export type listPoolsApiConfigsPoolGetResponseError = (listPoolsApiConfigsPoolGetResponse422) & {
  headers: Headers;
};

export type listPoolsApiConfigsPoolGetResponse = (listPoolsApiConfigsPoolGetResponseSuccess | listPoolsApiConfigsPoolGetResponseError)

export const getListPoolsApiConfigsPoolGetUrl = (params?: ListPoolsApiConfigsPoolGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool?${stringifiedParams}` : `/api/configs/pool`
}

export const listPoolsApiConfigsPoolGet = async (params?: ListPoolsApiConfigsPoolGetParams, options?: RequestInit): Promise<listPoolsApiConfigsPoolGetResponse> => {
  
  const res = await fetch(getListPoolsApiConfigsPoolGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listPoolsApiConfigsPoolGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listPoolsApiConfigsPoolGetResponse
}
  


/**
 * Put Pool configurations
 * @summary Put Pools
 */
export type putPoolsApiConfigsPoolPutResponse200 = {
  data: unknown
  status: 200
}

export type putPoolsApiConfigsPoolPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPoolsApiConfigsPoolPutResponseSuccess = (putPoolsApiConfigsPoolPutResponse200) & {
  headers: Headers;
};
export type putPoolsApiConfigsPoolPutResponseError = (putPoolsApiConfigsPoolPutResponse422) & {
  headers: Headers;
};

export type putPoolsApiConfigsPoolPutResponse = (putPoolsApiConfigsPoolPutResponseSuccess | putPoolsApiConfigsPoolPutResponseError)

export const getPutPoolsApiConfigsPoolPutUrl = () => {


  

  return `/api/configs/pool`
}

export const putPoolsApiConfigsPoolPut = async (putPoolsRequest: PutPoolsRequest, options?: RequestInit): Promise<putPoolsApiConfigsPoolPutResponse> => {
  
  const res = await fetch(getPutPoolsApiConfigsPoolPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPoolsApiConfigsPoolPutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPoolsApiConfigsPoolPutResponse
}
  


/**
 * Read Pool configuration

Return type Any to prevent unwanted artifacts between Pool and PoolEditable outputs
Should return Pool or PoolEditable objects
 * @summary Read Pool
 */
export type readPoolApiConfigsPoolNameGetResponse200 = {
  data: string
  status: 200
}

export type readPoolApiConfigsPoolNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPoolApiConfigsPoolNameGetResponseSuccess = (readPoolApiConfigsPoolNameGetResponse200) & {
  headers: Headers;
};
export type readPoolApiConfigsPoolNameGetResponseError = (readPoolApiConfigsPoolNameGetResponse422) & {
  headers: Headers;
};

export type readPoolApiConfigsPoolNameGetResponse = (readPoolApiConfigsPoolNameGetResponseSuccess | readPoolApiConfigsPoolNameGetResponseError)

export const getReadPoolApiConfigsPoolNameGetUrl = (name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}?${stringifiedParams}` : `/api/configs/pool/${name}`
}

export const readPoolApiConfigsPoolNameGet = async (name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: RequestInit): Promise<readPoolApiConfigsPoolNameGetResponse> => {
  
  const res = await fetch(getReadPoolApiConfigsPoolNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readPoolApiConfigsPoolNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readPoolApiConfigsPoolNameGetResponse
}
  


/**
 * Put Pool configurations
 * @summary Put Pool
 */
export type putPoolApiConfigsPoolNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPoolApiConfigsPoolNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPoolApiConfigsPoolNamePutResponseSuccess = (putPoolApiConfigsPoolNamePutResponse200) & {
  headers: Headers;
};
export type putPoolApiConfigsPoolNamePutResponseError = (putPoolApiConfigsPoolNamePutResponse422) & {
  headers: Headers;
};

export type putPoolApiConfigsPoolNamePutResponse = (putPoolApiConfigsPoolNamePutResponseSuccess | putPoolApiConfigsPoolNamePutResponseError)

export const getPutPoolApiConfigsPoolNamePutUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const putPoolApiConfigsPoolNamePut = async (name: string,
    putPoolRequest: PutPoolRequest, options?: RequestInit): Promise<putPoolApiConfigsPoolNamePutResponse> => {
  
  const res = await fetch(getPutPoolApiConfigsPoolNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPoolApiConfigsPoolNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPoolApiConfigsPoolNamePutResponse
}
  


/**
 * Delete Pool configurations
 * @summary Delete Pool
 */
export type deletePoolApiConfigsPoolNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deletePoolApiConfigsPoolNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deletePoolApiConfigsPoolNameDeleteResponseSuccess = (deletePoolApiConfigsPoolNameDeleteResponse200) & {
  headers: Headers;
};
export type deletePoolApiConfigsPoolNameDeleteResponseError = (deletePoolApiConfigsPoolNameDeleteResponse422) & {
  headers: Headers;
};

export type deletePoolApiConfigsPoolNameDeleteResponse = (deletePoolApiConfigsPoolNameDeleteResponseSuccess | deletePoolApiConfigsPoolNameDeleteResponseError)

export const getDeletePoolApiConfigsPoolNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const deletePoolApiConfigsPoolNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deletePoolApiConfigsPoolNameDeleteResponse> => {
  
  const res = await fetch(getDeletePoolApiConfigsPoolNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePoolApiConfigsPoolNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePoolApiConfigsPoolNameDeleteResponse
}
  


/**
 * Patch Pool configurations
 * @summary Patch Pool
 */
export type patchPoolApiConfigsPoolNamePatchResponse200 = {
  data: unknown
  status: 200
}

export type patchPoolApiConfigsPoolNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchPoolApiConfigsPoolNamePatchResponseSuccess = (patchPoolApiConfigsPoolNamePatchResponse200) & {
  headers: Headers;
};
export type patchPoolApiConfigsPoolNamePatchResponseError = (patchPoolApiConfigsPoolNamePatchResponse422) & {
  headers: Headers;
};

export type patchPoolApiConfigsPoolNamePatchResponse = (patchPoolApiConfigsPoolNamePatchResponseSuccess | patchPoolApiConfigsPoolNamePatchResponseError)

export const getPatchPoolApiConfigsPoolNamePatchUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const patchPoolApiConfigsPoolNamePatch = async (name: string,
    patchPoolRequest: PatchPoolRequest, options?: RequestInit): Promise<patchPoolApiConfigsPoolNamePatchResponse> => {
  
  const res = await fetch(getPatchPoolApiConfigsPoolNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchPoolRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchPoolApiConfigsPoolNamePatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchPoolApiConfigsPoolNamePatchResponse
}
  


/**
 * Rename Pool
 * @summary Rename Pool
 */
export type renamePoolApiConfigsPoolNameRenamePutResponse200 = {
  data: unknown
  status: 200
}

export type renamePoolApiConfigsPoolNameRenamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renamePoolApiConfigsPoolNameRenamePutResponseSuccess = (renamePoolApiConfigsPoolNameRenamePutResponse200) & {
  headers: Headers;
};
export type renamePoolApiConfigsPoolNameRenamePutResponseError = (renamePoolApiConfigsPoolNameRenamePutResponse422) & {
  headers: Headers;
};

export type renamePoolApiConfigsPoolNameRenamePutResponse = (renamePoolApiConfigsPoolNameRenamePutResponseSuccess | renamePoolApiConfigsPoolNameRenamePutResponseError)

export const getRenamePoolApiConfigsPoolNameRenamePutUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}/rename`
}

export const renamePoolApiConfigsPoolNameRenamePut = async (name: string,
    renamePoolRequest: RenamePoolRequest, options?: RequestInit): Promise<renamePoolApiConfigsPoolNameRenamePutResponse> => {
  
  const res = await fetch(getRenamePoolApiConfigsPoolNameRenamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renamePoolRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: renamePoolApiConfigsPoolNameRenamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as renamePoolApiConfigsPoolNameRenamePutResponse
}
  


/**
 * List all Platforms

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Dict[str, Platform] or Dict[str, PlatformEditable] objects
 * @summary List Platforms In Pool
 */
export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse200 = {
  data: string
  status: 200
}

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseSuccess = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse200) & {
  headers: Headers;
};
export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseError = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse422) & {
  headers: Headers;
};

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseSuccess | listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseError)

export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetUrl = (name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}/platform?${stringifiedParams}` : `/api/configs/pool/${name}/platform`
}

export const listPlatformsInPoolApiConfigsPoolNamePlatformGet = async (name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: RequestInit): Promise<listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse> => {
  
  const res = await fetch(getListPlatformsInPoolApiConfigsPoolNamePlatformGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse
}
  


/**
 * Read Platform

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Platform or PlatformEditable objects
 * @summary Read Platform In Pool
 */
export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse200 = {
  data: string
  status: 200
}

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseSuccess = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse200) & {
  headers: Headers;
};
export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseError = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse422) & {
  headers: Headers;
};

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseSuccess | readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseError)

export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetUrl = (name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}/platform/${platformName}?${stringifiedParams}` : `/api/configs/pool/${name}/platform/${platformName}`
}

export const readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet = async (name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: RequestInit): Promise<readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse> => {
  
  const res = await fetch(getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetUrl(name,platformName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse
}
  


/**
 * Put Platform configurations
 * @summary Put Platform In Pool
 */
export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseSuccess = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse200) & {
  headers: Headers;
};
export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseError = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse422) & {
  headers: Headers;
};

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseSuccess | putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseError)

export const getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutUrl = (name: string,
    platformName: string,) => {


  

  return `/api/configs/pool/${name}/platform/${platformName}`
}

export const putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut = async (name: string,
    platformName: string,
    putPoolPlatformRequest: PutPoolPlatformRequest, options?: RequestInit): Promise<putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse> => {
  
  const res = await fetch(getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutUrl(name,platformName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolPlatformRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse
}
  


/**
 * Rename Platform
 * @summary Rename Platform In Pool
 */
export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse200 = {
  data: unknown
  status: 200
}

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseSuccess = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse200) & {
  headers: Headers;
};
export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseError = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse422) & {
  headers: Headers;
};

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseSuccess | renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseError)

export const getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutUrl = (name: string,
    platformName: string,) => {


  

  return `/api/configs/pool/${name}/platform/${platformName}/rename`
}

export const renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut = async (name: string,
    platformName: string,
    renamePoolPlatformRequest: RenamePoolPlatformRequest, options?: RequestInit): Promise<renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse> => {
  
  const res = await fetch(getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutUrl(name,platformName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renamePoolPlatformRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse
}
  


/**
 * List all Pod Template configurations
 * @summary List Pod Templates
 */
export type listPodTemplatesApiConfigsPodTemplateGetResponse200 = {
  data: string
  status: 200
}

export type listPodTemplatesApiConfigsPodTemplateGetResponseSuccess = (listPodTemplatesApiConfigsPodTemplateGetResponse200) & {
  headers: Headers;
};
;

export type listPodTemplatesApiConfigsPodTemplateGetResponse = (listPodTemplatesApiConfigsPodTemplateGetResponseSuccess)

export const getListPodTemplatesApiConfigsPodTemplateGetUrl = () => {


  

  return `/api/configs/pod_template`
}

export const listPodTemplatesApiConfigsPodTemplateGet = async ( options?: RequestInit): Promise<listPodTemplatesApiConfigsPodTemplateGetResponse> => {
  
  const res = await fetch(getListPodTemplatesApiConfigsPodTemplateGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listPodTemplatesApiConfigsPodTemplateGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listPodTemplatesApiConfigsPodTemplateGetResponse
}
  


/**
 * Set Dict of Pod Templates configurations
 * @summary Put Pod Templates
 */
export type putPodTemplatesApiConfigsPodTemplatePutResponse200 = {
  data: unknown
  status: 200
}

export type putPodTemplatesApiConfigsPodTemplatePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPodTemplatesApiConfigsPodTemplatePutResponseSuccess = (putPodTemplatesApiConfigsPodTemplatePutResponse200) & {
  headers: Headers;
};
export type putPodTemplatesApiConfigsPodTemplatePutResponseError = (putPodTemplatesApiConfigsPodTemplatePutResponse422) & {
  headers: Headers;
};

export type putPodTemplatesApiConfigsPodTemplatePutResponse = (putPodTemplatesApiConfigsPodTemplatePutResponseSuccess | putPodTemplatesApiConfigsPodTemplatePutResponseError)

export const getPutPodTemplatesApiConfigsPodTemplatePutUrl = () => {


  

  return `/api/configs/pod_template`
}

export const putPodTemplatesApiConfigsPodTemplatePut = async (putPodTemplatesRequest: PutPodTemplatesRequest, options?: RequestInit): Promise<putPodTemplatesApiConfigsPodTemplatePutResponse> => {
  
  const res = await fetch(getPutPodTemplatesApiConfigsPodTemplatePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPodTemplatesRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPodTemplatesApiConfigsPodTemplatePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPodTemplatesApiConfigsPodTemplatePutResponse
}
  


/**
 * Read Pod Template configurations
 * @summary Read Pod Template
 */
export type readPodTemplateApiConfigsPodTemplateNameGetResponse200 = {
  data: string
  status: 200
}

export type readPodTemplateApiConfigsPodTemplateNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPodTemplateApiConfigsPodTemplateNameGetResponseSuccess = (readPodTemplateApiConfigsPodTemplateNameGetResponse200) & {
  headers: Headers;
};
export type readPodTemplateApiConfigsPodTemplateNameGetResponseError = (readPodTemplateApiConfigsPodTemplateNameGetResponse422) & {
  headers: Headers;
};

export type readPodTemplateApiConfigsPodTemplateNameGetResponse = (readPodTemplateApiConfigsPodTemplateNameGetResponseSuccess | readPodTemplateApiConfigsPodTemplateNameGetResponseError)

export const getReadPodTemplateApiConfigsPodTemplateNameGetUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const readPodTemplateApiConfigsPodTemplateNameGet = async (name: string, options?: RequestInit): Promise<readPodTemplateApiConfigsPodTemplateNameGetResponse> => {
  
  const res = await fetch(getReadPodTemplateApiConfigsPodTemplateNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readPodTemplateApiConfigsPodTemplateNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readPodTemplateApiConfigsPodTemplateNameGetResponse
}
  


/**
 * Put Pod Template configurations
 * @summary Put Pod Template
 */
export type putPodTemplateApiConfigsPodTemplateNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPodTemplateApiConfigsPodTemplateNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPodTemplateApiConfigsPodTemplateNamePutResponseSuccess = (putPodTemplateApiConfigsPodTemplateNamePutResponse200) & {
  headers: Headers;
};
export type putPodTemplateApiConfigsPodTemplateNamePutResponseError = (putPodTemplateApiConfigsPodTemplateNamePutResponse422) & {
  headers: Headers;
};

export type putPodTemplateApiConfigsPodTemplateNamePutResponse = (putPodTemplateApiConfigsPodTemplateNamePutResponseSuccess | putPodTemplateApiConfigsPodTemplateNamePutResponseError)

export const getPutPodTemplateApiConfigsPodTemplateNamePutUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const putPodTemplateApiConfigsPodTemplateNamePut = async (name: string,
    putPodTemplateRequest: PutPodTemplateRequest, options?: RequestInit): Promise<putPodTemplateApiConfigsPodTemplateNamePutResponse> => {
  
  const res = await fetch(getPutPodTemplateApiConfigsPodTemplateNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPodTemplateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putPodTemplateApiConfigsPodTemplateNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putPodTemplateApiConfigsPodTemplateNamePutResponse
}
  


/**
 * Delete Pod Template configurations
 * @summary Delete Pod Template
 */
export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponseSuccess = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponse200) & {
  headers: Headers;
};
export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponseError = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponse422) & {
  headers: Headers;
};

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponseSuccess | deletePodTemplateApiConfigsPodTemplateNameDeleteResponseError)

export const getDeletePodTemplateApiConfigsPodTemplateNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const deletePodTemplateApiConfigsPodTemplateNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deletePodTemplateApiConfigsPodTemplateNameDeleteResponse> => {
  
  const res = await fetch(getDeletePodTemplateApiConfigsPodTemplateNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePodTemplateApiConfigsPodTemplateNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePodTemplateApiConfigsPodTemplateNameDeleteResponse
}
  


/**
 * List all Group Template configurations
 * @summary List Group Templates
 */
export type listGroupTemplatesApiConfigsGroupTemplateGetResponse200 = {
  data: string
  status: 200
}

export type listGroupTemplatesApiConfigsGroupTemplateGetResponseSuccess = (listGroupTemplatesApiConfigsGroupTemplateGetResponse200) & {
  headers: Headers;
};
;

export type listGroupTemplatesApiConfigsGroupTemplateGetResponse = (listGroupTemplatesApiConfigsGroupTemplateGetResponseSuccess)

export const getListGroupTemplatesApiConfigsGroupTemplateGetUrl = () => {


  

  return `/api/configs/group_template`
}

export const listGroupTemplatesApiConfigsGroupTemplateGet = async ( options?: RequestInit): Promise<listGroupTemplatesApiConfigsGroupTemplateGetResponse> => {
  
  const res = await fetch(getListGroupTemplatesApiConfigsGroupTemplateGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listGroupTemplatesApiConfigsGroupTemplateGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listGroupTemplatesApiConfigsGroupTemplateGetResponse
}
  


/**
 * Set Dict of Group Templates configurations
 * @summary Put Group Templates
 */
export type putGroupTemplatesApiConfigsGroupTemplatePutResponse200 = {
  data: unknown
  status: 200
}

export type putGroupTemplatesApiConfigsGroupTemplatePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putGroupTemplatesApiConfigsGroupTemplatePutResponseSuccess = (putGroupTemplatesApiConfigsGroupTemplatePutResponse200) & {
  headers: Headers;
};
export type putGroupTemplatesApiConfigsGroupTemplatePutResponseError = (putGroupTemplatesApiConfigsGroupTemplatePutResponse422) & {
  headers: Headers;
};

export type putGroupTemplatesApiConfigsGroupTemplatePutResponse = (putGroupTemplatesApiConfigsGroupTemplatePutResponseSuccess | putGroupTemplatesApiConfigsGroupTemplatePutResponseError)

export const getPutGroupTemplatesApiConfigsGroupTemplatePutUrl = () => {


  

  return `/api/configs/group_template`
}

export const putGroupTemplatesApiConfigsGroupTemplatePut = async (putGroupTemplatesRequest: PutGroupTemplatesRequest, options?: RequestInit): Promise<putGroupTemplatesApiConfigsGroupTemplatePutResponse> => {
  
  const res = await fetch(getPutGroupTemplatesApiConfigsGroupTemplatePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putGroupTemplatesRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putGroupTemplatesApiConfigsGroupTemplatePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putGroupTemplatesApiConfigsGroupTemplatePutResponse
}
  


/**
 * Read Group Template configurations
 * @summary Read Group Template
 */
export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse200 = {
  data: string
  status: 200
}

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponseSuccess = (readGroupTemplateApiConfigsGroupTemplateNameGetResponse200) & {
  headers: Headers;
};
export type readGroupTemplateApiConfigsGroupTemplateNameGetResponseError = (readGroupTemplateApiConfigsGroupTemplateNameGetResponse422) & {
  headers: Headers;
};

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse = (readGroupTemplateApiConfigsGroupTemplateNameGetResponseSuccess | readGroupTemplateApiConfigsGroupTemplateNameGetResponseError)

export const getReadGroupTemplateApiConfigsGroupTemplateNameGetUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const readGroupTemplateApiConfigsGroupTemplateNameGet = async (name: string, options?: RequestInit): Promise<readGroupTemplateApiConfigsGroupTemplateNameGetResponse> => {
  
  const res = await fetch(getReadGroupTemplateApiConfigsGroupTemplateNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readGroupTemplateApiConfigsGroupTemplateNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readGroupTemplateApiConfigsGroupTemplateNameGetResponse
}
  


/**
 * Put Group Template configurations
 * @summary Put Group Template
 */
export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponseSuccess = (putGroupTemplateApiConfigsGroupTemplateNamePutResponse200) & {
  headers: Headers;
};
export type putGroupTemplateApiConfigsGroupTemplateNamePutResponseError = (putGroupTemplateApiConfigsGroupTemplateNamePutResponse422) & {
  headers: Headers;
};

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse = (putGroupTemplateApiConfigsGroupTemplateNamePutResponseSuccess | putGroupTemplateApiConfigsGroupTemplateNamePutResponseError)

export const getPutGroupTemplateApiConfigsGroupTemplateNamePutUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const putGroupTemplateApiConfigsGroupTemplateNamePut = async (name: string,
    putGroupTemplateRequest: PutGroupTemplateRequest, options?: RequestInit): Promise<putGroupTemplateApiConfigsGroupTemplateNamePutResponse> => {
  
  const res = await fetch(getPutGroupTemplateApiConfigsGroupTemplateNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putGroupTemplateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putGroupTemplateApiConfigsGroupTemplateNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putGroupTemplateApiConfigsGroupTemplateNamePutResponse
}
  


/**
 * Delete Group Template configurations
 * @summary Delete Group Template
 */
export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseSuccess = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseError = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseSuccess | deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseError)

export const getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const deleteGroupTemplateApiConfigsGroupTemplateNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse> => {
  
  const res = await fetch(getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse
}
  


/**
 * List all Resource Validation configurations
 * @summary List Resource Validations
 */
export type listResourceValidationsApiConfigsResourceValidationGetResponse200 = {
  data: string
  status: 200
}

export type listResourceValidationsApiConfigsResourceValidationGetResponseSuccess = (listResourceValidationsApiConfigsResourceValidationGetResponse200) & {
  headers: Headers;
};
;

export type listResourceValidationsApiConfigsResourceValidationGetResponse = (listResourceValidationsApiConfigsResourceValidationGetResponseSuccess)

export const getListResourceValidationsApiConfigsResourceValidationGetUrl = () => {


  

  return `/api/configs/resource_validation`
}

export const listResourceValidationsApiConfigsResourceValidationGet = async ( options?: RequestInit): Promise<listResourceValidationsApiConfigsResourceValidationGetResponse> => {
  
  const res = await fetch(getListResourceValidationsApiConfigsResourceValidationGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listResourceValidationsApiConfigsResourceValidationGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listResourceValidationsApiConfigsResourceValidationGetResponse
}
  


/**
 * Put Resource Validation configurations
 * @summary Put Resource Validations
 */
export type putResourceValidationsApiConfigsResourceValidationPutResponse200 = {
  data: unknown
  status: 200
}

export type putResourceValidationsApiConfigsResourceValidationPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putResourceValidationsApiConfigsResourceValidationPutResponseSuccess = (putResourceValidationsApiConfigsResourceValidationPutResponse200) & {
  headers: Headers;
};
export type putResourceValidationsApiConfigsResourceValidationPutResponseError = (putResourceValidationsApiConfigsResourceValidationPutResponse422) & {
  headers: Headers;
};

export type putResourceValidationsApiConfigsResourceValidationPutResponse = (putResourceValidationsApiConfigsResourceValidationPutResponseSuccess | putResourceValidationsApiConfigsResourceValidationPutResponseError)

export const getPutResourceValidationsApiConfigsResourceValidationPutUrl = () => {


  

  return `/api/configs/resource_validation`
}

export const putResourceValidationsApiConfigsResourceValidationPut = async (putResourceValidationsRequest: PutResourceValidationsRequest, options?: RequestInit): Promise<putResourceValidationsApiConfigsResourceValidationPutResponse> => {
  
  const res = await fetch(getPutResourceValidationsApiConfigsResourceValidationPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putResourceValidationsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putResourceValidationsApiConfigsResourceValidationPutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putResourceValidationsApiConfigsResourceValidationPutResponse
}
  


/**
 * Read Resource Validation configurations
 * @summary Read Resource Validation
 */
export type readResourceValidationApiConfigsResourceValidationNameGetResponse200 = {
  data: string
  status: 200
}

export type readResourceValidationApiConfigsResourceValidationNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readResourceValidationApiConfigsResourceValidationNameGetResponseSuccess = (readResourceValidationApiConfigsResourceValidationNameGetResponse200) & {
  headers: Headers;
};
export type readResourceValidationApiConfigsResourceValidationNameGetResponseError = (readResourceValidationApiConfigsResourceValidationNameGetResponse422) & {
  headers: Headers;
};

export type readResourceValidationApiConfigsResourceValidationNameGetResponse = (readResourceValidationApiConfigsResourceValidationNameGetResponseSuccess | readResourceValidationApiConfigsResourceValidationNameGetResponseError)

export const getReadResourceValidationApiConfigsResourceValidationNameGetUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const readResourceValidationApiConfigsResourceValidationNameGet = async (name: string, options?: RequestInit): Promise<readResourceValidationApiConfigsResourceValidationNameGetResponse> => {
  
  const res = await fetch(getReadResourceValidationApiConfigsResourceValidationNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readResourceValidationApiConfigsResourceValidationNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readResourceValidationApiConfigsResourceValidationNameGetResponse
}
  


/**
 * Put Resource Validation configurations
 * @summary Put Resource Validation
 */
export type putResourceValidationApiConfigsResourceValidationNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putResourceValidationApiConfigsResourceValidationNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putResourceValidationApiConfigsResourceValidationNamePutResponseSuccess = (putResourceValidationApiConfigsResourceValidationNamePutResponse200) & {
  headers: Headers;
};
export type putResourceValidationApiConfigsResourceValidationNamePutResponseError = (putResourceValidationApiConfigsResourceValidationNamePutResponse422) & {
  headers: Headers;
};

export type putResourceValidationApiConfigsResourceValidationNamePutResponse = (putResourceValidationApiConfigsResourceValidationNamePutResponseSuccess | putResourceValidationApiConfigsResourceValidationNamePutResponseError)

export const getPutResourceValidationApiConfigsResourceValidationNamePutUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const putResourceValidationApiConfigsResourceValidationNamePut = async (name: string,
    putResourceValidationRequest: PutResourceValidationRequest, options?: RequestInit): Promise<putResourceValidationApiConfigsResourceValidationNamePutResponse> => {
  
  const res = await fetch(getPutResourceValidationApiConfigsResourceValidationNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putResourceValidationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putResourceValidationApiConfigsResourceValidationNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putResourceValidationApiConfigsResourceValidationNamePutResponse
}
  


/**
 * Delete Resource Validation configurations
 * @summary Delete Resource Validation
 */
export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseSuccess = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseError = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseSuccess | deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseError)

export const getDeleteResourceValidationApiConfigsResourceValidationNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const deleteResourceValidationApiConfigsResourceValidationNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse> => {
  
  const res = await fetch(getDeleteResourceValidationApiConfigsResourceValidationNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse
}
  


/**
 * List all Roles
 * @summary List Roles
 */
export type listRolesApiConfigsRoleGetResponse200 = {
  data: string
  status: 200
}

export type listRolesApiConfigsRoleGetResponseSuccess = (listRolesApiConfigsRoleGetResponse200) & {
  headers: Headers;
};
;

export type listRolesApiConfigsRoleGetResponse = (listRolesApiConfigsRoleGetResponseSuccess)

export const getListRolesApiConfigsRoleGetUrl = () => {


  

  return `/api/configs/role`
}

export const listRolesApiConfigsRoleGet = async ( options?: RequestInit): Promise<listRolesApiConfigsRoleGetResponse> => {
  
  const res = await fetch(getListRolesApiConfigsRoleGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listRolesApiConfigsRoleGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listRolesApiConfigsRoleGetResponse
}
  


/**
 * Put Roles
 * @summary Put Roles
 */
export type putRolesApiConfigsRolePutResponse200 = {
  data: unknown
  status: 200
}

export type putRolesApiConfigsRolePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putRolesApiConfigsRolePutResponseSuccess = (putRolesApiConfigsRolePutResponse200) & {
  headers: Headers;
};
export type putRolesApiConfigsRolePutResponseError = (putRolesApiConfigsRolePutResponse422) & {
  headers: Headers;
};

export type putRolesApiConfigsRolePutResponse = (putRolesApiConfigsRolePutResponseSuccess | putRolesApiConfigsRolePutResponseError)

export const getPutRolesApiConfigsRolePutUrl = () => {


  

  return `/api/configs/role`
}

export const putRolesApiConfigsRolePut = async (putRolesRequest: PutRolesRequest, options?: RequestInit): Promise<putRolesApiConfigsRolePutResponse> => {
  
  const res = await fetch(getPutRolesApiConfigsRolePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putRolesRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putRolesApiConfigsRolePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putRolesApiConfigsRolePutResponse
}
  


/**
 * Read Role
 * @summary Read Role
 */
export type readRoleApiConfigsRoleNameGetResponse200 = {
  data: string
  status: 200
}

export type readRoleApiConfigsRoleNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readRoleApiConfigsRoleNameGetResponseSuccess = (readRoleApiConfigsRoleNameGetResponse200) & {
  headers: Headers;
};
export type readRoleApiConfigsRoleNameGetResponseError = (readRoleApiConfigsRoleNameGetResponse422) & {
  headers: Headers;
};

export type readRoleApiConfigsRoleNameGetResponse = (readRoleApiConfigsRoleNameGetResponseSuccess | readRoleApiConfigsRoleNameGetResponseError)

export const getReadRoleApiConfigsRoleNameGetUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const readRoleApiConfigsRoleNameGet = async (name: string, options?: RequestInit): Promise<readRoleApiConfigsRoleNameGetResponse> => {
  
  const res = await fetch(getReadRoleApiConfigsRoleNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readRoleApiConfigsRoleNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readRoleApiConfigsRoleNameGetResponse
}
  


/**
 * Patch Role configurations
 * @summary Put Role
 */
export type putRoleApiConfigsRoleNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putRoleApiConfigsRoleNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putRoleApiConfigsRoleNamePutResponseSuccess = (putRoleApiConfigsRoleNamePutResponse200) & {
  headers: Headers;
};
export type putRoleApiConfigsRoleNamePutResponseError = (putRoleApiConfigsRoleNamePutResponse422) & {
  headers: Headers;
};

export type putRoleApiConfigsRoleNamePutResponse = (putRoleApiConfigsRoleNamePutResponseSuccess | putRoleApiConfigsRoleNamePutResponseError)

export const getPutRoleApiConfigsRoleNamePutUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const putRoleApiConfigsRoleNamePut = async (name: string,
    putRoleRequest: PutRoleRequest, options?: RequestInit): Promise<putRoleApiConfigsRoleNamePutResponse> => {
  
  const res = await fetch(getPutRoleApiConfigsRoleNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putRoleRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putRoleApiConfigsRoleNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putRoleApiConfigsRoleNamePutResponse
}
  


/**
 * Delete Role
 * @summary Delete Role
 */
export type deleteRoleApiConfigsRoleNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteRoleApiConfigsRoleNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteRoleApiConfigsRoleNameDeleteResponseSuccess = (deleteRoleApiConfigsRoleNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteRoleApiConfigsRoleNameDeleteResponseError = (deleteRoleApiConfigsRoleNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteRoleApiConfigsRoleNameDeleteResponse = (deleteRoleApiConfigsRoleNameDeleteResponseSuccess | deleteRoleApiConfigsRoleNameDeleteResponseError)

export const getDeleteRoleApiConfigsRoleNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const deleteRoleApiConfigsRoleNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteRoleApiConfigsRoleNameDeleteResponse> => {
  
  const res = await fetch(getDeleteRoleApiConfigsRoleNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteRoleApiConfigsRoleNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteRoleApiConfigsRoleNameDeleteResponse
}
  


/**
 * List all backend test configurations
 * @summary List Backend Tests
 */
export type listBackendTestsApiConfigsBackendTestGetResponse200 = {
  data: string
  status: 200
}

export type listBackendTestsApiConfigsBackendTestGetResponseSuccess = (listBackendTestsApiConfigsBackendTestGetResponse200) & {
  headers: Headers;
};
;

export type listBackendTestsApiConfigsBackendTestGetResponse = (listBackendTestsApiConfigsBackendTestGetResponseSuccess)

export const getListBackendTestsApiConfigsBackendTestGetUrl = () => {


  

  return `/api/configs/backend_test`
}

export const listBackendTestsApiConfigsBackendTestGet = async ( options?: RequestInit): Promise<listBackendTestsApiConfigsBackendTestGetResponse> => {
  
  const res = await fetch(getListBackendTestsApiConfigsBackendTestGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBackendTestsApiConfigsBackendTestGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBackendTestsApiConfigsBackendTestGetResponse
}
  


/**
 * Put backend test configurations
 * @summary Put Backend Tests
 */
export type putBackendTestsApiConfigsBackendTestPutResponse200 = {
  data: unknown
  status: 200
}

export type putBackendTestsApiConfigsBackendTestPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putBackendTestsApiConfigsBackendTestPutResponseSuccess = (putBackendTestsApiConfigsBackendTestPutResponse200) & {
  headers: Headers;
};
export type putBackendTestsApiConfigsBackendTestPutResponseError = (putBackendTestsApiConfigsBackendTestPutResponse422) & {
  headers: Headers;
};

export type putBackendTestsApiConfigsBackendTestPutResponse = (putBackendTestsApiConfigsBackendTestPutResponseSuccess | putBackendTestsApiConfigsBackendTestPutResponseError)

export const getPutBackendTestsApiConfigsBackendTestPutUrl = () => {


  

  return `/api/configs/backend_test`
}

export const putBackendTestsApiConfigsBackendTestPut = async (putBackendTestsRequest: PutBackendTestsRequest, options?: RequestInit): Promise<putBackendTestsApiConfigsBackendTestPutResponse> => {
  
  const res = await fetch(getPutBackendTestsApiConfigsBackendTestPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putBackendTestsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putBackendTestsApiConfigsBackendTestPutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putBackendTestsApiConfigsBackendTestPutResponse
}
  


/**
 * Read backend test configuration
 * @summary Read Backend Test
 */
export type readBackendTestApiConfigsBackendTestNameGetResponse200 = {
  data: string
  status: 200
}

export type readBackendTestApiConfigsBackendTestNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readBackendTestApiConfigsBackendTestNameGetResponseSuccess = (readBackendTestApiConfigsBackendTestNameGetResponse200) & {
  headers: Headers;
};
export type readBackendTestApiConfigsBackendTestNameGetResponseError = (readBackendTestApiConfigsBackendTestNameGetResponse422) & {
  headers: Headers;
};

export type readBackendTestApiConfigsBackendTestNameGetResponse = (readBackendTestApiConfigsBackendTestNameGetResponseSuccess | readBackendTestApiConfigsBackendTestNameGetResponseError)

export const getReadBackendTestApiConfigsBackendTestNameGetUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const readBackendTestApiConfigsBackendTestNameGet = async (name: string, options?: RequestInit): Promise<readBackendTestApiConfigsBackendTestNameGetResponse> => {
  
  const res = await fetch(getReadBackendTestApiConfigsBackendTestNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readBackendTestApiConfigsBackendTestNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readBackendTestApiConfigsBackendTestNameGetResponse
}
  


/**
 * Put backend test configuration
 * @summary Put Backend Test
 */
export type putBackendTestApiConfigsBackendTestNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putBackendTestApiConfigsBackendTestNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putBackendTestApiConfigsBackendTestNamePutResponseSuccess = (putBackendTestApiConfigsBackendTestNamePutResponse200) & {
  headers: Headers;
};
export type putBackendTestApiConfigsBackendTestNamePutResponseError = (putBackendTestApiConfigsBackendTestNamePutResponse422) & {
  headers: Headers;
};

export type putBackendTestApiConfigsBackendTestNamePutResponse = (putBackendTestApiConfigsBackendTestNamePutResponseSuccess | putBackendTestApiConfigsBackendTestNamePutResponseError)

export const getPutBackendTestApiConfigsBackendTestNamePutUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const putBackendTestApiConfigsBackendTestNamePut = async (name: string,
    putBackendTestRequest: PutBackendTestRequest, options?: RequestInit): Promise<putBackendTestApiConfigsBackendTestNamePutResponse> => {
  
  const res = await fetch(getPutBackendTestApiConfigsBackendTestNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putBackendTestRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putBackendTestApiConfigsBackendTestNamePutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putBackendTestApiConfigsBackendTestNamePutResponse
}
  


/**
 * Delete test configuration
 * @summary Delete Backend Test
 */
export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponseSuccess = (deleteBackendTestApiConfigsBackendTestNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteBackendTestApiConfigsBackendTestNameDeleteResponseError = (deleteBackendTestApiConfigsBackendTestNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse = (deleteBackendTestApiConfigsBackendTestNameDeleteResponseSuccess | deleteBackendTestApiConfigsBackendTestNameDeleteResponseError)

export const getDeleteBackendTestApiConfigsBackendTestNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const deleteBackendTestApiConfigsBackendTestNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteBackendTestApiConfigsBackendTestNameDeleteResponse> => {
  
  const res = await fetch(getDeleteBackendTestApiConfigsBackendTestNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteBackendTestApiConfigsBackendTestNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteBackendTestApiConfigsBackendTestNameDeleteResponse
}
  


/**
 * Patch backend test configuration
 * @summary Patch Backend Test
 */
export type patchBackendTestApiConfigsBackendTestNamePatchResponse200 = {
  data: unknown
  status: 200
}

export type patchBackendTestApiConfigsBackendTestNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchBackendTestApiConfigsBackendTestNamePatchResponseSuccess = (patchBackendTestApiConfigsBackendTestNamePatchResponse200) & {
  headers: Headers;
};
export type patchBackendTestApiConfigsBackendTestNamePatchResponseError = (patchBackendTestApiConfigsBackendTestNamePatchResponse422) & {
  headers: Headers;
};

export type patchBackendTestApiConfigsBackendTestNamePatchResponse = (patchBackendTestApiConfigsBackendTestNamePatchResponseSuccess | patchBackendTestApiConfigsBackendTestNamePatchResponseError)

export const getPatchBackendTestApiConfigsBackendTestNamePatchUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const patchBackendTestApiConfigsBackendTestNamePatch = async (name: string,
    patchBackendTestRequest: PatchBackendTestRequest, options?: RequestInit): Promise<patchBackendTestApiConfigsBackendTestNamePatchResponse> => {
  
  const res = await fetch(getPatchBackendTestApiConfigsBackendTestNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchBackendTestRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: patchBackendTestApiConfigsBackendTestNamePatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as patchBackendTestApiConfigsBackendTestNamePatchResponse
}
  


/**
 * List history of all configs
 * @summary Get Configs History
 */
export type getConfigsHistoryApiConfigsHistoryGetResponse200 = {
  data: GetConfigsHistoryResponse
  status: 200
}

export type getConfigsHistoryApiConfigsHistoryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getConfigsHistoryApiConfigsHistoryGetResponseSuccess = (getConfigsHistoryApiConfigsHistoryGetResponse200) & {
  headers: Headers;
};
export type getConfigsHistoryApiConfigsHistoryGetResponseError = (getConfigsHistoryApiConfigsHistoryGetResponse422) & {
  headers: Headers;
};

export type getConfigsHistoryApiConfigsHistoryGetResponse = (getConfigsHistoryApiConfigsHistoryGetResponseSuccess | getConfigsHistoryApiConfigsHistoryGetResponseError)

export const getGetConfigsHistoryApiConfigsHistoryGetUrl = (params?: GetConfigsHistoryApiConfigsHistoryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/history?${stringifiedParams}` : `/api/configs/history`
}

export const getConfigsHistoryApiConfigsHistoryGet = async (params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: RequestInit): Promise<getConfigsHistoryApiConfigsHistoryGetResponse> => {
  
  const res = await fetch(getGetConfigsHistoryApiConfigsHistoryGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getConfigsHistoryApiConfigsHistoryGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getConfigsHistoryApiConfigsHistoryGetResponse
}
  


/**
 * Roll back a config to a particular revision.
 * @summary Rollback Config
 */
export type rollbackConfigApiConfigsHistoryRollbackPostResponse200 = {
  data: unknown
  status: 200
}

export type rollbackConfigApiConfigsHistoryRollbackPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type rollbackConfigApiConfigsHistoryRollbackPostResponseSuccess = (rollbackConfigApiConfigsHistoryRollbackPostResponse200) & {
  headers: Headers;
};
export type rollbackConfigApiConfigsHistoryRollbackPostResponseError = (rollbackConfigApiConfigsHistoryRollbackPostResponse422) & {
  headers: Headers;
};

export type rollbackConfigApiConfigsHistoryRollbackPostResponse = (rollbackConfigApiConfigsHistoryRollbackPostResponseSuccess | rollbackConfigApiConfigsHistoryRollbackPostResponseError)

export const getRollbackConfigApiConfigsHistoryRollbackPostUrl = () => {


  

  return `/api/configs/history/rollback`
}

export const rollbackConfigApiConfigsHistoryRollbackPost = async (rollbackConfigRequest: RollbackConfigRequest, options?: RequestInit): Promise<rollbackConfigApiConfigsHistoryRollbackPostResponse> => {
  
  const res = await fetch(getRollbackConfigApiConfigsHistoryRollbackPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rollbackConfigRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rollbackConfigApiConfigsHistoryRollbackPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rollbackConfigApiConfigsHistoryRollbackPostResponse
}
  


/**
 * Delete a specific config history revision. This performs a soft delete of the revision.

Args:
    config_type: Type of config to delete
    revision: Revision number to delete (must be greater than 0)
    username: Username of the person performing the delete

Raises:
    OSMOUserError: If the revision doesn't exist or is the current revision
 * @summary Delete Config History Revision
 */
export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseSuccess = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse200) & {
  headers: Headers;
};
export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseError = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse422) & {
  headers: Headers;
};

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseSuccess | deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseError)

export const getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteUrl = (configType: string,
    revision: number,) => {


  

  return `/api/configs/history/${configType}/revision/${revision}`
}

export const deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete = async (configType: string,
    revision: number, options?: RequestInit): Promise<deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse> => {
  
  const res = await fetch(getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteUrl(configType,revision),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse
}
  


/**
 * Update tags for a specific config history revision.

Args:
    config_type: Type of config to update
    revision: Revision number to update (must be greater than 0)
    request: Request containing tags to add and delete
    username: Username of the person performing the update

Raises:
    OSMOUserError: If the revision doesn't exist or is invalid
 * @summary Update Config History Tags
 */
export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse200 = {
  data: unknown
  status: 200
}

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseSuccess = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse200) & {
  headers: Headers;
};
export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseError = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse422) & {
  headers: Headers;
};

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseSuccess | updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseError)

export const getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostUrl = (configType: string,
    revision: number,) => {


  

  return `/api/configs/history/${configType}/revision/${revision}/tags`
}

export const updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost = async (configType: string,
    revision: number,
    updateConfigTagsRequest: UpdateConfigTagsRequest, options?: RequestInit): Promise<updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse> => {
  
  const res = await fetch(getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostUrl(configType,revision),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateConfigTagsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse
}
  


/**
 * Returns two config revisions, similar to
GET /api/configs/history/{config_type}/revision/{revision}, but with obfuscated secret strings
that say if a secret string is changed. Intended for use with the `diff` command.

Args:
    request: Request containing config type and revisions to compare

Returns:
    ConfigDiffResponse containing the two revisions

Raises:
    OSMOUserError: If either revision doesn't exist or is invalid
 * @summary Get Config Diff
 */
export type getConfigDiffApiConfigsDiffGetResponse200 = {
  data: string
  status: 200
}

export type getConfigDiffApiConfigsDiffGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getConfigDiffApiConfigsDiffGetResponseSuccess = (getConfigDiffApiConfigsDiffGetResponse200) & {
  headers: Headers;
};
export type getConfigDiffApiConfigsDiffGetResponseError = (getConfigDiffApiConfigsDiffGetResponse422) & {
  headers: Headers;
};

export type getConfigDiffApiConfigsDiffGetResponse = (getConfigDiffApiConfigsDiffGetResponseSuccess | getConfigDiffApiConfigsDiffGetResponseError)

export const getGetConfigDiffApiConfigsDiffGetUrl = (params: GetConfigDiffApiConfigsDiffGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/diff?${stringifiedParams}` : `/api/configs/diff`
}

export const getConfigDiffApiConfigsDiffGet = async (params: GetConfigDiffApiConfigsDiffGetParams, options?: RequestInit): Promise<getConfigDiffApiConfigsDiffGetResponse> => {
  
  const res = await fetch(getGetConfigDiffApiConfigsDiffGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getConfigDiffApiConfigsDiffGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getConfigDiffApiConfigsDiffGetResponse
}
  


/**
 * API to fetch for a new access token using a refresh token.
 * @summary Get New Jwt Token
 */
export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse200 = {
  data: unknown
  status: 200
}

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponseSuccess = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponse200) & {
  headers: Headers;
};
export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponseError = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponse422) & {
  headers: Headers;
};

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponseSuccess | getNewJwtTokenApiAuthJwtRefreshTokenGetResponseError)

export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetUrl = (params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/jwt/refresh_token?${stringifiedParams}` : `/api/auth/jwt/refresh_token`
}

export const getNewJwtTokenApiAuthJwtRefreshTokenGet = async (params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: RequestInit): Promise<getNewJwtTokenApiAuthJwtRefreshTokenGetResponse> => {
  
  const res = await fetch(getGetNewJwtTokenApiAuthJwtRefreshTokenGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getNewJwtTokenApiAuthJwtRefreshTokenGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getNewJwtTokenApiAuthJwtRefreshTokenGetResponse
}
  


/**
 * API to create a new jwt token from an access token.
 * @summary Get Jwt Token From Access Token
 */
export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse200 = {
  data: unknown
  status: 200
}

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseSuccess = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse200) & {
  headers: Headers;
};
export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseError = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse422) & {
  headers: Headers;
};

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseSuccess | getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseError)

export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetUrl = (params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/jwt/access_token?${stringifiedParams}` : `/api/auth/jwt/access_token`
}

export const getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet = async (params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: RequestInit): Promise<getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse> => {
  
  const res = await fetch(getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse
}
  


/**
 * API to create a new access token.

If roles are specified, all specified roles must be assigned to the user.
If any role is not assigned to the user, the request fails and no token
is created. If no roles are specified, the access token inherits all of the user's
current roles from the user_roles table.
 * @summary Create Access Token
 */
export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse200 = {
  data: unknown
  status: 200
}

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponseSuccess = (createAccessTokenApiAuthAccessTokenTokenNamePostResponse200) & {
  headers: Headers;
};
export type createAccessTokenApiAuthAccessTokenTokenNamePostResponseError = (createAccessTokenApiAuthAccessTokenTokenNamePostResponse422) & {
  headers: Headers;
};

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse = (createAccessTokenApiAuthAccessTokenTokenNamePostResponseSuccess | createAccessTokenApiAuthAccessTokenTokenNamePostResponseError)

export const getCreateAccessTokenApiAuthAccessTokenTokenNamePostUrl = (tokenName: string,
    params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/access_token/${tokenName}?${stringifiedParams}` : `/api/auth/access_token/${tokenName}`
}

export const createAccessTokenApiAuthAccessTokenTokenNamePost = async (tokenName: string,
    params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams, options?: RequestInit): Promise<createAccessTokenApiAuthAccessTokenTokenNamePostResponse> => {
  
  const res = await fetch(getCreateAccessTokenApiAuthAccessTokenTokenNamePostUrl(tokenName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createAccessTokenApiAuthAccessTokenTokenNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createAccessTokenApiAuthAccessTokenTokenNamePostResponse
}
  


/**
 * API to delete an access token.
 * @summary Delete Access Token
 */
export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseSuccess = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseError = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseSuccess | deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseError)

export const getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteUrl = (tokenName: string,) => {


  

  return `/api/auth/access_token/${tokenName}`
}

export const deleteAccessTokenApiAuthAccessTokenTokenNameDelete = async (tokenName: string, options?: RequestInit): Promise<deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse> => {
  
  const res = await fetch(getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteUrl(tokenName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse
}
  


/**
 * List all roles assigned to an access token.

Args:
    token_name: The token name
    user_name: Authenticated user (owner of the token)

Returns:
    AccessTokenRolesResponse with list of role assignments
 * @summary List Access Token Roles
 */
export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse200 = {
  data: AccessTokenRolesResponse
  status: 200
}

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseSuccess = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse200) & {
  headers: Headers;
};
export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseError = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse422) & {
  headers: Headers;
};

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseSuccess | listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseError)

export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetUrl = (tokenName: string,) => {


  

  return `/api/auth/access_token/${tokenName}/roles`
}

export const listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet = async (tokenName: string, options?: RequestInit): Promise<listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse> => {
  
  const res = await fetch(getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetUrl(tokenName),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse
}
  


/**
 * API to list all access tokens for a user, including their assigned roles.
 * @summary List Access Tokens
 */
export type listAccessTokensApiAuthAccessTokenGetResponse200 = {
  data: AccessTokenWithRoles[]
  status: 200
}

export type listAccessTokensApiAuthAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAccessTokensApiAuthAccessTokenGetResponseSuccess = (listAccessTokensApiAuthAccessTokenGetResponse200) & {
  headers: Headers;
};
export type listAccessTokensApiAuthAccessTokenGetResponseError = (listAccessTokensApiAuthAccessTokenGetResponse422) & {
  headers: Headers;
};

export type listAccessTokensApiAuthAccessTokenGetResponse = (listAccessTokensApiAuthAccessTokenGetResponseSuccess | listAccessTokensApiAuthAccessTokenGetResponseError)

export const getListAccessTokensApiAuthAccessTokenGetUrl = () => {


  

  return `/api/auth/access_token`
}

export const listAccessTokensApiAuthAccessTokenGet = async ( options?: RequestInit): Promise<listAccessTokensApiAuthAccessTokenGetResponse> => {
  
  const res = await fetch(getListAccessTokensApiAuthAccessTokenGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listAccessTokensApiAuthAccessTokenGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listAccessTokensApiAuthAccessTokenGetResponse
}
  


/**
 * Admin API to create an access token for a specific user.

This endpoint allows administrators to create an access token
on behalf of any user in the system.

If roles are specified, all specified roles must be assigned to the target
user. If any role is not assigned to the user, the request fails and no
token is created. If no roles are specified, the access token inherits all of the
target user's current roles from the user_roles table.

Args:
    user_id: The user ID to create the token for
    token_name: Name for the access token
    expires_at: Expiration date in YYYY-MM-DD format
    description: Optional description for the token
    roles: Optional list of roles to assign (must all be assigned to user)
    admin_user: Authenticated admin user making the request

Returns:
    The generated access token string
 * @summary Admin Create Access Token
 */
export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse200 = {
  data: unknown
  status: 200
}

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseSuccess = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse200) & {
  headers: Headers;
};
export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseError = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse422) & {
  headers: Headers;
};

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseSuccess | adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseError)

export const getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostUrl = (userId: string,
    tokenName: string,
    params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/user/${userId}/access_token/${tokenName}?${stringifiedParams}` : `/api/auth/user/${userId}/access_token/${tokenName}`
}

export const adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost = async (userId: string,
    tokenName: string,
    params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams, options?: RequestInit): Promise<adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse> => {
  
  const res = await fetch(getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostUrl(userId,tokenName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse
}
  


/**
 * Admin API to delete an access token for a specific user.

Args:
    user_id: The user ID who owns the token
    token_name: Name of the token to delete
 * @summary Admin Delete Access Token
 */
export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseSuccess = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse200) & {
  headers: Headers;
};
export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseError = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse422) & {
  headers: Headers;
};

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseSuccess | adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseError)

export const getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteUrl = (userId: string,
    tokenName: string,) => {


  

  return `/api/auth/user/${userId}/access_token/${tokenName}`
}

export const adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete = async (userId: string,
    tokenName: string, options?: RequestInit): Promise<adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse> => {
  
  const res = await fetch(getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteUrl(userId,tokenName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse
}
  


/**
 * Admin API to list all access tokens for a specific user, including their assigned roles.

Args:
    user_id: The user ID to list tokens for

Returns:
    List of AccessTokenWithRoles objects
 * @summary Admin List Access Tokens
 */
export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse200 = {
  data: AccessTokenWithRoles[]
  status: 200
}

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseSuccess = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse200) & {
  headers: Headers;
};
export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseError = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse422) & {
  headers: Headers;
};

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseSuccess | adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseError)

export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/access_token`
}

export const adminListAccessTokensApiAuthUserUserIdAccessTokenGet = async (userId: string, options?: RequestInit): Promise<adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse> => {
  
  const res = await fetch(getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse
}
  


/**
 * List all users with optional filtering.

Args:
    start_index: Pagination start (1-based, default: 1)
    count: Results per page (default: 100, max: 1000)
    id_prefix: Filter users whose ID starts with this prefix
    roles: List of role names. Returns users who have ANY of these roles.
           Use multiple query params: ?roles=admin&roles=user

Returns:
    UserListResponse with paginated user list
 * @summary List Users
 */
export type listUsersApiAuthUserGetResponse200 = {
  data: UserListResponse
  status: 200
}

export type listUsersApiAuthUserGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUsersApiAuthUserGetResponseSuccess = (listUsersApiAuthUserGetResponse200) & {
  headers: Headers;
};
export type listUsersApiAuthUserGetResponseError = (listUsersApiAuthUserGetResponse422) & {
  headers: Headers;
};

export type listUsersApiAuthUserGetResponse = (listUsersApiAuthUserGetResponseSuccess | listUsersApiAuthUserGetResponseError)

export const getListUsersApiAuthUserGetUrl = (params?: ListUsersApiAuthUserGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/user?${stringifiedParams}` : `/api/auth/user`
}

export const listUsersApiAuthUserGet = async (params?: ListUsersApiAuthUserGetParams, options?: RequestInit): Promise<listUsersApiAuthUserGetResponse> => {
  
  const res = await fetch(getListUsersApiAuthUserGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsersApiAuthUserGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsersApiAuthUserGetResponse
}
  


/**
 * Create a new user.

Args:
    request: CreateUserRequest with user details
    created_by: Authenticated user making the request

Returns:
    Created User object
 * @summary Create User
 */
export type createUserApiAuthUserPostResponse200 = {
  data: User
  status: 200
}

export type createUserApiAuthUserPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createUserApiAuthUserPostResponseSuccess = (createUserApiAuthUserPostResponse200) & {
  headers: Headers;
};
export type createUserApiAuthUserPostResponseError = (createUserApiAuthUserPostResponse422) & {
  headers: Headers;
};

export type createUserApiAuthUserPostResponse = (createUserApiAuthUserPostResponseSuccess | createUserApiAuthUserPostResponseError)

export const getCreateUserApiAuthUserPostUrl = () => {


  

  return `/api/auth/user`
}

export const createUserApiAuthUserPost = async (createUserRequest: CreateUserRequest, options?: RequestInit): Promise<createUserApiAuthUserPostResponse> => {
  
  const res = await fetch(getCreateUserApiAuthUserPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUserApiAuthUserPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUserApiAuthUserPostResponse
}
  


/**
 * Get a specific user's details including their roles.

Args:
    user_id: The user ID to fetch

Returns:
    UserWithRoles object
 * @summary Get User
 */
export type getUserApiAuthUserUserIdGetResponse200 = {
  data: UserWithRoles
  status: 200
}

export type getUserApiAuthUserUserIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getUserApiAuthUserUserIdGetResponseSuccess = (getUserApiAuthUserUserIdGetResponse200) & {
  headers: Headers;
};
export type getUserApiAuthUserUserIdGetResponseError = (getUserApiAuthUserUserIdGetResponse422) & {
  headers: Headers;
};

export type getUserApiAuthUserUserIdGetResponse = (getUserApiAuthUserUserIdGetResponseSuccess | getUserApiAuthUserUserIdGetResponseError)

export const getGetUserApiAuthUserUserIdGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}`
}

export const getUserApiAuthUserUserIdGet = async (userId: string, options?: RequestInit): Promise<getUserApiAuthUserUserIdGetResponse> => {
  
  const res = await fetch(getGetUserApiAuthUserUserIdGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserApiAuthUserUserIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserApiAuthUserUserIdGetResponse
}
  


/**
 * Delete a user and all associated role assignments and PATs.

Args:
    user_id: The user ID to delete
 * @summary Delete User
 */
export type deleteUserApiAuthUserUserIdDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteUserApiAuthUserUserIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteUserApiAuthUserUserIdDeleteResponseSuccess = (deleteUserApiAuthUserUserIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteUserApiAuthUserUserIdDeleteResponseError = (deleteUserApiAuthUserUserIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteUserApiAuthUserUserIdDeleteResponse = (deleteUserApiAuthUserUserIdDeleteResponseSuccess | deleteUserApiAuthUserUserIdDeleteResponseError)

export const getDeleteUserApiAuthUserUserIdDeleteUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}`
}

export const deleteUserApiAuthUserUserIdDelete = async (userId: string, options?: RequestInit): Promise<deleteUserApiAuthUserUserIdDeleteResponse> => {
  
  const res = await fetch(getDeleteUserApiAuthUserUserIdDeleteUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUserApiAuthUserUserIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUserApiAuthUserUserIdDeleteResponse
}
  


/**
 * List all roles assigned to a user.

Args:
    user_id: The user ID

Returns:
    UserRolesResponse with list of role assignments
 * @summary List User Roles
 */
export type listUserRolesApiAuthUserUserIdRolesGetResponse200 = {
  data: UserRolesResponse
  status: 200
}

export type listUserRolesApiAuthUserUserIdRolesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUserRolesApiAuthUserUserIdRolesGetResponseSuccess = (listUserRolesApiAuthUserUserIdRolesGetResponse200) & {
  headers: Headers;
};
export type listUserRolesApiAuthUserUserIdRolesGetResponseError = (listUserRolesApiAuthUserUserIdRolesGetResponse422) & {
  headers: Headers;
};

export type listUserRolesApiAuthUserUserIdRolesGetResponse = (listUserRolesApiAuthUserUserIdRolesGetResponseSuccess | listUserRolesApiAuthUserUserIdRolesGetResponseError)

export const getListUserRolesApiAuthUserUserIdRolesGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/roles`
}

export const listUserRolesApiAuthUserUserIdRolesGet = async (userId: string, options?: RequestInit): Promise<listUserRolesApiAuthUserUserIdRolesGetResponse> => {
  
  const res = await fetch(getListUserRolesApiAuthUserUserIdRolesGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUserRolesApiAuthUserUserIdRolesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUserRolesApiAuthUserUserIdRolesGetResponse
}
  


/**
 * Assign a role to a user.

Args:
    user_id: The user ID
    request: AssignRoleRequest with role_name
    assigned_by: Authenticated user making the request

Returns:
    UserRoleAssignment with assignment details
 * @summary Assign Role To User
 */
export type assignRoleToUserApiAuthUserUserIdRolesPostResponse200 = {
  data: UserRoleAssignment
  status: 200
}

export type assignRoleToUserApiAuthUserUserIdRolesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type assignRoleToUserApiAuthUserUserIdRolesPostResponseSuccess = (assignRoleToUserApiAuthUserUserIdRolesPostResponse200) & {
  headers: Headers;
};
export type assignRoleToUserApiAuthUserUserIdRolesPostResponseError = (assignRoleToUserApiAuthUserUserIdRolesPostResponse422) & {
  headers: Headers;
};

export type assignRoleToUserApiAuthUserUserIdRolesPostResponse = (assignRoleToUserApiAuthUserUserIdRolesPostResponseSuccess | assignRoleToUserApiAuthUserUserIdRolesPostResponseError)

export const getAssignRoleToUserApiAuthUserUserIdRolesPostUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/roles`
}

export const assignRoleToUserApiAuthUserUserIdRolesPost = async (userId: string,
    assignRoleRequest: AssignRoleRequest, options?: RequestInit): Promise<assignRoleToUserApiAuthUserUserIdRolesPostResponse> => {
  
  const res = await fetch(getAssignRoleToUserApiAuthUserUserIdRolesPostUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignRoleRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: assignRoleToUserApiAuthUserUserIdRolesPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as assignRoleToUserApiAuthUserUserIdRolesPostResponse
}
  


/**
 * Remove a role from a user and all their PATs.

When a role is removed from a user, it is automatically removed from all PATs
owned by that user via the FK cascade from access_token_roles to user_roles.

Args:
    user_id: The user ID
    role_name: The role to remove
 * @summary Remove Role From User
 */
export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseSuccess = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse200) & {
  headers: Headers;
};
export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseError = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse422) & {
  headers: Headers;
};

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseSuccess | removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseError)

export const getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteUrl = (userId: string,
    roleName: string,) => {


  

  return `/api/auth/user/${userId}/roles/${roleName}`
}

export const removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete = async (userId: string,
    roleName: string, options?: RequestInit): Promise<removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse> => {
  
  const res = await fetch(getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteUrl(userId,roleName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse
}
  


/**
 * List all users who have a specific role.

Args:
    role_name: The role name

Returns:
    RoleUsersResponse with list of users
 * @summary List Users With Role
 */
export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse200 = {
  data: RoleUsersResponse
  status: 200
}

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseSuccess = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse200) & {
  headers: Headers;
};
export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseError = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse422) & {
  headers: Headers;
};

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseSuccess | listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseError)

export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetUrl = (roleName: string,) => {


  

  return `/api/auth/roles/${roleName}/users`
}

export const listUsersWithRoleApiAuthRolesRoleNameUsersGet = async (roleName: string, options?: RequestInit): Promise<listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse> => {
  
  const res = await fetch(getListUsersWithRoleApiAuthRolesRoleNameUsersGetUrl(roleName),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse
}
  


/**
 * Bulk assign a role to multiple users.

Args:
    role_name: The role to assign
    request: BulkAssignRequest with list of user_ids
    assigned_by: Authenticated user making the request

Returns:
    BulkAssignResponse with results
 * @summary Bulk Assign Role
 */
export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse200 = {
  data: BulkAssignResponse
  status: 200
}

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseSuccess = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse200) & {
  headers: Headers;
};
export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseError = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse422) & {
  headers: Headers;
};

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseSuccess | bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseError)

export const getBulkAssignRoleApiAuthRolesRoleNameUsersPostUrl = (roleName: string,) => {


  

  return `/api/auth/roles/${roleName}/users`
}

export const bulkAssignRoleApiAuthRolesRoleNameUsersPost = async (roleName: string,
    bulkAssignRequest: BulkAssignRequest, options?: RequestInit): Promise<bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse> => {
  
  const res = await fetch(getBulkAssignRoleApiAuthRolesRoleNameUsersPostUrl(roleName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkAssignRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse
}
  


/**
 * @summary List Apps
 */
export type listAppsApiAppGetResponse200 = {
  data: string
  status: 200
}

export type listAppsApiAppGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAppsApiAppGetResponseSuccess = (listAppsApiAppGetResponse200) & {
  headers: Headers;
};
export type listAppsApiAppGetResponseError = (listAppsApiAppGetResponse422) & {
  headers: Headers;
};

export type listAppsApiAppGetResponse = (listAppsApiAppGetResponseSuccess | listAppsApiAppGetResponseError)

export const getListAppsApiAppGetUrl = (params?: ListAppsApiAppGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app?${stringifiedParams}` : `/api/app`
}

export const listAppsApiAppGet = async (params?: ListAppsApiAppGetParams, options?: RequestInit): Promise<listAppsApiAppGetResponse> => {
  
  const res = await fetch(getListAppsApiAppGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listAppsApiAppGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listAppsApiAppGetResponse
}
  


/**
 * @summary Get App
 */
export type getAppApiAppUserNameGetResponse200 = {
  data: string
  status: 200
}

export type getAppApiAppUserNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAppApiAppUserNameGetResponseSuccess = (getAppApiAppUserNameGetResponse200) & {
  headers: Headers;
};
export type getAppApiAppUserNameGetResponseError = (getAppApiAppUserNameGetResponse422) & {
  headers: Headers;
};

export type getAppApiAppUserNameGetResponse = (getAppApiAppUserNameGetResponseSuccess | getAppApiAppUserNameGetResponseError)

export const getGetAppApiAppUserNameGetUrl = (name: string,
    params?: GetAppApiAppUserNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const getAppApiAppUserNameGet = async (name: string,
    params?: GetAppApiAppUserNameGetParams, options?: RequestInit): Promise<getAppApiAppUserNameGetResponse> => {
  
  const res = await fetch(getGetAppApiAppUserNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppApiAppUserNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppApiAppUserNameGetResponse
}
  


/**
 * @summary Create App
 */
export type createAppApiAppUserNamePostResponse200 = {
  data: unknown
  status: 200
}

export type createAppApiAppUserNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createAppApiAppUserNamePostResponseSuccess = (createAppApiAppUserNamePostResponse200) & {
  headers: Headers;
};
export type createAppApiAppUserNamePostResponseError = (createAppApiAppUserNamePostResponse422) & {
  headers: Headers;
};

export type createAppApiAppUserNamePostResponse = (createAppApiAppUserNamePostResponseSuccess | createAppApiAppUserNamePostResponseError)

export const getCreateAppApiAppUserNamePostUrl = (name: string,
    params: CreateAppApiAppUserNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const createAppApiAppUserNamePost = async (name: string,
    createAppApiAppUserNamePostBody: string,
    params: CreateAppApiAppUserNamePostParams, options?: RequestInit): Promise<createAppApiAppUserNamePostResponse> => {
  
  const res = await fetch(getCreateAppApiAppUserNamePostUrl(name,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createAppApiAppUserNamePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createAppApiAppUserNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createAppApiAppUserNamePostResponse
}
  


/**
 * @summary Delete App
 */
export type deleteAppApiAppUserNameDeleteResponse200 = {
  data: DeleteAppApiAppUserNameDelete200
  status: 200
}

export type deleteAppApiAppUserNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteAppApiAppUserNameDeleteResponseSuccess = (deleteAppApiAppUserNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteAppApiAppUserNameDeleteResponseError = (deleteAppApiAppUserNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteAppApiAppUserNameDeleteResponse = (deleteAppApiAppUserNameDeleteResponseSuccess | deleteAppApiAppUserNameDeleteResponseError)

export const getDeleteAppApiAppUserNameDeleteUrl = (name: string,
    params?: DeleteAppApiAppUserNameDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const deleteAppApiAppUserNameDelete = async (name: string,
    params?: DeleteAppApiAppUserNameDeleteParams, options?: RequestInit): Promise<deleteAppApiAppUserNameDeleteResponse> => {
  
  const res = await fetch(getDeleteAppApiAppUserNameDeleteUrl(name,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteAppApiAppUserNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteAppApiAppUserNameDeleteResponse
}
  


/**
 * @summary Update App
 */
export type updateAppApiAppUserNamePatchResponse200 = {
  data: EditResponse
  status: 200
}

export type updateAppApiAppUserNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateAppApiAppUserNamePatchResponseSuccess = (updateAppApiAppUserNamePatchResponse200) & {
  headers: Headers;
};
export type updateAppApiAppUserNamePatchResponseError = (updateAppApiAppUserNamePatchResponse422) & {
  headers: Headers;
};

export type updateAppApiAppUserNamePatchResponse = (updateAppApiAppUserNamePatchResponseSuccess | updateAppApiAppUserNamePatchResponseError)

export const getUpdateAppApiAppUserNamePatchUrl = (name: string,) => {


  

  return `/api/app/user/${name}`
}

export const updateAppApiAppUserNamePatch = async (name: string,
    updateAppApiAppUserNamePatchBody: string, options?: RequestInit): Promise<updateAppApiAppUserNamePatchResponse> => {
  
  const res = await fetch(getUpdateAppApiAppUserNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateAppApiAppUserNamePatchBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateAppApiAppUserNamePatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateAppApiAppUserNamePatchResponse
}
  


/**
 * @summary Get App Content
 */
export type getAppContentApiAppUserNameSpecGetResponse200 = {
  data: string
  status: 200
}

export type getAppContentApiAppUserNameSpecGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAppContentApiAppUserNameSpecGetResponseSuccess = (getAppContentApiAppUserNameSpecGetResponse200) & {
  headers: Headers;
};
export type getAppContentApiAppUserNameSpecGetResponseError = (getAppContentApiAppUserNameSpecGetResponse422) & {
  headers: Headers;
};

export type getAppContentApiAppUserNameSpecGetResponse = (getAppContentApiAppUserNameSpecGetResponseSuccess | getAppContentApiAppUserNameSpecGetResponseError)

export const getGetAppContentApiAppUserNameSpecGetUrl = (name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}/spec?${stringifiedParams}` : `/api/app/user/${name}/spec`
}

export const getAppContentApiAppUserNameSpecGet = async (name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: RequestInit): Promise<getAppContentApiAppUserNameSpecGetResponse> => {
  
  const res = await fetch(getGetAppContentApiAppUserNameSpecGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppContentApiAppUserNameSpecGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppContentApiAppUserNameSpecGetResponse
}
  


/**
 * @summary Rename App
 */
export type renameAppApiAppUserNameRenamePostResponse200 = {
  data: string
  status: 200
}

export type renameAppApiAppUserNameRenamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renameAppApiAppUserNameRenamePostResponseSuccess = (renameAppApiAppUserNameRenamePostResponse200) & {
  headers: Headers;
};
export type renameAppApiAppUserNameRenamePostResponseError = (renameAppApiAppUserNameRenamePostResponse422) & {
  headers: Headers;
};

export type renameAppApiAppUserNameRenamePostResponse = (renameAppApiAppUserNameRenamePostResponseSuccess | renameAppApiAppUserNameRenamePostResponseError)

export const getRenameAppApiAppUserNameRenamePostUrl = (name: string,) => {


  

  return `/api/app/user/${name}/rename`
}

export const renameAppApiAppUserNameRenamePost = async (name: string,
    renameAppApiAppUserNameRenamePostBody: string, options?: RequestInit): Promise<renameAppApiAppUserNameRenamePostResponse> => {
  
  const res = await fetch(getRenameAppApiAppUserNameRenamePostUrl(name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renameAppApiAppUserNameRenamePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: renameAppApiAppUserNameRenamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as renameAppApiAppUserNameRenamePostResponse
}
  


/**
 * Cancels the workflow.
 * @summary Cancel Workflow
 */
export type cancelWorkflowApiWorkflowNameCancelPostResponse200 = {
  data: CancelResponse
  status: 200
}

export type cancelWorkflowApiWorkflowNameCancelPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type cancelWorkflowApiWorkflowNameCancelPostResponseSuccess = (cancelWorkflowApiWorkflowNameCancelPostResponse200) & {
  headers: Headers;
};
export type cancelWorkflowApiWorkflowNameCancelPostResponseError = (cancelWorkflowApiWorkflowNameCancelPostResponse422) & {
  headers: Headers;
};

export type cancelWorkflowApiWorkflowNameCancelPostResponse = (cancelWorkflowApiWorkflowNameCancelPostResponseSuccess | cancelWorkflowApiWorkflowNameCancelPostResponseError)

export const getCancelWorkflowApiWorkflowNameCancelPostUrl = (name: string,
    params?: CancelWorkflowApiWorkflowNameCancelPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/cancel?${stringifiedParams}` : `/api/workflow/${name}/cancel`
}

export const cancelWorkflowApiWorkflowNameCancelPost = async (name: string,
    params?: CancelWorkflowApiWorkflowNameCancelPostParams, options?: RequestInit): Promise<cancelWorkflowApiWorkflowNameCancelPostResponse> => {
  
  const res = await fetch(getCancelWorkflowApiWorkflowNameCancelPostUrl(name,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: cancelWorkflowApiWorkflowNameCancelPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as cancelWorkflowApiWorkflowNameCancelPostResponse
}
  


/**
 * @summary List Workflow
 */
export type listWorkflowApiWorkflowGetResponse200 = {
  data: string
  status: 200
}

export type listWorkflowApiWorkflowGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listWorkflowApiWorkflowGetResponseSuccess = (listWorkflowApiWorkflowGetResponse200) & {
  headers: Headers;
};
export type listWorkflowApiWorkflowGetResponseError = (listWorkflowApiWorkflowGetResponse422) & {
  headers: Headers;
};

export type listWorkflowApiWorkflowGetResponse = (listWorkflowApiWorkflowGetResponseSuccess | listWorkflowApiWorkflowGetResponseError)

export const getListWorkflowApiWorkflowGetUrl = (params?: ListWorkflowApiWorkflowGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow?${stringifiedParams}` : `/api/workflow`
}

export const listWorkflowApiWorkflowGet = async (params?: ListWorkflowApiWorkflowGetParams, options?: RequestInit): Promise<listWorkflowApiWorkflowGetResponse> => {
  
  const res = await fetch(getListWorkflowApiWorkflowGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listWorkflowApiWorkflowGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listWorkflowApiWorkflowGetResponse
}
  


/**
 * Returns the task (with the latest retry_id) with the given name in the workflow.
 * @summary Get Workflow Task
 */
export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseSuccess = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse200) & {
  headers: Headers;
};
export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseError = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse422) & {
  headers: Headers;
};

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseSuccess | getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseError)

export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetUrl = (name: string,
    taskName: string,) => {


  

  return `/api/workflow/${name}/task/${taskName}`
}

export const getWorkflowTaskApiWorkflowNameTaskTaskNameGet = async (name: string,
    taskName: string, options?: RequestInit): Promise<getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse> => {
  
  const res = await fetch(getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetUrl(name,taskName),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse
}
  


/**
 * @summary List Task
 */
export type listTaskApiTaskGetResponse200 = {
  data: string
  status: 200
}

export type listTaskApiTaskGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listTaskApiTaskGetResponseSuccess = (listTaskApiTaskGetResponse200) & {
  headers: Headers;
};
export type listTaskApiTaskGetResponseError = (listTaskApiTaskGetResponse422) & {
  headers: Headers;
};

export type listTaskApiTaskGetResponse = (listTaskApiTaskGetResponseSuccess | listTaskApiTaskGetResponseError)

export const getListTaskApiTaskGetUrl = (params?: ListTaskApiTaskGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/task?${stringifiedParams}` : `/api/task`
}

export const listTaskApiTaskGet = async (params?: ListTaskApiTaskGetParams, options?: RequestInit): Promise<listTaskApiTaskGetResponse> => {
  
  const res = await fetch(getListTaskApiTaskGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listTaskApiTaskGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listTaskApiTaskGetResponse
}
  


/**
 * Returns the workflow with the given name in the database.
 * @summary Get Workflow
 */
export type getWorkflowApiWorkflowNameGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowApiWorkflowNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowApiWorkflowNameGetResponseSuccess = (getWorkflowApiWorkflowNameGetResponse200) & {
  headers: Headers;
};
export type getWorkflowApiWorkflowNameGetResponseError = (getWorkflowApiWorkflowNameGetResponse422) & {
  headers: Headers;
};

export type getWorkflowApiWorkflowNameGetResponse = (getWorkflowApiWorkflowNameGetResponseSuccess | getWorkflowApiWorkflowNameGetResponseError)

export const getGetWorkflowApiWorkflowNameGetUrl = (name: string,
    params?: GetWorkflowApiWorkflowNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}?${stringifiedParams}` : `/api/workflow/${name}`
}

export const getWorkflowApiWorkflowNameGet = async (name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: RequestInit): Promise<getWorkflowApiWorkflowNameGetResponse> => {
  
  const res = await fetch(getGetWorkflowApiWorkflowNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowApiWorkflowNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowApiWorkflowNameGetResponse
}
  


/**
 * Returns the workflow logs.
 * @summary Get Workflow Logs
 */
export type getWorkflowLogsApiWorkflowNameLogsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowLogsApiWorkflowNameLogsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowLogsApiWorkflowNameLogsGetResponseSuccess = (getWorkflowLogsApiWorkflowNameLogsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowLogsApiWorkflowNameLogsGetResponseError = (getWorkflowLogsApiWorkflowNameLogsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowLogsApiWorkflowNameLogsGetResponse = (getWorkflowLogsApiWorkflowNameLogsGetResponseSuccess | getWorkflowLogsApiWorkflowNameLogsGetResponseError)

export const getGetWorkflowLogsApiWorkflowNameLogsGetUrl = (name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/logs?${stringifiedParams}` : `/api/workflow/${name}/logs`
}

export const getWorkflowLogsApiWorkflowNameLogsGet = async (name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: RequestInit): Promise<getWorkflowLogsApiWorkflowNameLogsGetResponse> => {
  
  const res = await fetch(getGetWorkflowLogsApiWorkflowNameLogsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowLogsApiWorkflowNameLogsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowLogsApiWorkflowNameLogsGetResponse
}
  


/**
 * Returns the workflow pod conditions.
 * @summary Get Workflow Pod Conditions
 */
export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponseSuccess = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponseError = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponseSuccess | getWorkflowPodConditionsApiWorkflowNameEventsGetResponseError)

export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetUrl = (name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/events?${stringifiedParams}` : `/api/workflow/${name}/events`
}

export const getWorkflowPodConditionsApiWorkflowNameEventsGet = async (name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: RequestInit): Promise<getWorkflowPodConditionsApiWorkflowNameEventsGetResponse> => {
  
  const res = await fetch(getGetWorkflowPodConditionsApiWorkflowNameEventsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowPodConditionsApiWorkflowNameEventsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowPodConditionsApiWorkflowNameEventsGetResponse
}
  


/**
 * Returns the workflow error logs.
 * @summary Get Workflow Error Logs
 */
export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseSuccess = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseError = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseSuccess | getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseError)

export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetUrl = (name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/error_logs?${stringifiedParams}` : `/api/workflow/${name}/error_logs`
}

export const getWorkflowErrorLogsApiWorkflowNameErrorLogsGet = async (name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: RequestInit): Promise<getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse> => {
  
  const res = await fetch(getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse
}
  


/**
 * Returns the workflow spec.
 * @summary Get Workflow Spec
 */
export type getWorkflowSpecApiWorkflowNameSpecGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowSpecApiWorkflowNameSpecGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowSpecApiWorkflowNameSpecGetResponseSuccess = (getWorkflowSpecApiWorkflowNameSpecGetResponse200) & {
  headers: Headers;
};
export type getWorkflowSpecApiWorkflowNameSpecGetResponseError = (getWorkflowSpecApiWorkflowNameSpecGetResponse422) & {
  headers: Headers;
};

export type getWorkflowSpecApiWorkflowNameSpecGetResponse = (getWorkflowSpecApiWorkflowNameSpecGetResponseSuccess | getWorkflowSpecApiWorkflowNameSpecGetResponseError)

export const getGetWorkflowSpecApiWorkflowNameSpecGetUrl = (name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/spec?${stringifiedParams}` : `/api/workflow/${name}/spec`
}

export const getWorkflowSpecApiWorkflowNameSpecGet = async (name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: RequestInit): Promise<getWorkflowSpecApiWorkflowNameSpecGetResponse> => {
  
  const res = await fetch(getGetWorkflowSpecApiWorkflowNameSpecGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowSpecApiWorkflowNameSpecGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowSpecApiWorkflowNameSpecGetResponse
}
  


/**
 * Returns the workflow spec.
 * @summary Tag Workflow
 */
export type tagWorkflowApiWorkflowNameTagPostResponse200 = {
  data: unknown
  status: 200
}

export type tagWorkflowApiWorkflowNameTagPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type tagWorkflowApiWorkflowNameTagPostResponseSuccess = (tagWorkflowApiWorkflowNameTagPostResponse200) & {
  headers: Headers;
};
export type tagWorkflowApiWorkflowNameTagPostResponseError = (tagWorkflowApiWorkflowNameTagPostResponse422) & {
  headers: Headers;
};

export type tagWorkflowApiWorkflowNameTagPostResponse = (tagWorkflowApiWorkflowNameTagPostResponseSuccess | tagWorkflowApiWorkflowNameTagPostResponseError)

export const getTagWorkflowApiWorkflowNameTagPostUrl = (name: string,
    params?: TagWorkflowApiWorkflowNameTagPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/tag?${stringifiedParams}` : `/api/workflow/${name}/tag`
}

export const tagWorkflowApiWorkflowNameTagPost = async (name: string,
    params?: TagWorkflowApiWorkflowNameTagPostParams, options?: RequestInit): Promise<tagWorkflowApiWorkflowNameTagPostResponse> => {
  
  const res = await fetch(getTagWorkflowApiWorkflowNameTagPostUrl(name,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: tagWorkflowApiWorkflowNameTagPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as tagWorkflowApiWorkflowNameTagPostResponse
}
  


/**
 * Send command to all tasks in a group.
 * @summary Exec Into Group
 */
export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse200 = {
  data: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200
  status: 200
}

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseSuccess = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse200) & {
  headers: Headers;
};
export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseError = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse422) & {
  headers: Headers;
};

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseSuccess | execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseError)

export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostUrl = (name: string,
    groupName: string,
    params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/exec/group/${groupName}?${stringifiedParams}` : `/api/workflow/${name}/exec/group/${groupName}`
}

export const execIntoGroupApiWorkflowNameExecGroupGroupNamePost = async (name: string,
    groupName: string,
    params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams, options?: RequestInit): Promise<execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse> => {
  
  const res = await fetch(getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostUrl(name,groupName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse
}
  


/**
 * Exec into a task container.
 * @summary Exec Into Task
 */
export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseSuccess = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse200) & {
  headers: Headers;
};
export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseError = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse422) & {
  headers: Headers;
};

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseSuccess | execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseError)

export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostUrl = (name: string,
    taskName: string,
    params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/exec/task/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/exec/task/${taskName}`
}

export const execIntoTaskApiWorkflowNameExecTaskTaskNamePost = async (name: string,
    taskName: string,
    params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams, options?: RequestInit): Promise<execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse> => {
  
  const res = await fetch(getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse
}
  


/**
 * Portforward into a task container.
 * @summary Port Forward Task
 */
export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse200 = {
  data: RouterResponse[] | RouterResponse
  status: 200
}

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseSuccess = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse200) & {
  headers: Headers;
};
export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseError = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse422) & {
  headers: Headers;
};

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseSuccess | portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseError)

export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostUrl = (name: string,
    taskName: string,
    params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/portforward/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/portforward/${taskName}`
}

export const portForwardTaskApiWorkflowNamePortforwardTaskNamePost = async (name: string,
    taskName: string,
    params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams, options?: RequestInit): Promise<portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse> => {
  
  const res = await fetch(getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse
}
  


/**
 * Hold a webserver connection to a task container.
 * @summary Port Forward Webserver
 */
export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseSuccess = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse200) & {
  headers: Headers;
};
export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseError = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse422) & {
  headers: Headers;
};

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseSuccess | portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseError)

export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostUrl = (name: string,
    taskName: string,
    params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/webserver/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/webserver/${taskName}`
}

export const portForwardWebserverApiWorkflowNameWebserverTaskNamePost = async (name: string,
    taskName: string,
    params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams, options?: RequestInit): Promise<portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse> => {
  
  const res = await fetch(getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse
}
  


/**
 * Rsync into a task container.
 * @summary Rsync Task
 */
export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseSuccess = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse200) & {
  headers: Headers;
};
export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseError = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse422) & {
  headers: Headers;
};

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseSuccess | rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseError)

export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostUrl = (name: string,
    taskName: string,) => {


  

  return `/api/workflow/${name}/rsync/task/${taskName}`
}

export const rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost = async (name: string,
    taskName: string, options?: RequestInit): Promise<rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse> => {
  
  const res = await fetch(getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostUrl(name,taskName),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse
}
  


/**
 * Get default/all user credentials
 * @summary Get User Credential
 */
export type getUserCredentialApiCredentialsGetResponse200 = {
  data: string
  status: 200
}

export type getUserCredentialApiCredentialsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getUserCredentialApiCredentialsGetResponseSuccess = (getUserCredentialApiCredentialsGetResponse200) & {
  headers: Headers;
};
export type getUserCredentialApiCredentialsGetResponseError = (getUserCredentialApiCredentialsGetResponse422) & {
  headers: Headers;
};

export type getUserCredentialApiCredentialsGetResponse = (getUserCredentialApiCredentialsGetResponseSuccess | getUserCredentialApiCredentialsGetResponseError)

export const getGetUserCredentialApiCredentialsGetUrl = () => {


  

  return `/api/credentials`
}

export const getUserCredentialApiCredentialsGet = async ( options?: RequestInit): Promise<getUserCredentialApiCredentialsGetResponse> => {
  
  const res = await fetch(getGetUserCredentialApiCredentialsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserCredentialApiCredentialsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserCredentialApiCredentialsGetResponse
}
  


/**
 * Post/Update user credentials
 * @summary Set User Credential
 */
export type setUserCredentialApiCredentialsCredNamePostResponse200 = {
  data: unknown
  status: 200
}

export type setUserCredentialApiCredentialsCredNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type setUserCredentialApiCredentialsCredNamePostResponseSuccess = (setUserCredentialApiCredentialsCredNamePostResponse200) & {
  headers: Headers;
};
export type setUserCredentialApiCredentialsCredNamePostResponseError = (setUserCredentialApiCredentialsCredNamePostResponse422) & {
  headers: Headers;
};

export type setUserCredentialApiCredentialsCredNamePostResponse = (setUserCredentialApiCredentialsCredNamePostResponseSuccess | setUserCredentialApiCredentialsCredNamePostResponseError)

export const getSetUserCredentialApiCredentialsCredNamePostUrl = (credName: string,) => {


  

  return `/api/credentials/${credName}`
}

export const setUserCredentialApiCredentialsCredNamePost = async (credName: string,
    credentialOptions: CredentialOptions, options?: RequestInit): Promise<setUserCredentialApiCredentialsCredNamePostResponse> => {
  
  const res = await fetch(getSetUserCredentialApiCredentialsCredNamePostUrl(credName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      credentialOptions,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setUserCredentialApiCredentialsCredNamePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setUserCredentialApiCredentialsCredNamePostResponse
}
  


/**
 * Delete user credentials given the secret_id
 * @summary Delete Users Credential
 */
export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse200 = {
  data: CredentialGetResponse
  status: 200
}

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponseSuccess = (deleteUsersCredentialApiCredentialsCredNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteUsersCredentialApiCredentialsCredNameDeleteResponseError = (deleteUsersCredentialApiCredentialsCredNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse = (deleteUsersCredentialApiCredentialsCredNameDeleteResponseSuccess | deleteUsersCredentialApiCredentialsCredNameDeleteResponseError)

export const getDeleteUsersCredentialApiCredentialsCredNameDeleteUrl = (credName: string,) => {


  

  return `/api/credentials/${credName}`
}

export const deleteUsersCredentialApiCredentialsCredNameDelete = async (credName: string, options?: RequestInit): Promise<deleteUsersCredentialApiCredentialsCredNameDeleteResponse> => {
  
  const res = await fetch(getDeleteUsersCredentialApiCredentialsCredNameDeleteUrl(credName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUsersCredentialApiCredentialsCredNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUsersCredentialApiCredentialsCredNameDeleteResponse
}
  


/**
 * Returns the information of resources available in different pools.
 * @summary Get Resources
 */
export type getResourcesApiResourcesGetResponse200 = {
  data: string
  status: 200
}

export type getResourcesApiResourcesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getResourcesApiResourcesGetResponseSuccess = (getResourcesApiResourcesGetResponse200) & {
  headers: Headers;
};
export type getResourcesApiResourcesGetResponseError = (getResourcesApiResourcesGetResponse422) & {
  headers: Headers;
};

export type getResourcesApiResourcesGetResponse = (getResourcesApiResourcesGetResponseSuccess | getResourcesApiResourcesGetResponseError)

export const getGetResourcesApiResourcesGetUrl = (params?: GetResourcesApiResourcesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/resources?${stringifiedParams}` : `/api/resources`
}

export const getResourcesApiResourcesGet = async (params?: GetResourcesApiResourcesGetParams, options?: RequestInit): Promise<getResourcesApiResourcesGetResponse> => {
  
  const res = await fetch(getGetResourcesApiResourcesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getResourcesApiResourcesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getResourcesApiResourcesGetResponse
}
  


/**
 * Returns the request resource's information.
 * @summary Get One Resource
 */
export type getOneResourceApiResourcesNameGetResponse200 = {
  data: string
  status: 200
}

export type getOneResourceApiResourcesNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getOneResourceApiResourcesNameGetResponseSuccess = (getOneResourceApiResourcesNameGetResponse200) & {
  headers: Headers;
};
export type getOneResourceApiResourcesNameGetResponseError = (getOneResourceApiResourcesNameGetResponse422) & {
  headers: Headers;
};

export type getOneResourceApiResourcesNameGetResponse = (getOneResourceApiResourcesNameGetResponseSuccess | getOneResourceApiResourcesNameGetResponseError)

export const getGetOneResourceApiResourcesNameGetUrl = (name: string,) => {


  

  return `/api/resources/${name}`
}

export const getOneResourceApiResourcesNameGet = async (name: string, options?: RequestInit): Promise<getOneResourceApiResourcesNameGetResponse> => {
  
  const res = await fetch(getGetOneResourceApiResourcesNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOneResourceApiResourcesNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOneResourceApiResourcesNameGetResponse
}
  


/**
 * Returns information regarding pools to users.

If all_pools is set to true, all pools' information will be returned in API response.
Otherwise, only information from pools that the user has access to will be returned
in the response.
 * @summary Get Pools
 */
export type getPoolsApiPoolGetResponse200 = {
  data: string
  status: 200
}

export type getPoolsApiPoolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getPoolsApiPoolGetResponseSuccess = (getPoolsApiPoolGetResponse200) & {
  headers: Headers;
};
export type getPoolsApiPoolGetResponseError = (getPoolsApiPoolGetResponse422) & {
  headers: Headers;
};

export type getPoolsApiPoolGetResponse = (getPoolsApiPoolGetResponseSuccess | getPoolsApiPoolGetResponseError)

export const getGetPoolsApiPoolGetUrl = (params?: GetPoolsApiPoolGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool?${stringifiedParams}` : `/api/pool`
}

export const getPoolsApiPoolGet = async (params?: GetPoolsApiPoolGetParams, options?: RequestInit): Promise<getPoolsApiPoolGetResponse> => {
  
  const res = await fetch(getGetPoolsApiPoolGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPoolsApiPoolGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPoolsApiPoolGetResponse
}
  


/**
 * @summary Get Pool Quotas
 */
export type getPoolQuotasApiPoolQuotaGetResponse200 = {
  data: string
  status: 200
}

export type getPoolQuotasApiPoolQuotaGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getPoolQuotasApiPoolQuotaGetResponseSuccess = (getPoolQuotasApiPoolQuotaGetResponse200) & {
  headers: Headers;
};
export type getPoolQuotasApiPoolQuotaGetResponseError = (getPoolQuotasApiPoolQuotaGetResponse422) & {
  headers: Headers;
};

export type getPoolQuotasApiPoolQuotaGetResponse = (getPoolQuotasApiPoolQuotaGetResponseSuccess | getPoolQuotasApiPoolQuotaGetResponseError)

export const getGetPoolQuotasApiPoolQuotaGetUrl = (params?: GetPoolQuotasApiPoolQuotaGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool_quota?${stringifiedParams}` : `/api/pool_quota`
}

export const getPoolQuotasApiPoolQuotaGet = async (params?: GetPoolQuotasApiPoolQuotaGetParams, options?: RequestInit): Promise<getPoolQuotasApiPoolQuotaGetResponse> => {
  
  const res = await fetch(getGetPoolQuotasApiPoolQuotaGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPoolQuotasApiPoolQuotaGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPoolQuotasApiPoolQuotaGetResponse
}
  


/**
 * This api validates that a workflow is well formed and valid and then submits it.
 * @summary Submit Workflow
 */
export type submitWorkflowApiPoolPoolNameWorkflowPostResponse200 = {
  data: SubmitResponse
  status: 200
}

export type submitWorkflowApiPoolPoolNameWorkflowPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type submitWorkflowApiPoolPoolNameWorkflowPostResponseSuccess = (submitWorkflowApiPoolPoolNameWorkflowPostResponse200) & {
  headers: Headers;
};
export type submitWorkflowApiPoolPoolNameWorkflowPostResponseError = (submitWorkflowApiPoolPoolNameWorkflowPostResponse422) & {
  headers: Headers;
};

export type submitWorkflowApiPoolPoolNameWorkflowPostResponse = (submitWorkflowApiPoolPoolNameWorkflowPostResponseSuccess | submitWorkflowApiPoolPoolNameWorkflowPostResponseError)

export const getSubmitWorkflowApiPoolPoolNameWorkflowPostUrl = (poolName: string,
    params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool/${poolName}/workflow?${stringifiedParams}` : `/api/pool/${poolName}/workflow`
}

export const submitWorkflowApiPoolPoolNameWorkflowPost = async (poolName: string,
    templateSpec: TemplateSpec,
    params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams, options?: RequestInit): Promise<submitWorkflowApiPoolPoolNameWorkflowPostResponse> => {
  
  const res = await fetch(getSubmitWorkflowApiPoolPoolNameWorkflowPostUrl(poolName,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      templateSpec,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: submitWorkflowApiPoolPoolNameWorkflowPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as submitWorkflowApiPoolPoolNameWorkflowPostResponse
}
  


/**
 * This api restarts a failed workflow and then submits it.
 * @summary Restart Workflow
 */
export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse200 = {
  data: SubmitResponse
  status: 200
}

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseSuccess = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse200) & {
  headers: Headers;
};
export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseError = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse422) & {
  headers: Headers;
};

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseSuccess | restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseError)

export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostUrl = (poolName: string,
    workflowId: string,) => {


  

  return `/api/pool/${poolName}/workflow/${workflowId}/restart`
}

export const restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost = async (poolName: string,
    workflowId: string, options?: RequestInit): Promise<restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse> => {
  
  const res = await fetch(getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostUrl(poolName,workflowId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse
}
  


/**
 * This api allows users to fetch the default bucket and the list of available buckets.
 * @summary Get Bucket Info
 */
export type getBucketInfoApiBucketGetResponse200 = {
  data: BucketInfoResponse
  status: 200
}

export type getBucketInfoApiBucketGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getBucketInfoApiBucketGetResponseSuccess = (getBucketInfoApiBucketGetResponse200) & {
  headers: Headers;
};
export type getBucketInfoApiBucketGetResponseError = (getBucketInfoApiBucketGetResponse422) & {
  headers: Headers;
};

export type getBucketInfoApiBucketGetResponse = (getBucketInfoApiBucketGetResponseSuccess | getBucketInfoApiBucketGetResponseError)

export const getGetBucketInfoApiBucketGetUrl = (params?: GetBucketInfoApiBucketGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket?${stringifiedParams}` : `/api/bucket`
}

export const getBucketInfoApiBucketGet = async (params?: GetBucketInfoApiBucketGetParams, options?: RequestInit): Promise<getBucketInfoApiBucketGetResponse> => {
  
  const res = await fetch(getGetBucketInfoApiBucketGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getBucketInfoApiBucketGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getBucketInfoApiBucketGetResponse
}
  


/**
 * This api deletes a Dataset.
 * @summary Delete Dataset
 */
export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponseSuccess = (deleteDatasetApiBucketBucketDatasetNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteDatasetApiBucketBucketDatasetNameDeleteResponseError = (deleteDatasetApiBucketBucketDatasetNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse = (deleteDatasetApiBucketBucketDatasetNameDeleteResponseSuccess | deleteDatasetApiBucketBucketDatasetNameDeleteResponseError)

export const getDeleteDatasetApiBucketBucketDatasetNameDeleteUrl = (bucket: string,
    name: string,
    params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}`
}

export const deleteDatasetApiBucketBucketDatasetNameDelete = async (bucket: string,
    name: string,
    params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams, options?: RequestInit): Promise<deleteDatasetApiBucketBucketDatasetNameDeleteResponse> => {
  
  const res = await fetch(getDeleteDatasetApiBucketBucketDatasetNameDeleteUrl(bucket,name,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDatasetApiBucketBucketDatasetNameDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDatasetApiBucketBucketDatasetNameDeleteResponse
}
  


/**
 * This api can rename a dataset/collection or set/remove tags/labels/metadata.
If tag is not given, latest tag is selected
 * @summary Change Name Tag Label Metadata
 */
export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse200 = {
  data: DataAttributeResponse
  status: 200
}

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseSuccess = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse200) & {
  headers: Headers;
};
export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseError = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse422) & {
  headers: Headers;
};

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseSuccess | changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseError)

export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostUrl = (bucket: string,
    name: string,
    params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}/attribute?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}/attribute`
}

export const changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost = async (bucket: string,
    name: string,
    bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,
    params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams, options?: RequestInit): Promise<changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse> => {
  
  const res = await fetch(getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostUrl(bucket,name,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse
}
  


/**
 * This api gives info about the Dataset or Dataset Version.
 * @summary Get Info
 */
export type getInfoApiBucketBucketDatasetNameInfoGetResponse200 = {
  data: DataInfoResponse
  status: 200
}

export type getInfoApiBucketBucketDatasetNameInfoGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getInfoApiBucketBucketDatasetNameInfoGetResponseSuccess = (getInfoApiBucketBucketDatasetNameInfoGetResponse200) & {
  headers: Headers;
};
export type getInfoApiBucketBucketDatasetNameInfoGetResponseError = (getInfoApiBucketBucketDatasetNameInfoGetResponse422) & {
  headers: Headers;
};

export type getInfoApiBucketBucketDatasetNameInfoGetResponse = (getInfoApiBucketBucketDatasetNameInfoGetResponseSuccess | getInfoApiBucketBucketDatasetNameInfoGetResponseError)

export const getGetInfoApiBucketBucketDatasetNameInfoGetUrl = (bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}/info?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}/info`
}

export const getInfoApiBucketBucketDatasetNameInfoGet = async (bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: RequestInit): Promise<getInfoApiBucketBucketDatasetNameInfoGetResponse> => {
  
  const res = await fetch(getGetInfoApiBucketBucketDatasetNameInfoGetUrl(bucket,name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getInfoApiBucketBucketDatasetNameInfoGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInfoApiBucketBucketDatasetNameInfoGetResponse
}
  


/**
 * This api returns the list of datasets/colections.
 * @summary List Dataset From Bucket
 */
export type listDatasetFromBucketApiBucketListDatasetGetResponse200 = {
  data: DataListResponse
  status: 200
}

export type listDatasetFromBucketApiBucketListDatasetGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listDatasetFromBucketApiBucketListDatasetGetResponseSuccess = (listDatasetFromBucketApiBucketListDatasetGetResponse200) & {
  headers: Headers;
};
export type listDatasetFromBucketApiBucketListDatasetGetResponseError = (listDatasetFromBucketApiBucketListDatasetGetResponse422) & {
  headers: Headers;
};

export type listDatasetFromBucketApiBucketListDatasetGetResponse = (listDatasetFromBucketApiBucketListDatasetGetResponseSuccess | listDatasetFromBucketApiBucketListDatasetGetResponseError)

export const getListDatasetFromBucketApiBucketListDatasetGetUrl = (params?: ListDatasetFromBucketApiBucketListDatasetGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/list_dataset?${stringifiedParams}` : `/api/bucket/list_dataset`
}

export const listDatasetFromBucketApiBucketListDatasetGet = async (params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: RequestInit): Promise<listDatasetFromBucketApiBucketListDatasetGetResponse> => {
  
  const res = await fetch(getListDatasetFromBucketApiBucketListDatasetGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listDatasetFromBucketApiBucketListDatasetGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listDatasetFromBucketApiBucketListDatasetGetResponse
}
  


/**
 * This api creates a collection from datasets.
 * @summary Create Collection
 */
export type createCollectionApiBucketBucketDatasetNameCollectPostResponse200 = {
  data: unknown
  status: 200
}

export type createCollectionApiBucketBucketDatasetNameCollectPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createCollectionApiBucketBucketDatasetNameCollectPostResponseSuccess = (createCollectionApiBucketBucketDatasetNameCollectPostResponse200) & {
  headers: Headers;
};
export type createCollectionApiBucketBucketDatasetNameCollectPostResponseError = (createCollectionApiBucketBucketDatasetNameCollectPostResponse422) & {
  headers: Headers;
};

export type createCollectionApiBucketBucketDatasetNameCollectPostResponse = (createCollectionApiBucketBucketDatasetNameCollectPostResponseSuccess | createCollectionApiBucketBucketDatasetNameCollectPostResponseError)

export const getCreateCollectionApiBucketBucketDatasetNameCollectPostUrl = (bucket: string,
    name: string,) => {


  

  return `/api/bucket/${bucket}/dataset/${name}/collect`
}

export const createCollectionApiBucketBucketDatasetNameCollectPost = async (bucket: string,
    name: string,
    bodyCreateCollectionApiBucketBucketDatasetNameCollectPost: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost, options?: RequestInit): Promise<createCollectionApiBucketBucketDatasetNameCollectPostResponse> => {
  
  const res = await fetch(getCreateCollectionApiBucketBucketDatasetNameCollectPostUrl(bucket,name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bodyCreateCollectionApiBucketBucketDatasetNameCollectPost,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCollectionApiBucketBucketDatasetNameCollectPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCollectionApiBucketBucketDatasetNameCollectPostResponse
}
  


/**
 * This api queries dataset.
 * @summary Query Dataset
 */
export type queryDatasetApiBucketBucketQueryGetResponse200 = {
  data: DataQueryResponse
  status: 200
}

export type queryDatasetApiBucketBucketQueryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type queryDatasetApiBucketBucketQueryGetResponseSuccess = (queryDatasetApiBucketBucketQueryGetResponse200) & {
  headers: Headers;
};
export type queryDatasetApiBucketBucketQueryGetResponseError = (queryDatasetApiBucketBucketQueryGetResponse422) & {
  headers: Headers;
};

export type queryDatasetApiBucketBucketQueryGetResponse = (queryDatasetApiBucketBucketQueryGetResponseSuccess | queryDatasetApiBucketBucketQueryGetResponseError)

export const getQueryDatasetApiBucketBucketQueryGetUrl = (bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/query?${stringifiedParams}` : `/api/bucket/${bucket}/query`
}

export const queryDatasetApiBucketBucketQueryGet = async (bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: RequestInit): Promise<queryDatasetApiBucketBucketQueryGetResponse> => {
  
  const res = await fetch(getQueryDatasetApiBucketBucketQueryGetUrl(bucket,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryDatasetApiBucketBucketQueryGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryDatasetApiBucketBucketQueryGetResponse
}
  


/**
 * @summary Get Notification Settings
 */
export type getNotificationSettingsApiProfileSettingsGetResponse200 = {
  data: ProfileResponse
  status: 200
}

export type getNotificationSettingsApiProfileSettingsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getNotificationSettingsApiProfileSettingsGetResponseSuccess = (getNotificationSettingsApiProfileSettingsGetResponse200) & {
  headers: Headers;
};
export type getNotificationSettingsApiProfileSettingsGetResponseError = (getNotificationSettingsApiProfileSettingsGetResponse422) & {
  headers: Headers;
};

export type getNotificationSettingsApiProfileSettingsGetResponse = (getNotificationSettingsApiProfileSettingsGetResponseSuccess | getNotificationSettingsApiProfileSettingsGetResponseError)

export const getGetNotificationSettingsApiProfileSettingsGetUrl = () => {


  

  return `/api/profile/settings`
}

export const getNotificationSettingsApiProfileSettingsGet = async ( options?: RequestInit): Promise<getNotificationSettingsApiProfileSettingsGetResponse> => {
  
  const res = await fetch(getGetNotificationSettingsApiProfileSettingsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getNotificationSettingsApiProfileSettingsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getNotificationSettingsApiProfileSettingsGetResponse
}
  


/**
 * @summary Set Notification Settings
 */
export type setNotificationSettingsApiProfileSettingsPostResponse200 = {
  data: unknown
  status: 200
}

export type setNotificationSettingsApiProfileSettingsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type setNotificationSettingsApiProfileSettingsPostResponseSuccess = (setNotificationSettingsApiProfileSettingsPostResponse200) & {
  headers: Headers;
};
export type setNotificationSettingsApiProfileSettingsPostResponseError = (setNotificationSettingsApiProfileSettingsPostResponse422) & {
  headers: Headers;
};

export type setNotificationSettingsApiProfileSettingsPostResponse = (setNotificationSettingsApiProfileSettingsPostResponseSuccess | setNotificationSettingsApiProfileSettingsPostResponseError)

export const getSetNotificationSettingsApiProfileSettingsPostUrl = (params?: SetNotificationSettingsApiProfileSettingsPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/profile/settings?${stringifiedParams}` : `/api/profile/settings`
}

export const setNotificationSettingsApiProfileSettingsPost = async (userProfile: UserProfile,
    params?: SetNotificationSettingsApiProfileSettingsPostParams, options?: RequestInit): Promise<setNotificationSettingsApiProfileSettingsPostResponse> => {
  
  const res = await fetch(getSetNotificationSettingsApiProfileSettingsPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userProfile,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setNotificationSettingsApiProfileSettingsPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setNotificationSettingsApiProfileSettingsPostResponse
}
  


/**
 * @summary Get Osmo Client Version
 */
export type getOsmoClientVersionClientVersionGetResponse200 = {
  data: unknown
  status: 200
}

export type getOsmoClientVersionClientVersionGetResponseSuccess = (getOsmoClientVersionClientVersionGetResponse200) & {
  headers: Headers;
};
;

export type getOsmoClientVersionClientVersionGetResponse = (getOsmoClientVersionClientVersionGetResponseSuccess)

export const getGetOsmoClientVersionClientVersionGetUrl = () => {


  

  return `/client/version`
}

export const getOsmoClientVersionClientVersionGet = async ( options?: RequestInit): Promise<getOsmoClientVersionClientVersionGetResponse> => {
  
  const res = await fetch(getGetOsmoClientVersionClientVersionGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOsmoClientVersionClientVersionGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOsmoClientVersionClientVersionGetResponse
}
  


/**
 * To be used for the readiness probe, but not liveness probe. That way, if this method is
slow, no new traffic gets routed, instead of killing the service.
 * @summary Health
 */
export type healthHealthGetResponse200 = {
  data: unknown
  status: 200
}

export type healthHealthGetResponseSuccess = (healthHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthHealthGetResponse = (healthHealthGetResponseSuccess)

export const getHealthHealthGetUrl = () => {


  

  return `/health`
}

export const healthHealthGet = async ( options?: RequestInit): Promise<healthHealthGetResponse> => {
  
  const res = await fetch(getHealthHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthHealthGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthHealthGetResponse
}
  


/**
 * @summary Get Version
 */
export type getVersionApiVersionGetResponse200 = {
  data: unknown
  status: 200
}

export type getVersionApiVersionGetResponseSuccess = (getVersionApiVersionGetResponse200) & {
  headers: Headers;
};
;

export type getVersionApiVersionGetResponse = (getVersionApiVersionGetResponseSuccess)

export const getGetVersionApiVersionGetUrl = () => {


  

  return `/api/version`
}

export const getVersionApiVersionGet = async ( options?: RequestInit): Promise<getVersionApiVersionGetResponse> => {
  
  const res = await fetch(getGetVersionApiVersionGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVersionApiVersionGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVersionApiVersionGetResponse
}
  


/**
 * Returns the values of all users who have submitted a workflow.
 * @summary Get Users
 */
export type getUsersApiUsersGetResponse200 = {
  data: string
  status: 200
}

export type getUsersApiUsersGetResponseSuccess = (getUsersApiUsersGetResponse200) & {
  headers: Headers;
};
;

export type getUsersApiUsersGetResponse = (getUsersApiUsersGetResponseSuccess)

export const getGetUsersApiUsersGetUrl = () => {


  

  return `/api/users`
}

export const getUsersApiUsersGet = async ( options?: RequestInit): Promise<getUsersApiUsersGetResponse> => {
  
  const res = await fetch(getGetUsersApiUsersGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUsersApiUsersGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUsersApiUsersGetResponse
}
  


/**
 * Returns all workflow tags.
 * @summary Get Available Workflow Tags
 */
export type getAvailableWorkflowTagsApiTagGetResponse200 = {
  data: unknown
  status: 200
}

export type getAvailableWorkflowTagsApiTagGetResponseSuccess = (getAvailableWorkflowTagsApiTagGetResponse200) & {
  headers: Headers;
};
;

export type getAvailableWorkflowTagsApiTagGetResponse = (getAvailableWorkflowTagsApiTagGetResponseSuccess)

export const getGetAvailableWorkflowTagsApiTagGetUrl = () => {


  

  return `/api/tag`
}

export const getAvailableWorkflowTagsApiTagGet = async ( options?: RequestInit): Promise<getAvailableWorkflowTagsApiTagGetResponse> => {
  
  const res = await fetch(getGetAvailableWorkflowTagsApiTagGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAvailableWorkflowTagsApiTagGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAvailableWorkflowTagsApiTagGetResponse
}
  


/**
 * Get all the workflow plugins configurations
 * @summary Get Workflow Plugins Configs
 */
export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponseSuccess = (getWorkflowPluginsConfigsApiPluginsConfigsGetResponse200) & {
  headers: Headers;
};
;

export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponse = (getWorkflowPluginsConfigsApiPluginsConfigsGetResponseSuccess)

export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetUrl = () => {


  

  return `/api/plugins/configs`
}

export const getWorkflowPluginsConfigsApiPluginsConfigsGet = async ( options?: RequestInit): Promise<getWorkflowPluginsConfigsApiPluginsConfigsGetResponse> => {
  
  const res = await fetch(getGetWorkflowPluginsConfigsApiPluginsConfigsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkflowPluginsConfigsApiPluginsConfigsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkflowPluginsConfigsApiPluginsConfigsGetResponse
}


export const getReadServiceConfigsApiConfigsServiceGetResponseMock = (): string => (faker.word.sample())

export const getPutServiceConfigsApiConfigsServicePutResponseMock = (): PutServiceConfigsApiConfigsServicePut200 => ({})

export const getPatchServiceConfigsApiConfigsServicePatchResponseMock = (): PatchServiceConfigsApiConfigsServicePatch200 => ({})

export const getReadWorkflowConfigsApiConfigsWorkflowGetResponseMock = (): string => (faker.word.sample())

export const getPutWorkflowConfigsApiConfigsWorkflowPutResponseMock = (): PutWorkflowConfigsApiConfigsWorkflowPut200 => ({})

export const getPatchWorkflowConfigsApiConfigsWorkflowPatchResponseMock = (): PatchWorkflowConfigsApiConfigsWorkflowPatch200 => ({})

export const getReadDatasetConfigsApiConfigsDatasetGetResponseMock = (): string => (faker.word.sample())

export const getPutDatasetConfigsApiConfigsDatasetPutResponseMock = (): PutDatasetConfigsApiConfigsDatasetPut200 => ({})

export const getPatchDatasetConfigsApiConfigsDatasetPatchResponseMock = (): PatchDatasetConfigsApiConfigsDatasetPatch200 => ({})

export const getPatchDatasetApiConfigsDatasetNamePatchResponseMock = (): PatchDatasetApiConfigsDatasetNamePatch200 => ({})

export const getListBackendsApiConfigsBackendGetResponseMock = (): string => (faker.word.sample())

export const getGetBackendApiConfigsBackendNameGetResponseMock = (): string => (faker.word.sample())

export const getListPoolsApiConfigsPoolGetResponseMock = (): string => (faker.word.sample())

export const getReadPoolApiConfigsPoolNameGetResponseMock = (): string => (faker.word.sample())

export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetResponseMock = (): string => (faker.word.sample())

export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseMock = (): string => (faker.word.sample())

export const getListPodTemplatesApiConfigsPodTemplateGetResponseMock = (): string => (faker.word.sample())

export const getReadPodTemplateApiConfigsPodTemplateNameGetResponseMock = (): string => (faker.word.sample())

export const getListGroupTemplatesApiConfigsGroupTemplateGetResponseMock = (): string => (faker.word.sample())

export const getReadGroupTemplateApiConfigsGroupTemplateNameGetResponseMock = (): string => (faker.word.sample())

export const getListResourceValidationsApiConfigsResourceValidationGetResponseMock = (): string => (faker.word.sample())

export const getReadResourceValidationApiConfigsResourceValidationNameGetResponseMock = (): string => (faker.word.sample())

export const getListRolesApiConfigsRoleGetResponseMock = (): string => (faker.word.sample())

export const getReadRoleApiConfigsRoleNameGetResponseMock = (): string => (faker.word.sample())

export const getListBackendTestsApiConfigsBackendTestGetResponseMock = (): string => (faker.word.sample())

export const getReadBackendTestApiConfigsBackendTestNameGetResponseMock = (): string => (faker.word.sample())

export const getGetConfigsHistoryApiConfigsHistoryGetResponseMock = (overrideResponse: Partial<Extract<GetConfigsHistoryResponse, object>> = {}): GetConfigsHistoryResponse => ({configs: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({config_type: faker.helpers.arrayElement(Object.values(SrcLibUtilsConfigHistoryConfigHistoryType)), name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), revision: faker.number.int(), username: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), created_at: faker.date.past().toISOString().slice(0, 19) + 'Z', description: 'A test resource', tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), data: faker.helpers.arrayElement([{}, undefined])})), ...overrideResponse})

export const getGetConfigDiffApiConfigsDiffGetResponseMock = (): string => (faker.word.sample())

export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseMock = (overrideResponse: Partial<Extract<AccessTokenRolesResponse, object>> = {}): AccessTokenRolesResponse => ({user_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), token_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), assigned_by: faker.string.alpha({length: {min: 10, max: 20}}), assigned_at: faker.date.past().toISOString().slice(0, 19) + 'Z'})), ...overrideResponse})

export const getListAccessTokensApiAuthAccessTokenGetResponseMock = (): AccessTokenWithRoles[] => (Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({user_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), token_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), expires_at: faker.date.past().toISOString().slice(0, 19) + 'Z', description: 'A test resource', roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))})))

export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseMock = (): AccessTokenWithRoles[] => (Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({user_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), token_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), expires_at: faker.date.past().toISOString().slice(0, 19) + 'Z', description: 'A test resource', roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))})))

export const getListUsersApiAuthUserGetResponseMock = (overrideResponse: Partial<Extract<UserListResponse, object>> = {}): UserListResponse => ({total_results: faker.number.int(), start_index: faker.number.int(), items_per_page: faker.number.int(), users: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), created_at: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), created_by: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), ...overrideResponse})

export const getCreateUserApiAuthUserPostResponseMock = (overrideResponse: Partial<Extract<User, object>> = {}): User => ({id: faker.string.alpha({length: {min: 10, max: 20}}), created_at: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), created_by: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetUserApiAuthUserUserIdGetResponseMock = (overrideResponse: Partial<Extract<UserWithRoles, object>> = {}): UserWithRoles => ({id: faker.string.alpha({length: {min: 10, max: 20}}), created_at: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), created_by: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), assigned_by: faker.string.alpha({length: {min: 10, max: 20}}), assigned_at: faker.date.past().toISOString().slice(0, 19) + 'Z'})), ...overrideResponse})

export const getListUserRolesApiAuthUserUserIdRolesGetResponseMock = (overrideResponse: Partial<Extract<UserRolesResponse, object>> = {}): UserRolesResponse => ({user_id: faker.string.alpha({length: {min: 10, max: 20}}), roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), assigned_by: faker.string.alpha({length: {min: 10, max: 20}}), assigned_at: faker.date.past().toISOString().slice(0, 19) + 'Z'})), ...overrideResponse})

export const getAssignRoleToUserApiAuthUserUserIdRolesPostResponseMock = (overrideResponse: Partial<Extract<UserRoleAssignment, object>> = {}): UserRoleAssignment => ({user_id: faker.string.alpha({length: {min: 10, max: 20}}), role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), assigned_by: faker.string.alpha({length: {min: 10, max: 20}}), assigned_at: faker.date.past().toISOString().slice(0, 19) + 'Z', ...overrideResponse})

export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetResponseMock = (overrideResponse: Partial<Extract<RoleUsersResponse, object>> = {}): RoleUsersResponse => ({role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), users: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({})), ...overrideResponse})

export const getBulkAssignRoleApiAuthRolesRoleNameUsersPostResponseMock = (overrideResponse: Partial<Extract<BulkAssignResponse, object>> = {}): BulkAssignResponse => ({role_name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), assigned: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), already_assigned: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), failed: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), ...overrideResponse})

export const getListAppsApiAppGetResponseMock = (): string => (faker.word.sample())

export const getGetAppApiAppUserNameGetResponseMock = (): string => (faker.word.sample())

export const getDeleteAppApiAppUserNameDeleteResponseMock = (): DeleteAppApiAppUserNameDelete200 => ({
        [faker.string.alphanumeric(5)]: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.number.int()))
      })

export const getUpdateAppApiAppUserNamePatchResponseMock = (overrideResponse: Partial<Extract<EditResponse, object>> = {}): EditResponse => ({uuid: faker.string.alpha({length: {min: 10, max: 20}}), version: faker.number.int(), name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), created_by: faker.string.alpha({length: {min: 10, max: 20}}), created_date: faker.date.past().toISOString().slice(0, 19) + 'Z', ...overrideResponse})

export const getGetAppContentApiAppUserNameSpecGetResponseMock = (): string => (faker.word.sample())

export const getRenameAppApiAppUserNameRenamePostResponseMock = (): string => (faker.word.sample())

export const getCancelWorkflowApiWorkflowNameCancelPostResponseMock = (overrideResponse: Partial<Extract<CancelResponse, object>> = {}): CancelResponse => ({name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), ...overrideResponse})

export const getListWorkflowApiWorkflowGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseMock = (): string => (faker.word.sample())

export const getListTaskApiTaskGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowApiWorkflowNameGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowLogsApiWorkflowNameLogsGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowSpecApiWorkflowNameSpecGetResponseMock = (): string => (faker.word.sample())

export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseMock = (): ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200 => ({
        [faker.string.alphanumeric(5)]: {router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}})}
      })

export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseMock = (overrideResponse: Partial<Extract<RouterResponse, object>> = {}): RouterResponse => ({router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseMock = (): RouterResponse[] | RouterResponse => (faker.helpers.arrayElement([Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}})})),{router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}})},]))

export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseMock = (overrideResponse: Partial<Extract<RouterResponse, object>> = {}): RouterResponse => ({router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseMock = (overrideResponse: Partial<Extract<RouterResponse, object>> = {}): RouterResponse => ({router_address: faker.string.alpha({length: {min: 10, max: 20}}), key: faker.string.alpha({length: {min: 10, max: 20}}), cookie: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetUserCredentialApiCredentialsGetResponseMock = (): string => (faker.word.sample())

export const getDeleteUsersCredentialApiCredentialsCredNameDeleteResponseMock = (overrideResponse: Partial<Extract<CredentialGetResponse, object>> = {}): CredentialGetResponse => ({credentials: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({
        [faker.string.alphanumeric(5)]: faker.string.alpha({length: {min: 10, max: 20}})
      })), ...overrideResponse})

export const getGetResourcesApiResourcesGetResponseMock = (): string => (faker.word.sample())

export const getGetOneResourceApiResourcesNameGetResponseMock = (): string => (faker.word.sample())

export const getGetPoolsApiPoolGetResponseMock = (): string => (faker.word.sample())

export const getGetPoolQuotasApiPoolQuotaGetResponseMock = (): string => (faker.word.sample())

export const getSubmitWorkflowApiPoolPoolNameWorkflowPostResponseMock = (overrideResponse: Partial<Extract<SubmitResponse, object>> = {}): SubmitResponse => ({name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), overview: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), logs: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), spec: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), dashboard_url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseMock = (overrideResponse: Partial<Extract<SubmitResponse, object>> = {}): SubmitResponse => ({name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), overview: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), logs: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), spec: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), dashboard_url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetBucketInfoApiBucketGetResponseMock = (overrideResponse: Partial<Extract<BucketInfoResponse, object>> = {}): BucketInfoResponse => ({default: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), buckets: {
        [faker.string.alphanumeric(5)]: {path: faker.string.alpha({length: {min: 10, max: 20}}), description: 'A test resource', mode: faker.string.alpha({length: {min: 10, max: 20}}), default_cred: faker.datatype.boolean()}
      }, ...overrideResponse})

export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseMock = (overrideResponse: Partial<Extract<DataAttributeResponse, object>> = {}): DataAttributeResponse => ({tag_response: faker.helpers.arrayElement([{version_id: faker.string.alpha({length: {min: 10, max: 20}}), tags: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))}, undefined]), label_response: faker.helpers.arrayElement([{metadata: {}}, undefined]), metadata_response: faker.helpers.arrayElement([{metadata: {}}, undefined]), ...overrideResponse})

export const getGetInfoApiBucketBucketDatasetNameInfoGetResponseMock = (overrideResponse: Partial<Extract<DataInfoResponse, object>> = {}): DataInfoResponse => ({name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), id: faker.string.alpha({length: {min: 10, max: 20}}), bucket: faker.string.alpha({length: {min: 10, max: 20}}), created_by: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_date: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), hash_location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), hash_location_size: faker.helpers.arrayElement([faker.number.int(), undefined]), labels: {}, type: faker.helpers.arrayElement(Object.values(DatasetType)), versions: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.helpers.arrayElement([{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), version: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(DatasetStatus)), created_by: faker.string.alpha({length: {min: 10, max: 20}}), created_date: faker.date.past().toISOString().slice(0, 19) + 'Z', last_used: faker.date.past().toISOString().slice(0, 19) + 'Z', size: faker.number.int(), checksum: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), uri: faker.string.alpha({length: {min: 10, max: 20}}), metadata: {}, tags: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), collections: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))},{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), version: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), uri: faker.string.alpha({length: {min: 10, max: 20}}), hash_location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), size: faker.number.int()},]))), ...overrideResponse})

export const getListDatasetFromBucketApiBucketListDatasetGetResponseMock = (overrideResponse: Partial<Extract<DataListResponse, object>> = {}): DataListResponse => ({datasets: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => ({name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), id: faker.string.alpha({length: {min: 10, max: 20}}), bucket: faker.string.alpha({length: {min: 10, max: 20}}), create_time: faker.date.past().toISOString().slice(0, 19) + 'Z', last_created: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), hash_location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), hash_location_size: faker.helpers.arrayElement([faker.number.int(), undefined]), version_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement(Object.values(DatasetType))})), ...overrideResponse})

export const getQueryDatasetApiBucketBucketQueryGetResponseMock = (overrideResponse: Partial<Extract<DataQueryResponse, object>> = {}): DataQueryResponse => ({type: faker.helpers.arrayElement(Object.values(DatasetQueryType)), datasets: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.helpers.arrayElement([{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), id: faker.string.alpha({length: {min: 10, max: 20}}), bucket: faker.string.alpha({length: {min: 10, max: 20}}), created_by: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_date: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), hash_location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), hash_location_size: faker.helpers.arrayElement([faker.number.int(), undefined]), labels: {}, type: faker.helpers.arrayElement(Object.values(DatasetType)), versions: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.helpers.arrayElement([{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), version: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(DatasetStatus)), created_by: faker.string.alpha({length: {min: 10, max: 20}}), created_date: faker.date.past().toISOString().slice(0, 19) + 'Z', last_used: faker.date.past().toISOString().slice(0, 19) + 'Z', size: faker.number.int(), checksum: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), uri: faker.string.alpha({length: {min: 10, max: 20}}), metadata: {}, tags: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), collections: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))},{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), version: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), uri: faker.string.alpha({length: {min: 10, max: 20}}), hash_location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), size: faker.number.int()},])))},{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), version: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(DatasetStatus)), created_by: faker.string.alpha({length: {min: 10, max: 20}}), created_date: faker.date.past().toISOString().slice(0, 19) + 'Z', last_used: faker.date.past().toISOString().slice(0, 19) + 'Z', size: faker.number.int(), checksum: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), uri: faker.string.alpha({length: {min: 10, max: 20}}), metadata: {}, tags: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), collections: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}})))},]))), ...overrideResponse})

export const getGetNotificationSettingsApiProfileSettingsGetResponseMock = (overrideResponse: Partial<Extract<ProfileResponse, object>> = {}): ProfileResponse => ({profile: {username: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), email_notification: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), slack_notification: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), bucket: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), pool: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, roles: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), pools: Array.from({ length: faker.number.int({min: 1, max: 10}) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), token: faker.helpers.arrayElement([{name: (() => `pool-${Math.random().toString(36).slice(2, 7)}`)(), expires_at: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, undefined]), ...overrideResponse})

export const getGetUsersApiUsersGetResponseMock = (): string => (faker.word.sample())

export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetResponseMock = (): string => (faker.word.sample())


export const getReadServiceConfigsApiConfigsServiceGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/service', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadServiceConfigsApiConfigsServiceGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutServiceConfigsApiConfigsServicePutMockHandler = (overrideResponse?: PutServiceConfigsApiConfigsServicePut200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutServiceConfigsApiConfigsServicePut200> | PutServiceConfigsApiConfigsServicePut200), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/service', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutServiceConfigsApiConfigsServicePutResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPatchServiceConfigsApiConfigsServicePatchMockHandler = (overrideResponse?: PatchServiceConfigsApiConfigsServicePatch200 | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<PatchServiceConfigsApiConfigsServicePatch200> | PatchServiceConfigsApiConfigsServicePatch200), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/service', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPatchServiceConfigsApiConfigsServicePatchResponseMock(),
      { status: 200
      })
  }, options)
}

export const getReadWorkflowConfigsApiConfigsWorkflowGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/workflow', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadWorkflowConfigsApiConfigsWorkflowGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutWorkflowConfigsApiConfigsWorkflowPutMockHandler = (overrideResponse?: PutWorkflowConfigsApiConfigsWorkflowPut200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutWorkflowConfigsApiConfigsWorkflowPut200> | PutWorkflowConfigsApiConfigsWorkflowPut200), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/workflow', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutWorkflowConfigsApiConfigsWorkflowPutResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPatchWorkflowConfigsApiConfigsWorkflowPatchMockHandler = (overrideResponse?: PatchWorkflowConfigsApiConfigsWorkflowPatch200 | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<PatchWorkflowConfigsApiConfigsWorkflowPatch200> | PatchWorkflowConfigsApiConfigsWorkflowPatch200), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/workflow', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPatchWorkflowConfigsApiConfigsWorkflowPatchResponseMock(),
      { status: 200
      })
  }, options)
}

export const getReadDatasetConfigsApiConfigsDatasetGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/dataset', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadDatasetConfigsApiConfigsDatasetGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutDatasetConfigsApiConfigsDatasetPutMockHandler = (overrideResponse?: PutDatasetConfigsApiConfigsDatasetPut200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutDatasetConfigsApiConfigsDatasetPut200> | PutDatasetConfigsApiConfigsDatasetPut200), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/dataset', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutDatasetConfigsApiConfigsDatasetPutResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPatchDatasetConfigsApiConfigsDatasetPatchMockHandler = (overrideResponse?: PatchDatasetConfigsApiConfigsDatasetPatch200 | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<PatchDatasetConfigsApiConfigsDatasetPatch200> | PatchDatasetConfigsApiConfigsDatasetPatch200), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/dataset', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPatchDatasetConfigsApiConfigsDatasetPatchResponseMock(),
      { status: 200
      })
  }, options)
}

export const getDeleteDatasetApiConfigsDatasetNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/dataset/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getPatchDatasetApiConfigsDatasetNamePatchMockHandler = (overrideResponse?: PatchDatasetApiConfigsDatasetNamePatch200 | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<PatchDatasetApiConfigsDatasetNamePatch200> | PatchDatasetApiConfigsDatasetNamePatch200), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/dataset/:name', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPatchDatasetApiConfigsDatasetNamePatchResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListBackendsApiConfigsBackendGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/backend', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListBackendsApiConfigsBackendGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetBackendApiConfigsBackendNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/backend/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetBackendApiConfigsBackendNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getUpdateBackendApiConfigsBackendNamePostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/configs/backend/:name', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteBackendApiConfigsBackendNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/backend/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListPoolsApiConfigsPoolGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pool', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListPoolsApiConfigsPoolGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutPoolsApiConfigsPoolPutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pool', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadPoolApiConfigsPoolNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pool/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadPoolApiConfigsPoolNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutPoolApiConfigsPoolNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pool/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeletePoolApiConfigsPoolNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/pool/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getPatchPoolApiConfigsPoolNamePatchMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/pool/:name', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getRenamePoolApiConfigsPoolNameRenamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pool/:name/rename', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pool/:name/platform', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListPlatformsInPoolApiConfigsPoolNamePlatformGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pool/:name/platform/:platformName', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pool/:name/platform/:platformName', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pool/:name/platform/:platformName/rename', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListPodTemplatesApiConfigsPodTemplateGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pod_template', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListPodTemplatesApiConfigsPodTemplateGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutPodTemplatesApiConfigsPodTemplatePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pod_template', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadPodTemplateApiConfigsPodTemplateNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/pod_template/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadPodTemplateApiConfigsPodTemplateNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutPodTemplateApiConfigsPodTemplateNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/pod_template/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeletePodTemplateApiConfigsPodTemplateNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/pod_template/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListGroupTemplatesApiConfigsGroupTemplateGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/group_template', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListGroupTemplatesApiConfigsGroupTemplateGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutGroupTemplatesApiConfigsGroupTemplatePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/group_template', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadGroupTemplateApiConfigsGroupTemplateNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/group_template/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadGroupTemplateApiConfigsGroupTemplateNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutGroupTemplateApiConfigsGroupTemplateNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/group_template/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/group_template/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListResourceValidationsApiConfigsResourceValidationGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/resource_validation', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListResourceValidationsApiConfigsResourceValidationGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutResourceValidationsApiConfigsResourceValidationPutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/resource_validation', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadResourceValidationApiConfigsResourceValidationNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/resource_validation/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadResourceValidationApiConfigsResourceValidationNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutResourceValidationApiConfigsResourceValidationNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/resource_validation/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/resource_validation/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListRolesApiConfigsRoleGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/role', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListRolesApiConfigsRoleGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutRolesApiConfigsRolePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/role', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadRoleApiConfigsRoleNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/role/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadRoleApiConfigsRoleNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutRoleApiConfigsRoleNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/role/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteRoleApiConfigsRoleNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/role/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListBackendTestsApiConfigsBackendTestGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/backend_test', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListBackendTestsApiConfigsBackendTestGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutBackendTestsApiConfigsBackendTestPutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/backend_test', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getReadBackendTestApiConfigsBackendTestNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/backend_test/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadBackendTestApiConfigsBackendTestNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPutBackendTestApiConfigsBackendTestNamePutMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.put('*/api/configs/backend_test/:name', async (info: Parameters<Parameters<typeof http.put>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteBackendTestApiConfigsBackendTestNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/backend_test/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getPatchBackendTestApiConfigsBackendTestNamePatchMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.patch('*/api/configs/backend_test/:name', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetConfigsHistoryApiConfigsHistoryGetMockHandler = (overrideResponse?: GetConfigsHistoryResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetConfigsHistoryResponse> | GetConfigsHistoryResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/history', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetConfigsHistoryApiConfigsHistoryGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getRollbackConfigApiConfigsHistoryRollbackPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/configs/history/rollback', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/configs/history/:configType/revision/:revision', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/configs/history/:configType/revision/:revision/tags', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetConfigDiffApiConfigsDiffGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/configs/diff', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetConfigDiffApiConfigsDiffGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/jwt/refresh_token', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/jwt/access_token', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getCreateAccessTokenApiAuthAccessTokenTokenNamePostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/auth/access_token/:tokenName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/auth/access_token/:tokenName', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetMockHandler = (overrideResponse?: AccessTokenRolesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AccessTokenRolesResponse> | AccessTokenRolesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/access_token/:tokenName/roles', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListAccessTokensApiAuthAccessTokenGetMockHandler = (overrideResponse?: AccessTokenWithRoles[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AccessTokenWithRoles[]> | AccessTokenWithRoles[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/access_token', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListAccessTokensApiAuthAccessTokenGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/auth/user/:userId/access_token/:tokenName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/auth/user/:userId/access_token/:tokenName', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetMockHandler = (overrideResponse?: AccessTokenWithRoles[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AccessTokenWithRoles[]> | AccessTokenWithRoles[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/user/:userId/access_token', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListUsersApiAuthUserGetMockHandler = (overrideResponse?: UserListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserListResponse> | UserListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/user', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUsersApiAuthUserGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getCreateUserApiAuthUserPostMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.post('*/api/auth/user', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateUserApiAuthUserPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetUserApiAuthUserUserIdGetMockHandler = (overrideResponse?: UserWithRoles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserWithRoles> | UserWithRoles), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/user/:userId', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserApiAuthUserUserIdGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getDeleteUserApiAuthUserUserIdDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/auth/user/:userId', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListUserRolesApiAuthUserUserIdRolesGetMockHandler = (overrideResponse?: UserRolesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserRolesResponse> | UserRolesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/user/:userId/roles', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUserRolesApiAuthUserUserIdRolesGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getAssignRoleToUserApiAuthUserUserIdRolesPostMockHandler = (overrideResponse?: UserRoleAssignment | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserRoleAssignment> | UserRoleAssignment), options?: RequestHandlerOptions) => {
  return http.post('*/api/auth/user/:userId/roles', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAssignRoleToUserApiAuthUserUserIdRolesPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/auth/user/:userId/roles/:roleName', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetMockHandler = (overrideResponse?: RoleUsersResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<RoleUsersResponse> | RoleUsersResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/auth/roles/:roleName/users', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUsersWithRoleApiAuthRolesRoleNameUsersGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getBulkAssignRoleApiAuthRolesRoleNameUsersPostMockHandler = (overrideResponse?: BulkAssignResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<BulkAssignResponse> | BulkAssignResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/auth/roles/:roleName/users', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getBulkAssignRoleApiAuthRolesRoleNameUsersPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListAppsApiAppGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/app', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListAppsApiAppGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetAppApiAppUserNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/app/user/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetAppApiAppUserNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getCreateAppApiAppUserNamePostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/app/user/:name', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteAppApiAppUserNameDeleteMockHandler = (overrideResponse?: DeleteAppApiAppUserNameDelete200 | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteAppApiAppUserNameDelete200> | DeleteAppApiAppUserNameDelete200), options?: RequestHandlerOptions) => {
  return http.delete('*/api/app/user/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteAppApiAppUserNameDeleteResponseMock(),
      { status: 200
      })
  }, options)
}

export const getUpdateAppApiAppUserNamePatchMockHandler = (overrideResponse?: EditResponse | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<EditResponse> | EditResponse), options?: RequestHandlerOptions) => {
  return http.patch('*/api/app/user/:name', async (info: Parameters<Parameters<typeof http.patch>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateAppApiAppUserNamePatchResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetAppContentApiAppUserNameSpecGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/app/user/:name/spec', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetAppContentApiAppUserNameSpecGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getRenameAppApiAppUserNameRenamePostMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.post('*/api/app/user/:name/rename', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRenameAppApiAppUserNameRenamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getCancelWorkflowApiWorkflowNameCancelPostMockHandler = (overrideResponse?: CancelResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CancelResponse> | CancelResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/cancel', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCancelWorkflowApiWorkflowNameCancelPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListWorkflowApiWorkflowGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListWorkflowApiWorkflowGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name/task/:taskName', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListTaskApiTaskGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/task', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListTaskApiTaskGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetWorkflowApiWorkflowNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowApiWorkflowNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetWorkflowLogsApiWorkflowNameLogsGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name/logs', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  const resolvedBody = overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowLogsApiWorkflowNameLogsGetResponseMock();
    const textBody = typeof resolvedBody === 'string' ? resolvedBody : JSON.stringify(resolvedBody ?? null);
    return HttpResponse.text(textBody,
      { status: 200
      })
  }, options)
}

export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name/events', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  const resolvedBody = overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowPodConditionsApiWorkflowNameEventsGetResponseMock();
    const textBody = typeof resolvedBody === 'string' ? resolvedBody : JSON.stringify(resolvedBody ?? null);
    return HttpResponse.text(textBody,
      { status: 200
      })
  }, options)
}

export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name/error_logs', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  const resolvedBody = overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseMock();
    const textBody = typeof resolvedBody === 'string' ? resolvedBody : JSON.stringify(resolvedBody ?? null);
    return HttpResponse.text(textBody,
      { status: 200
      })
  }, options)
}

export const getGetWorkflowSpecApiWorkflowNameSpecGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/workflow/:name/spec', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  const resolvedBody = overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowSpecApiWorkflowNameSpecGetResponseMock();
    const textBody = typeof resolvedBody === 'string' ? resolvedBody : JSON.stringify(resolvedBody ?? null);
    return HttpResponse.text(textBody,
      { status: 200
      })
  }, options)
}

export const getTagWorkflowApiWorkflowNameTagPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/tag', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMockHandler = (overrideResponse?: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200> | ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/exec/group/:groupName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMockHandler = (overrideResponse?: RouterResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RouterResponse> | RouterResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/exec/task/:taskName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMockHandler = (overrideResponse?: RouterResponse[] | RouterResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RouterResponse[] | RouterResponse> | RouterResponse[] | RouterResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/portforward/:taskName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMockHandler = (overrideResponse?: RouterResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RouterResponse> | RouterResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/webserver/:taskName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMockHandler = (overrideResponse?: RouterResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RouterResponse> | RouterResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/workflow/:name/rsync/task/:taskName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetUserCredentialApiCredentialsGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/credentials', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserCredentialApiCredentialsGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getSetUserCredentialApiCredentialsCredNamePostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/credentials/:credName', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getDeleteUsersCredentialApiCredentialsCredNameDeleteMockHandler = (overrideResponse?: CredentialGetResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<CredentialGetResponse> | CredentialGetResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/api/credentials/:credName', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteUsersCredentialApiCredentialsCredNameDeleteResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetResourcesApiResourcesGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/resources', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetResourcesApiResourcesGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetOneResourceApiResourcesNameGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/resources/:name', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOneResourceApiResourcesNameGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetPoolsApiPoolGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/pool', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetPoolsApiPoolGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetPoolQuotasApiPoolQuotaGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/pool_quota', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetPoolQuotasApiPoolQuotaGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getSubmitWorkflowApiPoolPoolNameWorkflowPostMockHandler = (overrideResponse?: SubmitResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SubmitResponse> | SubmitResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/pool/:poolName/workflow', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSubmitWorkflowApiPoolPoolNameWorkflowPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMockHandler = (overrideResponse?: SubmitResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SubmitResponse> | SubmitResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/pool/:poolName/workflow/:workflowId/restart', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetBucketInfoApiBucketGetMockHandler = (overrideResponse?: BucketInfoResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<BucketInfoResponse> | BucketInfoResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/bucket', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetBucketInfoApiBucketGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getDeleteDatasetApiBucketBucketDatasetNameDeleteMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.delete('*/api/bucket/:bucket/dataset/:name', async (info: Parameters<Parameters<typeof http.delete>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMockHandler = (overrideResponse?: DataAttributeResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<DataAttributeResponse> | DataAttributeResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/bucket/:bucket/dataset/:name/attribute', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetInfoApiBucketBucketDatasetNameInfoGetMockHandler = (overrideResponse?: DataInfoResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DataInfoResponse> | DataInfoResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/bucket/:bucket/dataset/:name/info', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetInfoApiBucketBucketDatasetNameInfoGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getListDatasetFromBucketApiBucketListDatasetGetMockHandler = (overrideResponse?: DataListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DataListResponse> | DataListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/bucket/list_dataset', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListDatasetFromBucketApiBucketListDatasetGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getCreateCollectionApiBucketBucketDatasetNameCollectPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/bucket/:bucket/dataset/:name/collect', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getQueryDatasetApiBucketBucketQueryGetMockHandler = (overrideResponse?: DataQueryResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DataQueryResponse> | DataQueryResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/bucket/:bucket/query', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQueryDatasetApiBucketBucketQueryGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetNotificationSettingsApiProfileSettingsGetMockHandler = (overrideResponse?: ProfileResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ProfileResponse> | ProfileResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/profile/settings', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetNotificationSettingsApiProfileSettingsGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getSetNotificationSettingsApiProfileSettingsPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/profile/settings', async (info: Parameters<Parameters<typeof http.post>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetOsmoClientVersionClientVersionGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/client/version', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getHealthHealthGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/health', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetVersionApiVersionGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/version', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetUsersApiUsersGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/users', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUsersApiUsersGetResponseMock(),
      { status: 200
      })
  }, options)
}

export const getGetAvailableWorkflowTagsApiTagGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/api/tag', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
  
    return new HttpResponse(null,
      { status: 200
      })
  }, options)
}

export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/api/plugins/configs', async (info: Parameters<Parameters<typeof http.get>[1]>[0]) => {await delay(0);
  
  
    return HttpResponse.json(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetWorkflowPluginsConfigsApiPluginsConfigsGetResponseMock(),
      { status: 200
      })
  }, options)
}
export const getFastAPIMock = () => [
  getReadServiceConfigsApiConfigsServiceGetMockHandler(),
  getPutServiceConfigsApiConfigsServicePutMockHandler(),
  getPatchServiceConfigsApiConfigsServicePatchMockHandler(),
  getReadWorkflowConfigsApiConfigsWorkflowGetMockHandler(),
  getPutWorkflowConfigsApiConfigsWorkflowPutMockHandler(),
  getPatchWorkflowConfigsApiConfigsWorkflowPatchMockHandler(),
  getReadDatasetConfigsApiConfigsDatasetGetMockHandler(),
  getPutDatasetConfigsApiConfigsDatasetPutMockHandler(),
  getPatchDatasetConfigsApiConfigsDatasetPatchMockHandler(),
  getDeleteDatasetApiConfigsDatasetNameDeleteMockHandler(),
  getPatchDatasetApiConfigsDatasetNamePatchMockHandler(),
  getListBackendsApiConfigsBackendGetMockHandler(),
  getGetBackendApiConfigsBackendNameGetMockHandler(),
  getUpdateBackendApiConfigsBackendNamePostMockHandler(),
  getDeleteBackendApiConfigsBackendNameDeleteMockHandler(),
  getListPoolsApiConfigsPoolGetMockHandler(),
  getPutPoolsApiConfigsPoolPutMockHandler(),
  getReadPoolApiConfigsPoolNameGetMockHandler(),
  getPutPoolApiConfigsPoolNamePutMockHandler(),
  getDeletePoolApiConfigsPoolNameDeleteMockHandler(),
  getPatchPoolApiConfigsPoolNamePatchMockHandler(),
  getRenamePoolApiConfigsPoolNameRenamePutMockHandler(),
  getListPlatformsInPoolApiConfigsPoolNamePlatformGetMockHandler(),
  getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetMockHandler(),
  getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMockHandler(),
  getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMockHandler(),
  getListPodTemplatesApiConfigsPodTemplateGetMockHandler(),
  getPutPodTemplatesApiConfigsPodTemplatePutMockHandler(),
  getReadPodTemplateApiConfigsPodTemplateNameGetMockHandler(),
  getPutPodTemplateApiConfigsPodTemplateNamePutMockHandler(),
  getDeletePodTemplateApiConfigsPodTemplateNameDeleteMockHandler(),
  getListGroupTemplatesApiConfigsGroupTemplateGetMockHandler(),
  getPutGroupTemplatesApiConfigsGroupTemplatePutMockHandler(),
  getReadGroupTemplateApiConfigsGroupTemplateNameGetMockHandler(),
  getPutGroupTemplateApiConfigsGroupTemplateNamePutMockHandler(),
  getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMockHandler(),
  getListResourceValidationsApiConfigsResourceValidationGetMockHandler(),
  getPutResourceValidationsApiConfigsResourceValidationPutMockHandler(),
  getReadResourceValidationApiConfigsResourceValidationNameGetMockHandler(),
  getPutResourceValidationApiConfigsResourceValidationNamePutMockHandler(),
  getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMockHandler(),
  getListRolesApiConfigsRoleGetMockHandler(),
  getPutRolesApiConfigsRolePutMockHandler(),
  getReadRoleApiConfigsRoleNameGetMockHandler(),
  getPutRoleApiConfigsRoleNamePutMockHandler(),
  getDeleteRoleApiConfigsRoleNameDeleteMockHandler(),
  getListBackendTestsApiConfigsBackendTestGetMockHandler(),
  getPutBackendTestsApiConfigsBackendTestPutMockHandler(),
  getReadBackendTestApiConfigsBackendTestNameGetMockHandler(),
  getPutBackendTestApiConfigsBackendTestNamePutMockHandler(),
  getDeleteBackendTestApiConfigsBackendTestNameDeleteMockHandler(),
  getPatchBackendTestApiConfigsBackendTestNamePatchMockHandler(),
  getGetConfigsHistoryApiConfigsHistoryGetMockHandler(),
  getRollbackConfigApiConfigsHistoryRollbackPostMockHandler(),
  getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMockHandler(),
  getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMockHandler(),
  getGetConfigDiffApiConfigsDiffGetMockHandler(),
  getGetNewJwtTokenApiAuthJwtRefreshTokenGetMockHandler(),
  getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetMockHandler(),
  getCreateAccessTokenApiAuthAccessTokenTokenNamePostMockHandler(),
  getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMockHandler(),
  getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetMockHandler(),
  getListAccessTokensApiAuthAccessTokenGetMockHandler(),
  getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMockHandler(),
  getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMockHandler(),
  getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetMockHandler(),
  getListUsersApiAuthUserGetMockHandler(),
  getCreateUserApiAuthUserPostMockHandler(),
  getGetUserApiAuthUserUserIdGetMockHandler(),
  getDeleteUserApiAuthUserUserIdDeleteMockHandler(),
  getListUserRolesApiAuthUserUserIdRolesGetMockHandler(),
  getAssignRoleToUserApiAuthUserUserIdRolesPostMockHandler(),
  getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMockHandler(),
  getListUsersWithRoleApiAuthRolesRoleNameUsersGetMockHandler(),
  getBulkAssignRoleApiAuthRolesRoleNameUsersPostMockHandler(),
  getListAppsApiAppGetMockHandler(),
  getGetAppApiAppUserNameGetMockHandler(),
  getCreateAppApiAppUserNamePostMockHandler(),
  getDeleteAppApiAppUserNameDeleteMockHandler(),
  getUpdateAppApiAppUserNamePatchMockHandler(),
  getGetAppContentApiAppUserNameSpecGetMockHandler(),
  getRenameAppApiAppUserNameRenamePostMockHandler(),
  getCancelWorkflowApiWorkflowNameCancelPostMockHandler(),
  getListWorkflowApiWorkflowGetMockHandler(),
  getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetMockHandler(),
  getListTaskApiTaskGetMockHandler(),
  getGetWorkflowApiWorkflowNameGetMockHandler(),
  getGetWorkflowLogsApiWorkflowNameLogsGetMockHandler(),
  getGetWorkflowPodConditionsApiWorkflowNameEventsGetMockHandler(),
  getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetMockHandler(),
  getGetWorkflowSpecApiWorkflowNameSpecGetMockHandler(),
  getTagWorkflowApiWorkflowNameTagPostMockHandler(),
  getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMockHandler(),
  getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMockHandler(),
  getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMockHandler(),
  getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMockHandler(),
  getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMockHandler(),
  getGetUserCredentialApiCredentialsGetMockHandler(),
  getSetUserCredentialApiCredentialsCredNamePostMockHandler(),
  getDeleteUsersCredentialApiCredentialsCredNameDeleteMockHandler(),
  getGetResourcesApiResourcesGetMockHandler(),
  getGetOneResourceApiResourcesNameGetMockHandler(),
  getGetPoolsApiPoolGetMockHandler(),
  getGetPoolQuotasApiPoolQuotaGetMockHandler(),
  getSubmitWorkflowApiPoolPoolNameWorkflowPostMockHandler(),
  getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMockHandler(),
  getGetBucketInfoApiBucketGetMockHandler(),
  getDeleteDatasetApiBucketBucketDatasetNameDeleteMockHandler(),
  getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMockHandler(),
  getGetInfoApiBucketBucketDatasetNameInfoGetMockHandler(),
  getListDatasetFromBucketApiBucketListDatasetGetMockHandler(),
  getCreateCollectionApiBucketBucketDatasetNameCollectPostMockHandler(),
  getQueryDatasetApiBucketBucketQueryGetMockHandler(),
  getGetNotificationSettingsApiProfileSettingsGetMockHandler(),
  getSetNotificationSettingsApiProfileSettingsPostMockHandler(),
  getGetOsmoClientVersionClientVersionGetMockHandler(),
  getHealthHealthGetMockHandler(),
  getGetVersionApiVersionGetMockHandler(),
  getGetUsersApiUsersGetMockHandler(),
  getGetAvailableWorkflowTagsApiTagGetMockHandler(),
  getGetWorkflowPluginsConfigsApiPluginsConfigsGetMockHandler()
]
