/**
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Generate THIRD_PARTY_LICENSES.md from `pnpm licenses list --json`.
 * Run via: pnpm licenses:generate
 */

import { execSync } from "node:child_process";
import { writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");
const OUTPUT = join(ROOT, "THIRD_PARTY_LICENSES.md");

// License groups in preferred display order.
const LICENSE_ORDER = [
  "MIT",
  "Apache-2.0",
  "ISC",
  "BSD-2-Clause",
  "BSD-3-Clause",
  "0BSD",
  "CC0-1.0",
  "CC-BY-4.0",
  "BlueOak-1.0.0",
  "Python-2.0",
  "Unlicense",
  "LGPL-2.1",
  "LGPL-3.0",
  "LGPL-3.0-or-later",
  "MPL-2.0",
  "EPL-2.0",
];

function getLicenseData() {
  const raw = execSync("pnpm licenses list --json --long --prod", {
    cwd: ROOT,
    maxBuffer: 20 * 1024 * 1024,
    stdio: ["pipe", "pipe", "pipe"],
  }).toString();
  return JSON.parse(raw);
}

function sortLicenses(licenses) {
  return [...licenses].sort((a, b) => {
    const ai = LICENSE_ORDER.indexOf(a);
    const bi = LICENSE_ORDER.indexOf(b);
    if (ai !== -1 && bi !== -1) return ai - bi;
    if (ai !== -1) return -1;
    if (bi !== -1) return 1;
    return a.localeCompare(b);
  });
}

function generateMarkdown(licenseData) {
  const date = new Date().toISOString().split("T")[0];
  const totalPackages = Object.values(licenseData).reduce(
    (sum, pkgs) => sum + pkgs.length,
    0,
  );

  const lines = [
    "# Third-Party License Inventory",
    "",
    `Generated: ${date} · Packages audited: **${totalPackages}** · Scope: production (server image)`,
    "",
    "> Auto-generated by `pnpm licenses:generate`. Do not edit manually.",
    "",
    "## Contents",
    "",
  ];

  // Build TOC
  const sortedLicenses = sortLicenses(Object.keys(licenseData));
  for (const license of sortedLicenses) {
    const count = licenseData[license].length;
    const anchor = license.toLowerCase().replace(/[^a-z0-9]/g, "-");
    lines.push(`- [${license} (${count} packages)](#${anchor}-${count}-packages)`);
  }
  lines.push("");

  // Build sections
  for (const license of sortedLicenses) {
    const packages = [...licenseData[license]].sort((a, b) =>
      a.name.localeCompare(b.name),
    );

    lines.push(`## ${license} (${packages.length} packages)`);
    lines.push("");
    lines.push("| Package | Version | Homepage |");
    lines.push("|---------|---------|----------|");

    for (const pkg of packages) {
      const version = Array.isArray(pkg.versions)
        ? pkg.versions.join(", ")
        : (pkg.version ?? "—");
      const homepage = pkg.homepage ? `[link](${pkg.homepage})` : "—";
      lines.push(`| \`${pkg.name}\` | ${version} | ${homepage} |`);
    }

    lines.push("");
  }

  return lines.join("\n");
}

const licenseData = getLicenseData();
const markdown = generateMarkdown(licenseData);
writeFileSync(OUTPUT, markdown);

const total = Object.values(licenseData).reduce((s, p) => s + p.length, 0);
console.log(`✓ Generated THIRD_PARTY_LICENSES.md (${total} packages)`);
