/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customFetch } from './fetcher';
/**
 * Access token role assignment.
 */
export interface AccessTokenRole {
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * Response for listing access token roles.
 */
export interface AccessTokenRolesResponse {
  user_name: string;
  token_name: string;
  roles: AccessTokenRole[];
}

/**
 * Access Token with roles.
 */
export interface AccessTokenWithRoles {
  user_name: string;
  token_name: string;
  expires_at: string;
  description: string;
  roles?: string[];
}

/**
 * Request to assign a role to a user.
 */
export interface AssignRoleRequest {
  role_name: string;
}

/**
 * Store a public/private key pair 
 */
export interface AsymmetricKeyPair {
  public_key: string;
  private_key: string;
}

export type AuthenticationConfigKeys = {[key: string]: AsymmetricKeyPair};

/**
 * Store info needed to login 
 */
export interface LoginInfo {
  device_endpoint?: string;
  device_client_id?: string;
  browser_endpoint?: string;
  browser_client_id?: string;
  token_endpoint?: string;
  logout_endpoint?: string;
}

/**
 * Store info needed to generate and validate idtokens 
 */
export interface AuthenticationConfig {
  keys: AuthenticationConfigKeys;
  active_key: string;
  issuer: string;
  audience: string;
  user_roles?: string[];
  ctrl_roles?: string[];
  login_info?: LoginInfo;
  max_token_duration?: string;
}

/**
 * Defines the type of scheduler used by the backend 
 */
export type BackendSchedulerType = typeof BackendSchedulerType[keyof typeof BackendSchedulerType];


export const BackendSchedulerType = {
  kai: 'kai',
} as const;

/**
 * Settings that control the how pods are scheduled in a backend
 */
export interface BackendSchedulerSettings {
  scheduler_type?: BackendSchedulerType;
  scheduler_name?: string;
  scheduler_timeout?: number;
}

export type BackendNodeConditionsRules = {[key: string]: string};

/**
 * Settings for backend node conditions. 
 */
export interface BackendNodeConditions {
  rules?: BackendNodeConditionsRules;
  prefix?: string;
}

/**
 * Object storing backend info. 
 */
export interface Backend {
  name: string;
  description: string;
  version: string;
  k8s_uid: string;
  k8s_namespace: string;
  dashboard_url: string;
  grafana_url: string;
  tests: string[];
  scheduler_settings: BackendSchedulerSettings;
  node_conditions: BackendNodeConditions;
  last_heartbeat: string;
  created_date: string;
  router_address: string;
  online: boolean;
}

/**
 * Similar to connectors.Backend, but with optional fields.
 */
export interface BackendConfig {
  description?: string;
  k8s_uid?: string;
  dashboard_url?: string;
  grafana_url?: string;
  tests?: string[];
  scheduler_settings?: BackendSchedulerSettings;
  node_conditions?: BackendNodeConditions;
  router_address?: string;
}

/**
 * Resource type for BackendResource. 
 */
export type BackendResourceType = typeof BackendResourceType[keyof typeof BackendResourceType];


export const BackendResourceType = {
  RESERVED: 'RESERVED',
  SHARED: 'SHARED',
  UNUSED: 'UNUSED',
} as const;

export type BackendTestsParsedPodTemplate = { [key: string]: unknown };

/**
 * Represents a test config. 
 */
export interface BackendTests {
  /** @minLength 1 */
  name: string;
  description: string;
  /** @minLength 1 */
  cron_schedule: string;
  test_timeout?: string;
  /** @minItems 1 */
  node_conditions: string[];
  /** @minItems 1 */
  common_pod_template: string[];
  parsed_pod_template?: BackendTestsParsedPodTemplate;
}

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel = { [key: string]: unknown };

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata = { [key: string]: unknown };

export interface BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost {
  set_label?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel;
  set_metadata?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface DatasetStructure {
  /** @pattern ^[a-zA-Z0-9_-]+$ */
  name: string;
  /** @pattern ^([a-zA-Z0-9_-]*)$ */
  tag: string;
}

export interface BodyCreateCollectionApiBucketBucketDatasetNameCollectPost {
  datasets: DatasetStructure[];
}

/**
 * Static data credentials (i.e. credentials with access_key_id and access_key) for a data backend.
 */
export interface StaticDataCredential {
  /** The OSMO storage URI for the data service (e.g., s3://bucket) */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** HTTP endpoint URL override the storage URI (e.g., http://minio:9000) */
  override_url?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The encrypted authentication secret for a data backend */
  access_key: string;
}

/**
 * Class to store the name of the bucket and the dataset path
 */
export interface BucketConfig {
  /** @pattern (^swift://[^/,;*]+(/[^/,;*]+){2,}/*$|^s3://[^/,;*]+(/[^/,;*]+)*\/*$|^gs://[^/,;*]+(/[^/,;*]+)*\/*$|^tos://[^/,;*]+(/[^/,;*]+)+/*$|^azure://[^/,;*]+(/[^/,;*]+)+/*$) */
  dataset_path: string;
  region?: string;
  description?: string;
  mode?: string;
  default_credential?: StaticDataCredential;
}

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoEntry {
  path: string;
  description: string;
  mode: string;
  default_cred: boolean;
}

export type BucketInfoResponseBuckets = {[key: string]: BucketInfoEntry};

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoResponse {
  default?: string;
  buckets: BucketInfoResponseBuckets;
}

/**
 * Request to bulk assign a role to users.
 */
export interface BulkAssignRequest {
  user_ids: string[];
}

/**
 * Response for bulk role assignment.
 */
export interface BulkAssignResponse {
  role_name: string;
  assigned: string[];
  already_assigned: string[];
  failed: string[];
}

/**
 * Object storing workflow name. 
 */
export interface CancelResponse {
  name: string;
}

/**
 * Config for storing information regarding CLI storage. 
 */
export interface CliConfig {
  latest_version?: string;
  min_supported_version?: string;
  client_install_url?: string;
}

/**
 * Response body for config diff endpoint.
 */
export interface ConfigDiffResponse {
  first_data?: unknown;
  second_data?: unknown;
}

/**
 * Type of configs supported by config history 
 */
export type SrcLibUtilsConfigHistoryConfigHistoryType = typeof SrcLibUtilsConfigHistoryConfigHistoryType[keyof typeof SrcLibUtilsConfigHistoryConfigHistoryType];


export const SrcLibUtilsConfigHistoryConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  GROUP_TEMPLATE: 'GROUP_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

/**
 * Object storing config history.
 */
export interface ConfigHistory {
  config_type: SrcLibUtilsConfigHistoryConfigHistoryType;
  name: string;
  revision: number;
  username: string;
  created_at: string;
  description: string;
  tags?: string[];
  data?: unknown;
}

/**
 * Request body for updating configurations with history tracking metadata.
 */
export interface ConfigsRequest {
  description?: string;
  tags?: string[];
}

/**
 * Request to create a new user.
 */
export interface CreateUserRequest {
  id: string;
  roles?: string[];
}

/**
 * Stores registries/data which do not do validation 
 */
export interface CredentialConfig {
  disable_registry_validation?: string[];
  disable_data_validation?: string[];
}

export type CredentialGetResponseCredentialsItem = {[key: string]: string};

/**
 * Credential Response. 
 */
export interface CredentialGetResponse {
  credentials: CredentialGetResponseCredentialsItem[];
}

/**
 * Authentication information for a Docker registry. 
 */
export interface UserRegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth: string;
}

/**
 * Authentication information for a data service. 
 */
export interface UserDataCredential {
  /** The OSMO storage URI for the data service (e.g., s3://bucket) */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** HTTP endpoint URL override the storage URI (e.g., http://minio:9000) */
  override_url?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The authentication secret for a data backend */
  access_key: string;
}

/**
 * The credential dictionary that contains authentication information
 */
export type UserCredentialCredential = {[key: string]: string};

/**
 * Generic authentication information. 
 */
export interface UserCredential {
  /** The credential dictionary that contains authentication information */
  credential: UserCredentialCredential;
}

/**
 * Credential options 
 */
export interface CredentialOptions {
  /** Authentication information for a Docker registry */
  registry_credential?: UserRegistryCredential;
  /** Authentication information for a data service */
  data_credential?: UserDataCredential;
  /** Generic authentication information */
  generic_credential?: UserCredential;
}

/**
 * Object storing Tag Response. 
 */
export interface DataTagResponse {
  version_id: string;
  tags: string[];
}

export type DataMetadataResponseMetadata = { [key: string]: unknown };

/**
 * Object storing Label/Metadata Response. 
 */
export interface DataMetadataResponse {
  metadata: DataMetadataResponseMetadata;
}

/**
 * Object storing Tag/Label/Metadata Response. 
 */
export interface DataAttributeResponse {
  tag_response?: DataTagResponse;
  label_response?: DataMetadataResponse;
  metadata_response?: DataMetadataResponse;
}

/**
 * Type of Config to fetch or set 
 */
export type DownloadType = typeof DownloadType[keyof typeof DownloadType];


export const DownloadType = {
  download: 'download',
} as const;

/**
 * Config for storing information about data. 
 */
export interface DataConfig {
  credential?: StaticDataCredential;
  base_url?: string;
  websocket_timeout?: number;
  data_timeout?: number;
  download_type?: DownloadType;
}

/**
 * Object storing Info Element. 
 */
export interface DataInfoCollectionEntry {
  name: string;
  version: string;
  location: string;
  uri: string;
  hash_location?: string;
  size: number;
}

export type DataInfoDatasetEntryMetadata = { [key: string]: unknown };

/**
 * The status of a dataset / dataset version.
 */
export type DatasetStatus = typeof DatasetStatus[keyof typeof DatasetStatus];


export const DatasetStatus = {
  PENDING: 'PENDING',
  READY: 'READY',
  PENDING_DELETE: 'PENDING_DELETE',
  DELETED: 'DELETED',
} as const;

/**
 * Object storing Info Element. 
 */
export interface DataInfoDatasetEntry {
  name: string;
  version: string;
  status: DatasetStatus;
  created_by: string;
  created_date: string;
  last_used: string;
  size: number;
  checksum: string;
  location: string;
  uri: string;
  metadata: DataInfoDatasetEntryMetadata;
  tags: string[];
  collections: string[];
}

export type DataInfoResponseLabels = { [key: string]: unknown };

/**
 * An enumeration.
 */
export type DatasetType = typeof DatasetType[keyof typeof DatasetType];


export const DatasetType = {
  COLLECTION: 'COLLECTION',
  DATASET: 'DATASET',
} as const;

/**
 * Object storing Data Info Elements. 
 */
export interface DataInfoResponse {
  name: string;
  id: string;
  bucket: string;
  created_by?: string;
  created_date?: string;
  hash_location?: string;
  hash_location_size?: number;
  labels: DataInfoResponseLabels;
  type: DatasetType;
  versions: (DataInfoDatasetEntry | DataInfoCollectionEntry)[];
}

/**
 * Object storing Data List Element. 
 */
export interface DataListEntry {
  name: string;
  id: string;
  bucket: string;
  create_time: string;
  last_created?: string;
  hash_location?: string;
  hash_location_size?: number;
  version_id?: string;
  type: DatasetType;
}

/**
 * Object storing Data List Elements. 
 */
export interface DataListResponse {
  datasets: DataListEntry[];
}

/**
 * An enumeration.
 */
export type DatasetQueryType = typeof DatasetQueryType[keyof typeof DatasetQueryType];


export const DatasetQueryType = {
  VERSION: 'VERSION',
  DATASET: 'DATASET',
} as const;

/**
 * Object storing Dataset and Dataset Version Info. 
 */
export interface DataQueryResponse {
  type: DatasetQueryType;
  datasets: (DataInfoResponse | DataInfoDatasetEntry)[];
}

export type DatasetConfigBuckets = {[key: string]: BucketConfig};

/**
 * Stores any dataset configs External Admins control 
 */
export interface DatasetConfig {
  buckets?: DatasetConfigBuckets;
  default_bucket?: string;
}

/**
 * Request body for deleting a backend with history tracking metadata.
 */
export interface DeleteBackendRequest {
  description?: string;
  tags?: string[];
  force?: boolean;
}

export interface EditResponse {
  uuid: string;
  version: number;
  name: string;
  created_by: string;
  created_date: string;
}

/**
 * Represents the types of statuses a pool can have. 
 */
export type PoolStatus = typeof PoolStatus[keyof typeof PoolStatus];


export const PoolStatus = {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MAINTENANCE: 'MAINTENANCE',
} as const;

/**
 * Resources like GPU or CPU that have a discrete number. For guarantee and maximum, a value of -1
indicates that there is no limit.
 */
export interface PoolResourceCountable {
  guarantee?: number;
  maximum?: number;
  weight?: number;
}

/**
 * Resources allocated to the pool, for schedulers that support this feature 
 */
export interface PoolResources {
  gpu?: PoolResourceCountable;
}

/**
 * Defines a topology key for pool configuration
 */
export interface TopologyKey {
  key: string;
  label: string;
}

export type PlatformEditableDefaultVariables = { [key: string]: unknown };

/**
 * Single Platform Entry 
 */
export interface PlatformEditable {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_variables?: PlatformEditableDefaultVariables;
  resource_validations?: string[];
  override_pod_template?: string[];
}

export type PoolEditableDefaultExitActions = {[key: string]: string};

export type PoolEditableCommonDefaultVariables = { [key: string]: unknown };

export type PoolEditablePlatforms = {[key: string]: PlatformEditable};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolEditable {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolEditableDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  common_default_variables?: PoolEditableCommonDefaultVariables;
  common_resource_validations?: string[];
  common_pod_template?: string[];
  common_group_templates?: string[];
  platforms?: PoolEditablePlatforms;
}

export type EditablePoolConfigPools = {[key: string]: PoolEditable};

/**
 * Stores editable pool configs.
 */
export interface EditablePoolConfig {
  pools?: EditablePoolConfigPools;
}

/**
 * Response body for config history endpoint.
 */
export interface GetConfigsHistoryResponse {
  configs: ConfigHistory[];
}

/**
 * Represents the status of a task group 
 */
export type TaskGroupStatus = typeof TaskGroupStatus[keyof typeof TaskGroupStatus];


export const TaskGroupStatus = {
  SUBMITTING: 'SUBMITTING',
  WAITING: 'WAITING',
  PROCESSING: 'PROCESSING',
  SCHEDULING: 'SCHEDULING',
  INITIALIZING: 'INITIALIZING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  RESCHEDULED: 'RESCHEDULED',
  FAILED: 'FAILED',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_UPSTREAM: 'FAILED_UPSTREAM',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Represents the queryed group information. 
 */
export interface TaskQueryResponse {
  name: string;
  retry_id: number;
  status: TaskGroupStatus;
  failure_message?: string;
  exit_code?: number;
  logs: string;
  error_logs?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  events: string;
  start_time?: string;
  end_time?: string;
  input_download_start_time?: string;
  input_download_end_time?: string;
  output_upload_start_time?: string;
  dashboard_url?: string;
  pod_name: string;
  pod_ip?: string;
  task_uuid: string;
  node_name?: string;
  lead?: boolean;
}

/**
 * Represents the queryed task information. 
 */
export interface GroupQueryResponse {
  name: string;
  status: TaskGroupStatus;
  start_time?: string;
  end_time?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  remaining_upstream_groups?: string[];
  downstream_groups?: string[];
  failure_message?: string;
  tasks?: TaskQueryResponse[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Object storing info for all backends. 
 */
export interface ListBackendsResponse {
  backends: Backend[];
}

/**
 * Represents the list order for the database. 
 */
export type ListOrder = typeof ListOrder[keyof typeof ListOrder];


export const ListOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const;

/**
 * Entry for task list API results, aggregated by workflow. 
 */
export interface ListTaskAggregatedEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
  workflow_id: string;
}

export interface ListTaskAggregatedResponse {
  summaries: ListTaskAggregatedEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskEntry {
  user: string;
  workflow_id: string;
  workflow_uuid: string;
  task_name: string;
  retry_id: number;
  pool?: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  duration?: number;
  status: TaskGroupStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskResponse {
  tasks: ListTaskEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskSummaryEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskSummaryResponse {
  summaries: ListTaskSummaryEntry[];
}

/**
 * Config for storing information about data. 
 */
export interface LogConfig {
  credential?: StaticDataCredential;
}

/**
 * Single Platform Entry 
 */
export interface PlatformMinimal {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
}

export type PoolMinimalDefaultExitActions = {[key: string]: string};

export type PoolMinimalPlatforms = {[key: string]: PlatformMinimal};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolMinimal {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolMinimalDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  platforms?: PoolMinimalPlatforms;
}

export type MinimalPoolConfigPools = {[key: string]: PoolMinimal};

/**
 * Stores minimal pool configs.
 */
export interface MinimalPoolConfig {
  pools?: MinimalPoolConfigPools;
}

export interface SMTPConfig {
  host?: string;
  sender?: string;
  password?: string;
}

export interface NotificationConfig {
  slack_token?: string;
  smtp_settings?: SMTPConfig;
}

/**
 * An enumeration.
 */
export type OperatorType = typeof OperatorType[keyof typeof OperatorType];


export const OperatorType = {
  GT: 'GT',
  GE: 'GE',
  LT: 'LT',
  LE: 'LE',
  EQ: 'EQ',
} as const;

/**
 * Authentication information for a Docker registry. 
 */
export interface RegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth?: string;
}

/**
 * Dynamic Config for storing the image URLs for service images and the credentials needed
to pull them.
 */
export interface OsmoImageConfig {
  init?: string;
  client?: string;
  credential?: RegistryCredential;
}

export type PatchBackendTestRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a test with history tracking metadata.
 */
export interface PatchBackendTestRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchBackendTestRequestConfigsDict;
}

export type PatchConfigRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching configurations with history tracking metadata.
 */
export interface PatchConfigRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchConfigRequestConfigsDict;
}

export type PatchDatasetRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a dataset bucket configuration with history tracking metadata.
 */
export interface PatchDatasetRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchDatasetRequestConfigsDict;
}

export type PatchPoolRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a pool with history tracking metadata.
 */
export interface PatchPoolRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchPoolRequestConfigsDict;
}

export type PlatformLabels = {[key: string]: string};

export type PlatformDefaultVariables = { [key: string]: unknown };

export type PlatformParsedPodTemplate = { [key: string]: unknown };

/**
 * Single Toleration Entry 
 */
export interface Toleration {
  key: string;
  operator?: string;
  value?: string;
  effect?: string;
}

/**
 * Class for defining resource restrictions.
 */
export interface ResourceAssertion {
  operator: OperatorType;
  left_operand: string;
  right_operand: string;
  assert_message: string;
}

/**
 * Single Platform Entry 
 */
export interface Platform {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
  tolerations?: Toleration[];
  labels?: PlatformLabels;
  default_variables?: PlatformDefaultVariables;
  resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  override_pod_template?: string[];
  parsed_pod_template?: PlatformParsedPodTemplate;
}

/**
 * Stores a single allowed path for rsync 
 */
export interface RsyncAllowedPath {
  path: string;
  writable?: boolean;
}

export type RsyncConfigAllowedPaths = {[key: string]: RsyncAllowedPath};

/**
 * Stores all configs for rsync 
 */
export interface RsyncConfig {
  enabled?: boolean;
  enable_telemetry?: boolean;
  /**
   * User pod's rsync read bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  read_bandwidth_limit?: number;
  /**
   * User pod's rsync write bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  write_bandwidth_limit?: number;
  allowed_paths?: RsyncConfigAllowedPaths;
  /**
   * Daemon debounce delay for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_debounce_delay?: number;
  /**
   * Daemon poll interval for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_poll_interval?: number;
  /**
   * Daemon reconcile interval for rsync in seconds
   * @exclusiveMinimum 0
   */
  daemon_reconcile_interval?: number;
  /**
   * Client upload rate limit for rsync in bytes per second, zero means no limit
   * @minimum 0
   */
  client_upload_rate_limit?: number;
}

/**
 * Stores any plugins configs 
 */
export interface PluginsConfig {
  rsync?: RsyncConfig;
}

/**
 * Effect of a policy statement: Allow or Deny. Deny takes precedence over Allow.
 */
export type PolicyEffect = typeof PolicyEffect[keyof typeof PolicyEffect];


export const PolicyEffect = {
  Allow: 'Allow',
  Deny: 'Deny',
} as const;

export type PoolDefaultExitActions = {[key: string]: string};

export type PoolCommonDefaultVariables = { [key: string]: unknown };

export type PoolParsedPodTemplate = { [key: string]: unknown };

export type PoolParsedGroupTemplatesItem = { [key: string]: unknown };

export type PoolPlatforms = {[key: string]: Platform};

/**
 * Single Pool Entry 
 */
export interface Pool {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  common_default_variables?: PoolCommonDefaultVariables;
  common_resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  common_pod_template?: string[];
  parsed_pod_template?: PoolParsedPodTemplate;
  common_group_templates?: string[];
  parsed_group_templates?: PoolParsedGroupTemplatesItem[];
  platforms?: PoolPlatforms;
  last_heartbeat?: string;
}

/**
 * Object storing resource usage information. 
 */
export interface ResourceUsage {
  quota_used: string;
  quota_free: string;
  quota_limit: string;
  total_usage: string;
  total_capacity: string;
  total_free: string;
}

export type PoolResourceUsageDefaultExitActions = {[key: string]: string};

export type PoolResourceUsagePlatforms = {[key: string]: PlatformMinimal};

/**
 * Object storing pool information. 
 */
export interface PoolResourceUsage {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolResourceUsageDefaultExitActions;
  resources?: PoolResources;
  topology_keys?: TopologyKey[];
  platforms?: PoolResourceUsagePlatforms;
  resource_usage: ResourceUsage;
}

/**
 * Object storing pool node set information. 
 */
export interface PoolNodeSetResourceUsage {
  pools: PoolResourceUsage[];
}

export type PoolResourcesEntryUsageFields = { [key: string]: unknown };

export type PoolResourcesEntryAllocatableFields = { [key: string]: unknown };

/**
 * Entry for resources API results. 
 */
export interface PoolResourcesEntry {
  pool: string;
  platform: string;
  status: PoolStatus;
  usage_fields: PoolResourcesEntryUsageFields;
  allocatable_fields: PoolResourcesEntryAllocatableFields;
  backend: string;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface PoolResourcesResponse {
  pools: PoolResourcesEntry[];
}

/**
 * Object storing pool information. 
 */
export interface PoolResponse {
  node_sets: PoolNodeSetResourceUsage[];
  resource_sum: ResourceUsage;
}

/**
 * Request body for creating a new backend with history tracking metadata.
 */
export interface PostBackendRequest {
  description?: string;
  tags?: string[];
  configs: BackendConfig;
}

/**
 * Provides all User Profile Information 
 */
export interface UserProfile {
  username?: string;
  email_notification?: boolean;
  slack_notification?: boolean;
  bucket?: string;
  pool?: string;
}

/**
 * Identity when the request is authenticated with an access token. 
 */
export interface TokenIdentity {
  name: string;
  expires_at?: string;
}

/**
 * Profile and identity info. When token header is set, roles/pools are the
token's; otherwise they are the user's. JSON is self-explanatory for CLI.
 */
export interface ProfileResponse {
  profile: UserProfile;
  roles: string[];
  pools: string[];
  token?: TokenIdentity;
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestRequest {
  description?: string;
  tags?: string[];
  configs: BackendTests;
}

export type PutBackendTestsRequestConfigs = {[key: string]: BackendTests};

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestsRequest {
  description?: string;
  tags?: string[];
  configs: PutBackendTestsRequestConfigs;
}

/**
 * Request body for updating dataset configurations with history tracking metadata.
 */
export interface PutDatasetRequest {
  description?: string;
  tags?: string[];
  configs: DatasetConfig;
}

export type PutGroupTemplateRequestConfigs = { [key: string]: unknown };

/**
 * Request body for updating a group template with history tracking metadata.
 */
export interface PutGroupTemplateRequest {
  description?: string;
  tags?: string[];
  configs: PutGroupTemplateRequestConfigs;
}

export type PutGroupTemplatesRequestConfigs = {[key: string]: { [key: string]: unknown }};

/**
 * Request body for updating group templates with history tracking metadata.
 */
export interface PutGroupTemplatesRequest {
  description?: string;
  tags?: string[];
  configs: PutGroupTemplatesRequestConfigs;
}

export type PutPodTemplateRequestConfigs = { [key: string]: unknown };

/**
 * Request body for updating a pod template with history tracking metadata.
 */
export interface PutPodTemplateRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplateRequestConfigs;
}

export type PutPodTemplatesRequestConfigs = {[key: string]: { [key: string]: unknown }};

/**
 * Request body for updating pod templates with history tracking metadata.
 */
export interface PutPodTemplatesRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplatesRequestConfigs;
}

/**
 * Request body for updating a platform in a pool with history tracking metadata.
 */
export interface PutPoolPlatformRequest {
  description?: string;
  tags?: string[];
  configs: Platform;
}

/**
 * Request body for updating a pool with history tracking metadata.
 */
export interface PutPoolRequest {
  description?: string;
  tags?: string[];
  configs: Pool;
}

export type PutPoolsRequestConfigs = {[key: string]: Pool};

/**
 * Request body for updating pools with history tracking metadata.
 */
export interface PutPoolsRequest {
  description?: string;
  tags?: string[];
  configs: PutPoolsRequestConfigs;
}

export type PutResourceValidationRequestConfigsItem = { [key: string]: unknown };

/**
 * Request body for updating a resource validation with history tracking metadata.
 */
export interface PutResourceValidationRequest {
  description?: string;
  tags?: string[];
  configs: PutResourceValidationRequestConfigsItem[];
}

export type PutResourceValidationsRequestConfigsDictItem = { [key: string]: unknown };

export type PutResourceValidationsRequestConfigsDict = {[key: string]: PutResourceValidationsRequestConfigsDictItem[]};

/**
 * Request body for updating resource validations with history tracking metadata.
 */
export interface PutResourceValidationsRequest {
  description?: string;
  tags?: string[];
  configs_dict: PutResourceValidationsRequestConfigsDict;
}

/**
 * Single Role Policy Entry.

Contains a list of actions (semantic format "resource:Action") and optional
resources the policy applies to. If effect is Deny and the policy matches,
access is denied even if another policy allows it.

Actions are validated via regex; API/DB still use [{"action": "..."}] for
compatibility with the Go authz_sidecar.
 */
export interface RolePolicy {
  effect?: PolicyEffect;
  actions: string[];
  resources?: string[];
}

/**
 * Sync mode for role assignments.

- FORCE: Always apply this role to all users (e.g., for system roles)
- IMPORT: Role is imported from IDP claims or user_roles table (default)
- IGNORE: Ignore this role in IDP sync (role is managed manually)
 */
export type SyncMode = typeof SyncMode[keyof typeof SyncMode];


export const SyncMode = {
  force: 'force',
  import: 'import',
  ignore: 'ignore',
} as const;

/**
 * Single Role Entry.

Note: Authorization checking is now handled by the authz_sidecar (Go service).
This Python class is only used for role CRUD operations.
 */
export interface Role {
  name: string;
  description: string;
  policies: RolePolicy[];
  immutable?: boolean;
  sync_mode?: SyncMode;
  external_roles?: string[];
}

/**
 * Request body for updating a role with history tracking metadata.
 */
export interface PutRoleRequest {
  description?: string;
  tags?: string[];
  configs: Role;
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutRolesRequest {
  description?: string;
  tags?: string[];
  configs: Role[];
}

/**
 * Stores any configs OSMO Admins control 
 */
export interface ServiceConfig {
  service_base_url?: string;
  service_auth?: AuthenticationConfig;
  cli_config?: CliConfig;
  max_pod_restart_limit?: string;
  agent_queue_size?: number;
}

/**
 * Request body for updating service configurations with history tracking metadata.
 */
export interface PutServiceRequest {
  description?: string;
  tags?: string[];
  configs: ServiceConfig;
}

/**
 * Config for workflow storage info. 
 */
export interface WorkflowInfo {
  tags?: string[];
  max_name_length?: number;
}

/**
 * Stores workflow limits per user. Default is None, which means no limit.
If a limit is set, it must be greater than 0.
 */
export interface UserWorkflowLimitConfig {
  /** @exclusiveMinimum 0 */
  max_num_workflows?: number;
  /** @exclusiveMinimum 0 */
  max_num_tasks?: number;
  jinja_sandbox_workers?: number;
  jinja_sandbox_max_time?: number;
  jinja_sandbox_memory_limit?: number;
}

/**
 * Stores any workflow configs External Admins control 
 */
export interface WorkflowConfig {
  workflow_data?: DataConfig;
  workflow_log?: LogConfig;
  workflow_app?: LogConfig;
  workflow_info?: WorkflowInfo;
  backend_images?: OsmoImageConfig;
  workflow_alerts?: NotificationConfig;
  credential_config?: CredentialConfig;
  user_workflow_limits?: UserWorkflowLimitConfig;
  plugins_config?: PluginsConfig;
  max_num_tasks?: number;
  max_num_ports_per_task?: number;
  max_retry_per_task?: number;
  max_retry_per_job?: number;
  default_schedule_timeout?: number;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  force_cleanup_delay?: string;
  max_log_lines?: number;
  max_task_log_lines?: number;
  max_error_log_lines?: number;
  max_event_log_lines?: number;
  task_heartbeat_frequency?: string;
}

/**
 * Request body for updating workflow configurations with history tracking metadata.
 */
export interface PutWorkflowRequest {
  description?: string;
  tags?: string[];
  configs: WorkflowConfig;
}

/**
 * Request body for renaming a platform in a pool with history tracking metadata.
 */
export interface RenamePoolPlatformRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

/**
 * Request body for renaming a pool with history tracking metadata.
 */
export interface RenamePoolRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

export type ResourcesEntryExposedFields = { [key: string]: unknown };

export type ResourcesEntryTaintsItem = { [key: string]: unknown };

export type ResourcesEntryUsageFields = { [key: string]: unknown };

export type ResourcesEntryNonWorkflowUsageFields = { [key: string]: unknown };

export type ResourcesEntryAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAvailableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformWorkflowAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryConfigFields = { [key: string]: unknown };

export type ResourcesEntryLabelFields = { [key: string]: unknown };

export type ResourcesEntryPoolPlatformLabels = {[key: string]: string[]};

/**
 * Entry for resources API results. 
 */
export interface ResourcesEntry {
  hostname: string;
  exposed_fields: ResourcesEntryExposedFields;
  taints: ResourcesEntryTaintsItem[];
  usage_fields: ResourcesEntryUsageFields;
  conditions?: string[];
  non_workflow_usage_fields: ResourcesEntryNonWorkflowUsageFields;
  allocatable_fields: ResourcesEntryAllocatableFields;
  platform_allocatable_fields?: ResourcesEntryPlatformAllocatableFields;
  platform_available_fields?: ResourcesEntryPlatformAvailableFields;
  platform_workflow_allocatable_fields?: ResourcesEntryPlatformWorkflowAllocatableFields;
  config_fields?: ResourcesEntryConfigFields;
  backend: string;
  label_fields?: ResourcesEntryLabelFields;
  pool_platform_labels: ResourcesEntryPoolPlatformLabels;
  resource_type: BackendResourceType;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface ResourcesResponse {
  resources: ResourcesEntry[];
}

export type RoleUsersResponseUsersItem = { [key: string]: unknown };

/**
 * Response for listing users with a role.
 */
export interface RoleUsersResponse {
  role_name: string;
  users: RoleUsersResponseUsersItem[];
}

/**
 * Type of configs supported by config history 
 */
export type SrcUtilsConnectorsPostgresConfigHistoryType = typeof SrcUtilsConnectorsPostgresConfigHistoryType[keyof typeof SrcUtilsConnectorsPostgresConfigHistoryType];


export const SrcUtilsConnectorsPostgresConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  GROUP_TEMPLATE: 'GROUP_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

/**
 * Request body for config rollback endpoint.
 */
export interface RollbackConfigRequest {
  description?: string;
  tags?: string[];
  config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
  /**
   * Revision to roll back to
   * @exclusiveMinimum 0
   */
  revision: number;
}

/**
 * Router Information Response. 
 */
export interface RouterResponse {
  router_address: string;
  key: string;
  cookie: string;
}

/**
 * Object storing workflow name, logs, and spec after submission. 
 */
export interface SubmitResponse {
  name: string;
  overview?: string;
  logs?: string;
  spec?: string;
  dashboard_url?: string;
}

/**
 * Entry for task GET API result. 
 */
export interface TaskEntry {
  workflow_id: string;
  task_name: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  status: TaskGroupStatus;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
}

/**
 * Template Spec. 
 */
export interface TemplateSpec {
  file: string;
  set_variables?: string[];
  set_string_variables?: string[];
  uploaded_templated_spec?: string;
}

/**
 * Request body for updating config tags endpoint.
 */
export interface UpdateConfigTagsRequest {
  /** Tags to add to the config */
  set_tags?: string[];
  /** Tags to remove from the config */
  delete_tags?: string[];
}

/**
 * User record.
 */
export interface User {
  id: string;
  created_at?: string;
  created_by?: string;
}

/**
 * Response for listing users.
 */
export interface UserListResponse {
  total_results: number;
  start_index: number;
  items_per_page: number;
  users: User[];
}

/**
 * User role assignment.
 */
export interface UserRole {
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * User role assignment response.
 */
export interface UserRoleAssignment {
  user_id: string;
  role_name: string;
  assigned_by: string;
  assigned_at: string;
}

/**
 * Response for listing user roles.
 */
export interface UserRolesResponse {
  user_id: string;
  roles: UserRole[];
}

/**
 * User record with role assignments.
 */
export interface UserWithRoles {
  id: string;
  created_at?: string;
  created_by?: string;
  roles?: UserRole[];
}

export type VerbosePoolConfigPools = {[key: string]: Pool};

/**
 * Stores verbose pool configs.
 */
export interface VerbosePoolConfig {
  pools?: VerbosePoolConfigPools;
}

/**
 * Represents the state of plugins in a workflow upon submission. 
 */
export interface WorkflowPlugins {
  rsync?: boolean;
}

/**
 * Scheduling priority for workflows
 */
export type WorkflowPriority = typeof WorkflowPriority[keyof typeof WorkflowPriority];


export const WorkflowPriority = {
  HIGH: 'HIGH',
  NORMAL: 'NORMAL',
  LOW: 'LOW',
} as const;

/**
 * Represents the status of a workflow. 
 */
export type WorkflowStatus = typeof WorkflowStatus[keyof typeof WorkflowStatus];


export const WorkflowStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  WAITING: 'WAITING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  FAILED_SUBMISSION: 'FAILED_SUBMISSION',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Represents the queryed workflow information. 
 */
export interface WorkflowQueryResponse {
  name: string;
  uuid: string;
  submitted_by: string;
  cancelled_by?: string;
  spec: string;
  template_spec: string;
  logs: string;
  events: string;
  overview: string;
  parent_name?: string;
  parent_job_id?: number;
  dashboard_url?: string;
  grafana_url?: string;
  tags?: string[];
  submit_time: string;
  start_time?: string;
  end_time?: string;
  exec_timeout?: number;
  queue_timeout?: number;
  duration?: number;
  queued_time: number;
  status: WorkflowStatus;
  outputs?: string;
  groups: GroupQueryResponse[];
  pool?: string;
  backend?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  plugins: WorkflowPlugins;
  priority: string;
}

export interface SrcServiceCoreAppObjectsListEntry {
  uuid: string;
  name: string;
  description: string;
  created_date: string;
  owner: string;
  latest_version: string;
}

export interface SrcServiceCoreAppObjectsListResponse {
  apps: SrcServiceCoreAppObjectsListEntry[];
  more_entries: boolean;
}

/**
 * Entry for list API results. 
 */
export interface SrcServiceCoreWorkflowObjectsListEntry {
  user: string;
  name: string;
  workflow_uuid: string;
  submit_time: string;
  start_time?: string;
  end_time?: string;
  queued_time: number;
  duration?: number;
  status: WorkflowStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  pool?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  priority: string;
}

export interface SrcServiceCoreWorkflowObjectsListResponse {
  workflows: SrcServiceCoreWorkflowObjectsListEntry[];
  more_entries: boolean;
}

export type PutServiceConfigsApiConfigsServicePut200 = { [key: string]: unknown };

export type PatchServiceConfigsApiConfigsServicePatch200 = { [key: string]: unknown };

export type PutWorkflowConfigsApiConfigsWorkflowPut200 = { [key: string]: unknown };

export type PatchWorkflowConfigsApiConfigsWorkflowPatch200 = { [key: string]: unknown };

export type PutDatasetConfigsApiConfigsDatasetPut200 = { [key: string]: unknown };

export type PatchDatasetConfigsApiConfigsDatasetPatch200 = { [key: string]: unknown };

export type PatchDatasetApiConfigsDatasetNamePatch200 = { [key: string]: unknown };

export type ListPoolsApiConfigsPoolGetParams = {
verbose?: boolean;
backend?: string;
};

export type ReadPoolApiConfigsPoolNameGetParams = {
verbose?: boolean;
};

export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams = {
verbose?: boolean;
};

export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams = {
verbose?: boolean;
};

export type GetConfigsHistoryApiConfigsHistoryGetParams = {
/**
 * Number of records to skip
 * @minimum 0
 */
offset?: number;
/**
 * Maximum number of records to return
 * @maximum 1000
 * @exclusiveMinimum 0
 */
limit?: number;
/**
 * Sort order by creation time
 */
order?: ListOrder;
/**
 * Filter by config types
 */
config_types?: SrcLibUtilsConfigHistoryConfigHistoryType[];
/**
 * Filter by config name
 */
name?: string;
/**
 * Filter by revision
 * @exclusiveMinimum 0
 */
revision?: number;
/**
 * Filter by tags
 */
tags?: string[];
/**
 * Filter by creation time before
 */
created_before?: string;
/**
 * Filter by creation time after
 */
created_after?: string;
/**
 * Get config state at specific timestamp
 */
at_timestamp?: string;
/**
 * Whether to omit data from the response
 */
omit_data?: boolean;
};

export type GetConfigDiffApiConfigsDiffGetParams = {
config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
/**
 * First revision to compare
 * @exclusiveMinimum 0
 */
first_revision: number;
/**
 * Second revision to compare
 * @exclusiveMinimum 0
 */
second_revision: number;
};

export type GetNewJwtTokenApiAuthJwtRefreshTokenGetParams = {
refresh_token: string;
workflow_id: string;
group_name: string;
task_name: string;
retry_id?: number;
};

export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams = {
access_token: string;
};

export type CreateAccessTokenApiAuthAccessTokenTokenNamePostParams = {
expires_at: string;
description?: string;
roles?: string[];
};

export type AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams = {
expires_at: string;
description?: string;
roles?: string[];
};

export type ListUsersApiAuthUserGetParams = {
start_index?: number;
count?: number;
id_prefix?: string;
roles?: string[];
};

export type ListAppsApiAppGetParams = {
name?: string;
users?: string[];
all_users?: boolean;
offset?: number;
limit?: number;
order?: ListOrder;
};

export type GetAppApiAppUserNameGetParams = {
version?: number;
limit?: number;
order?: ListOrder;
};

export type CreateAppApiAppUserNamePostParams = {
description: string;
};

export type DeleteAppApiAppUserNameDeleteParams = {
version?: number;
all_versions?: boolean;
};

export type DeleteAppApiAppUserNameDelete200 = {[key: string]: number[]};

export type GetAppContentApiAppUserNameSpecGetParams = {
version?: number;
};

export type CancelWorkflowApiWorkflowNameCancelPostParams = {
message?: string;
force?: boolean;
};

export type ListWorkflowApiWorkflowGetParams = {
users?: string[];
name?: string;
statuses?: WorkflowStatus[];
offset?: number;
limit?: number;
order?: ListOrder;
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
submitted_before?: string;
submitted_after?: string;
tags?: string[];
app?: string;
priority?: WorkflowPriority[];
};

export type ListTaskApiTaskGetParams = {
workflow_id?: string;
statuses?: TaskGroupStatus[];
users?: string[];
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
nodes?: string[];
started_after?: string;
started_before?: string;
offset?: number;
limit?: number;
order?: ListOrder;
summary?: boolean;
aggregate_by_workflow?: boolean;
priority?: WorkflowPriority[];
};

export type GetWorkflowApiWorkflowNameGetParams = {
skip_groups?: boolean;
verbose?: boolean;
};

export type GetWorkflowLogsApiWorkflowNameLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowPodConditionsApiWorkflowNameEventsGetParams = {
task_name?: string;
retry_id?: number;
};

export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowSpecApiWorkflowNameSpecGetParams = {
use_template?: boolean;
};

export type TagWorkflowApiWorkflowNameTagPostParams = {
add?: string[];
remove?: string[];
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams = {
entry_command: string;
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200 = {[key: string]: RouterResponse};

export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams = {
entry_command: string;
};

export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams = {
task_ports?: number[];
use_udp?: boolean;
};

export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams = {
task_port: number;
};

export type GetResourcesApiResourcesGetParams = {
pools?: string[];
platforms?: string[];
all_pools?: boolean;
concise?: boolean;
};

export type GetPoolsApiPoolGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type GetPoolQuotasApiPoolQuotaGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type SubmitWorkflowApiPoolPoolNameWorkflowPostParams = {
workflow_id?: string;
app_uuid?: string;
app_version?: number;
dry_run?: boolean;
validation_only?: boolean;
priority?: WorkflowPriority;
env_vars?: string[];
};

export type GetBucketInfoApiBucketGetParams = {
default_only?: boolean;
};

export type DeleteDatasetApiBucketBucketDatasetNameDeleteParams = {
tag?: string;
all_flag?: boolean;
finish?: boolean;
};

export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams = {
tag?: string;
new_name?: string;
set_tag?: string[];
delete_tag?: string[];
delete_label?: string[];
delete_metadata?: string[];
};

export type GetInfoApiBucketBucketDatasetNameInfoGetParams = {
tag?: string;
all_flag?: boolean;
count?: number;
order?: ListOrder;
};

export type ListDatasetFromBucketApiBucketListDatasetGetParams = {
name?: string;
user?: string[];
buckets?: string[];
dataset_type?: DatasetType;
latest_before?: string;
latest_after?: string;
all_users?: boolean;
order?: ListOrder;
count?: number;
};

export type QueryDatasetApiBucketBucketQueryGetParams = {
command?: string;
};

export type SetNotificationSettingsApiProfileSettingsPostParams = {
set_default_backend?: boolean;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Read all the service configurations
 * @summary Read Service Configs
 */
export type readServiceConfigsApiConfigsServiceGetResponse200 = {
  data: string
  status: 200
}

export type readServiceConfigsApiConfigsServiceGetResponseSuccess = (readServiceConfigsApiConfigsServiceGetResponse200) & {
  headers: Headers;
};
;

export type readServiceConfigsApiConfigsServiceGetResponse = (readServiceConfigsApiConfigsServiceGetResponseSuccess)

export const getReadServiceConfigsApiConfigsServiceGetUrl = () => {


  

  return `/api/configs/service`
}

export const readServiceConfigsApiConfigsServiceGet = async ( options?: RequestInit): Promise<readServiceConfigsApiConfigsServiceGetResponse> => {
  
  return customFetch<readServiceConfigsApiConfigsServiceGetResponse>(getReadServiceConfigsApiConfigsServiceGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadServiceConfigsApiConfigsServiceGetQueryKey = () => {
    return [
    `/api/configs/service`
    ] as const;
    }

    
export const getReadServiceConfigsApiConfigsServiceGetQueryOptions = <TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadServiceConfigsApiConfigsServiceGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>> = ({ signal }) => readServiceConfigsApiConfigsServiceGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadServiceConfigsApiConfigsServiceGetQueryResult = NonNullable<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>>
export type ReadServiceConfigsApiConfigsServiceGetQueryError = unknown


export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>,
          TError,
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>,
          TError,
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Service Configs
 */

export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadServiceConfigsApiConfigsServiceGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put service configurations
 * @summary Put Service Configs
 */
export type putServiceConfigsApiConfigsServicePutResponse200 = {
  data: PutServiceConfigsApiConfigsServicePut200
  status: 200
}

export type putServiceConfigsApiConfigsServicePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putServiceConfigsApiConfigsServicePutResponseSuccess = (putServiceConfigsApiConfigsServicePutResponse200) & {
  headers: Headers;
};
export type putServiceConfigsApiConfigsServicePutResponseError = (putServiceConfigsApiConfigsServicePutResponse422) & {
  headers: Headers;
};

export type putServiceConfigsApiConfigsServicePutResponse = (putServiceConfigsApiConfigsServicePutResponseSuccess | putServiceConfigsApiConfigsServicePutResponseError)

export const getPutServiceConfigsApiConfigsServicePutUrl = () => {


  

  return `/api/configs/service`
}

export const putServiceConfigsApiConfigsServicePut = async (putServiceRequest: PutServiceRequest, options?: RequestInit): Promise<putServiceConfigsApiConfigsServicePutResponse> => {
  
  return customFetch<putServiceConfigsApiConfigsServicePutResponse>(getPutServiceConfigsApiConfigsServicePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putServiceRequest,)
  }
);}
  



export const getPutServiceConfigsApiConfigsServicePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext> => {

const mutationKey = ['putServiceConfigsApiConfigsServicePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, {data: PutServiceRequest}> = (props) => {
          const {data} = props ?? {};

          return  putServiceConfigsApiConfigsServicePut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutServiceConfigsApiConfigsServicePutMutationResult = NonNullable<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>>
    export type PutServiceConfigsApiConfigsServicePutMutationBody = PutServiceRequest
    export type PutServiceConfigsApiConfigsServicePutMutationError = HTTPValidationError

    /**
 * @summary Put Service Configs
 */
export const usePutServiceConfigsApiConfigsServicePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>,
        TError,
        {data: PutServiceRequest},
        TContext
      > => {
      return useMutation(getPutServiceConfigsApiConfigsServicePutMutationOptions(options), queryClient);
    }
    
/**
 * Patch service configurations
 * @summary Patch Service Configs
 */
export type patchServiceConfigsApiConfigsServicePatchResponse200 = {
  data: PatchServiceConfigsApiConfigsServicePatch200
  status: 200
}

export type patchServiceConfigsApiConfigsServicePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchServiceConfigsApiConfigsServicePatchResponseSuccess = (patchServiceConfigsApiConfigsServicePatchResponse200) & {
  headers: Headers;
};
export type patchServiceConfigsApiConfigsServicePatchResponseError = (patchServiceConfigsApiConfigsServicePatchResponse422) & {
  headers: Headers;
};

export type patchServiceConfigsApiConfigsServicePatchResponse = (patchServiceConfigsApiConfigsServicePatchResponseSuccess | patchServiceConfigsApiConfigsServicePatchResponseError)

export const getPatchServiceConfigsApiConfigsServicePatchUrl = () => {


  

  return `/api/configs/service`
}

export const patchServiceConfigsApiConfigsServicePatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchServiceConfigsApiConfigsServicePatchResponse> => {
  
  return customFetch<patchServiceConfigsApiConfigsServicePatchResponse>(getPatchServiceConfigsApiConfigsServicePatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
);}
  



export const getPatchServiceConfigsApiConfigsServicePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchServiceConfigsApiConfigsServicePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchServiceConfigsApiConfigsServicePatch(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchServiceConfigsApiConfigsServicePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>>
    export type PatchServiceConfigsApiConfigsServicePatchMutationBody = PatchConfigRequest
    export type PatchServiceConfigsApiConfigsServicePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Service Configs
 */
export const usePatchServiceConfigsApiConfigsServicePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {
      return useMutation(getPatchServiceConfigsApiConfigsServicePatchMutationOptions(options), queryClient);
    }
    
/**
 * Read all the workflow configurations
 * @summary Read Workflow Configs
 */
export type readWorkflowConfigsApiConfigsWorkflowGetResponse200 = {
  data: string
  status: 200
}

export type readWorkflowConfigsApiConfigsWorkflowGetResponseSuccess = (readWorkflowConfigsApiConfigsWorkflowGetResponse200) & {
  headers: Headers;
};
;

export type readWorkflowConfigsApiConfigsWorkflowGetResponse = (readWorkflowConfigsApiConfigsWorkflowGetResponseSuccess)

export const getReadWorkflowConfigsApiConfigsWorkflowGetUrl = () => {


  

  return `/api/configs/workflow`
}

export const readWorkflowConfigsApiConfigsWorkflowGet = async ( options?: RequestInit): Promise<readWorkflowConfigsApiConfigsWorkflowGetResponse> => {
  
  return customFetch<readWorkflowConfigsApiConfigsWorkflowGetResponse>(getReadWorkflowConfigsApiConfigsWorkflowGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadWorkflowConfigsApiConfigsWorkflowGetQueryKey = () => {
    return [
    `/api/configs/workflow`
    ] as const;
    }

    
export const getReadWorkflowConfigsApiConfigsWorkflowGetQueryOptions = <TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadWorkflowConfigsApiConfigsWorkflowGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>> = ({ signal }) => readWorkflowConfigsApiConfigsWorkflowGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadWorkflowConfigsApiConfigsWorkflowGetQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>>
export type ReadWorkflowConfigsApiConfigsWorkflowGetQueryError = unknown


export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Workflow Configs
 */

export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadWorkflowConfigsApiConfigsWorkflowGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put workflow configurations
 * @summary Put Workflow Configs
 */
export type putWorkflowConfigsApiConfigsWorkflowPutResponse200 = {
  data: PutWorkflowConfigsApiConfigsWorkflowPut200
  status: 200
}

export type putWorkflowConfigsApiConfigsWorkflowPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putWorkflowConfigsApiConfigsWorkflowPutResponseSuccess = (putWorkflowConfigsApiConfigsWorkflowPutResponse200) & {
  headers: Headers;
};
export type putWorkflowConfigsApiConfigsWorkflowPutResponseError = (putWorkflowConfigsApiConfigsWorkflowPutResponse422) & {
  headers: Headers;
};

export type putWorkflowConfigsApiConfigsWorkflowPutResponse = (putWorkflowConfigsApiConfigsWorkflowPutResponseSuccess | putWorkflowConfigsApiConfigsWorkflowPutResponseError)

export const getPutWorkflowConfigsApiConfigsWorkflowPutUrl = () => {


  

  return `/api/configs/workflow`
}

export const putWorkflowConfigsApiConfigsWorkflowPut = async (putWorkflowRequest: PutWorkflowRequest, options?: RequestInit): Promise<putWorkflowConfigsApiConfigsWorkflowPutResponse> => {
  
  return customFetch<putWorkflowConfigsApiConfigsWorkflowPutResponse>(getPutWorkflowConfigsApiConfigsWorkflowPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putWorkflowRequest,)
  }
);}
  



export const getPutWorkflowConfigsApiConfigsWorkflowPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext> => {

const mutationKey = ['putWorkflowConfigsApiConfigsWorkflowPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, {data: PutWorkflowRequest}> = (props) => {
          const {data} = props ?? {};

          return  putWorkflowConfigsApiConfigsWorkflowPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationResult = NonNullable<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>>
    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationBody = PutWorkflowRequest
    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationError = HTTPValidationError

    /**
 * @summary Put Workflow Configs
 */
export const usePutWorkflowConfigsApiConfigsWorkflowPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>,
        TError,
        {data: PutWorkflowRequest},
        TContext
      > => {
      return useMutation(getPutWorkflowConfigsApiConfigsWorkflowPutMutationOptions(options), queryClient);
    }
    
/**
 * Patch workflow configurations
 * @summary Patch Workflow Configs
 */
export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse200 = {
  data: PatchWorkflowConfigsApiConfigsWorkflowPatch200
  status: 200
}

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponseSuccess = (patchWorkflowConfigsApiConfigsWorkflowPatchResponse200) & {
  headers: Headers;
};
export type patchWorkflowConfigsApiConfigsWorkflowPatchResponseError = (patchWorkflowConfigsApiConfigsWorkflowPatchResponse422) & {
  headers: Headers;
};

export type patchWorkflowConfigsApiConfigsWorkflowPatchResponse = (patchWorkflowConfigsApiConfigsWorkflowPatchResponseSuccess | patchWorkflowConfigsApiConfigsWorkflowPatchResponseError)

export const getPatchWorkflowConfigsApiConfigsWorkflowPatchUrl = () => {


  

  return `/api/configs/workflow`
}

export const patchWorkflowConfigsApiConfigsWorkflowPatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchWorkflowConfigsApiConfigsWorkflowPatchResponse> => {
  
  return customFetch<patchWorkflowConfigsApiConfigsWorkflowPatchResponse>(getPatchWorkflowConfigsApiConfigsWorkflowPatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
);}
  



export const getPatchWorkflowConfigsApiConfigsWorkflowPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchWorkflowConfigsApiConfigsWorkflowPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchWorkflowConfigsApiConfigsWorkflowPatch(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>>
    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationBody = PatchConfigRequest
    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationError = HTTPValidationError

    /**
 * @summary Patch Workflow Configs
 */
export const usePatchWorkflowConfigsApiConfigsWorkflowPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {
      return useMutation(getPatchWorkflowConfigsApiConfigsWorkflowPatchMutationOptions(options), queryClient);
    }
    
/**
 * Read all the dataset configurations
 * @summary Read Dataset Configs
 */
export type readDatasetConfigsApiConfigsDatasetGetResponse200 = {
  data: string
  status: 200
}

export type readDatasetConfigsApiConfigsDatasetGetResponseSuccess = (readDatasetConfigsApiConfigsDatasetGetResponse200) & {
  headers: Headers;
};
;

export type readDatasetConfigsApiConfigsDatasetGetResponse = (readDatasetConfigsApiConfigsDatasetGetResponseSuccess)

export const getReadDatasetConfigsApiConfigsDatasetGetUrl = () => {


  

  return `/api/configs/dataset`
}

export const readDatasetConfigsApiConfigsDatasetGet = async ( options?: RequestInit): Promise<readDatasetConfigsApiConfigsDatasetGetResponse> => {
  
  return customFetch<readDatasetConfigsApiConfigsDatasetGetResponse>(getReadDatasetConfigsApiConfigsDatasetGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadDatasetConfigsApiConfigsDatasetGetQueryKey = () => {
    return [
    `/api/configs/dataset`
    ] as const;
    }

    
export const getReadDatasetConfigsApiConfigsDatasetGetQueryOptions = <TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDatasetConfigsApiConfigsDatasetGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>> = ({ signal }) => readDatasetConfigsApiConfigsDatasetGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadDatasetConfigsApiConfigsDatasetGetQueryResult = NonNullable<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>>
export type ReadDatasetConfigsApiConfigsDatasetGetQueryError = unknown


export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Dataset Configs
 */

export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadDatasetConfigsApiConfigsDatasetGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put dataset configurations
 * @summary Put Dataset Configs
 */
export type putDatasetConfigsApiConfigsDatasetPutResponse200 = {
  data: PutDatasetConfigsApiConfigsDatasetPut200
  status: 200
}

export type putDatasetConfigsApiConfigsDatasetPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putDatasetConfigsApiConfigsDatasetPutResponseSuccess = (putDatasetConfigsApiConfigsDatasetPutResponse200) & {
  headers: Headers;
};
export type putDatasetConfigsApiConfigsDatasetPutResponseError = (putDatasetConfigsApiConfigsDatasetPutResponse422) & {
  headers: Headers;
};

export type putDatasetConfigsApiConfigsDatasetPutResponse = (putDatasetConfigsApiConfigsDatasetPutResponseSuccess | putDatasetConfigsApiConfigsDatasetPutResponseError)

export const getPutDatasetConfigsApiConfigsDatasetPutUrl = () => {


  

  return `/api/configs/dataset`
}

export const putDatasetConfigsApiConfigsDatasetPut = async (putDatasetRequest: PutDatasetRequest, options?: RequestInit): Promise<putDatasetConfigsApiConfigsDatasetPutResponse> => {
  
  return customFetch<putDatasetConfigsApiConfigsDatasetPutResponse>(getPutDatasetConfigsApiConfigsDatasetPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putDatasetRequest,)
  }
);}
  



export const getPutDatasetConfigsApiConfigsDatasetPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext> => {

const mutationKey = ['putDatasetConfigsApiConfigsDatasetPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, {data: PutDatasetRequest}> = (props) => {
          const {data} = props ?? {};

          return  putDatasetConfigsApiConfigsDatasetPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutDatasetConfigsApiConfigsDatasetPutMutationResult = NonNullable<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>>
    export type PutDatasetConfigsApiConfigsDatasetPutMutationBody = PutDatasetRequest
    export type PutDatasetConfigsApiConfigsDatasetPutMutationError = HTTPValidationError

    /**
 * @summary Put Dataset Configs
 */
export const usePutDatasetConfigsApiConfigsDatasetPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>,
        TError,
        {data: PutDatasetRequest},
        TContext
      > => {
      return useMutation(getPutDatasetConfigsApiConfigsDatasetPutMutationOptions(options), queryClient);
    }
    
/**
 * Patch dataset configurations
 * @summary Patch Dataset Configs
 */
export type patchDatasetConfigsApiConfigsDatasetPatchResponse200 = {
  data: PatchDatasetConfigsApiConfigsDatasetPatch200
  status: 200
}

export type patchDatasetConfigsApiConfigsDatasetPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchDatasetConfigsApiConfigsDatasetPatchResponseSuccess = (patchDatasetConfigsApiConfigsDatasetPatchResponse200) & {
  headers: Headers;
};
export type patchDatasetConfigsApiConfigsDatasetPatchResponseError = (patchDatasetConfigsApiConfigsDatasetPatchResponse422) & {
  headers: Headers;
};

export type patchDatasetConfigsApiConfigsDatasetPatchResponse = (patchDatasetConfigsApiConfigsDatasetPatchResponseSuccess | patchDatasetConfigsApiConfigsDatasetPatchResponseError)

export const getPatchDatasetConfigsApiConfigsDatasetPatchUrl = () => {


  

  return `/api/configs/dataset`
}

export const patchDatasetConfigsApiConfigsDatasetPatch = async (patchConfigRequest: PatchConfigRequest, options?: RequestInit): Promise<patchDatasetConfigsApiConfigsDatasetPatchResponse> => {
  
  return customFetch<patchDatasetConfigsApiConfigsDatasetPatchResponse>(getPatchDatasetConfigsApiConfigsDatasetPatchUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchConfigRequest,)
  }
);}
  



export const getPatchDatasetConfigsApiConfigsDatasetPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchDatasetConfigsApiConfigsDatasetPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchDatasetConfigsApiConfigsDatasetPatch(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>>
    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationBody = PatchConfigRequest
    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationError = HTTPValidationError

    /**
 * @summary Patch Dataset Configs
 */
export const usePatchDatasetConfigsApiConfigsDatasetPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {
      return useMutation(getPatchDatasetConfigsApiConfigsDatasetPatchMutationOptions(options), queryClient);
    }
    
/**
 * Delete dataset configuration for a specific bucket
 * @summary Delete Dataset
 */
export type deleteDatasetApiConfigsDatasetNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteDatasetApiConfigsDatasetNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteDatasetApiConfigsDatasetNameDeleteResponseSuccess = (deleteDatasetApiConfigsDatasetNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteDatasetApiConfigsDatasetNameDeleteResponseError = (deleteDatasetApiConfigsDatasetNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteDatasetApiConfigsDatasetNameDeleteResponse = (deleteDatasetApiConfigsDatasetNameDeleteResponseSuccess | deleteDatasetApiConfigsDatasetNameDeleteResponseError)

export const getDeleteDatasetApiConfigsDatasetNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/dataset/${name}`
}

export const deleteDatasetApiConfigsDatasetNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteDatasetApiConfigsDatasetNameDeleteResponse> => {
  
  return customFetch<deleteDatasetApiConfigsDatasetNameDeleteResponse>(getDeleteDatasetApiConfigsDatasetNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeleteDatasetApiConfigsDatasetNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteDatasetApiConfigsDatasetNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteDatasetApiConfigsDatasetNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>>
    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationBody = ConfigsRequest
    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDatasetApiConfigsDatasetNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeleteDatasetApiConfigsDatasetNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Patch dataset configuration for a specific bucket
 * @summary Patch Dataset
 */
export type patchDatasetApiConfigsDatasetNamePatchResponse200 = {
  data: PatchDatasetApiConfigsDatasetNamePatch200
  status: 200
}

export type patchDatasetApiConfigsDatasetNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchDatasetApiConfigsDatasetNamePatchResponseSuccess = (patchDatasetApiConfigsDatasetNamePatchResponse200) & {
  headers: Headers;
};
export type patchDatasetApiConfigsDatasetNamePatchResponseError = (patchDatasetApiConfigsDatasetNamePatchResponse422) & {
  headers: Headers;
};

export type patchDatasetApiConfigsDatasetNamePatchResponse = (patchDatasetApiConfigsDatasetNamePatchResponseSuccess | patchDatasetApiConfigsDatasetNamePatchResponseError)

export const getPatchDatasetApiConfigsDatasetNamePatchUrl = (name: string,) => {


  

  return `/api/configs/dataset/${name}`
}

export const patchDatasetApiConfigsDatasetNamePatch = async (name: string,
    patchDatasetRequest: PatchDatasetRequest, options?: RequestInit): Promise<patchDatasetApiConfigsDatasetNamePatchResponse> => {
  
  return customFetch<patchDatasetApiConfigsDatasetNamePatchResponse>(getPatchDatasetApiConfigsDatasetNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchDatasetRequest,)
  }
);}
  



export const getPatchDatasetApiConfigsDatasetNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext> => {

const mutationKey = ['patchDatasetApiConfigsDatasetNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, {name: string;data: PatchDatasetRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchDatasetApiConfigsDatasetNamePatch(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchDatasetApiConfigsDatasetNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>>
    export type PatchDatasetApiConfigsDatasetNamePatchMutationBody = PatchDatasetRequest
    export type PatchDatasetApiConfigsDatasetNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Dataset
 */
export const usePatchDatasetApiConfigsDatasetNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>,
        TError,
        {name: string;data: PatchDatasetRequest},
        TContext
      > => {
      return useMutation(getPatchDatasetApiConfigsDatasetNamePatchMutationOptions(options), queryClient);
    }
    
/**
 * List all backends.
 * @summary List Backends
 */
export type listBackendsApiConfigsBackendGetResponse200 = {
  data: string
  status: 200
}

export type listBackendsApiConfigsBackendGetResponseSuccess = (listBackendsApiConfigsBackendGetResponse200) & {
  headers: Headers;
};
;

export type listBackendsApiConfigsBackendGetResponse = (listBackendsApiConfigsBackendGetResponseSuccess)

export const getListBackendsApiConfigsBackendGetUrl = () => {


  

  return `/api/configs/backend`
}

export const listBackendsApiConfigsBackendGet = async ( options?: RequestInit): Promise<listBackendsApiConfigsBackendGetResponse> => {
  
  return customFetch<listBackendsApiConfigsBackendGetResponse>(getListBackendsApiConfigsBackendGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListBackendsApiConfigsBackendGetQueryKey = () => {
    return [
    `/api/configs/backend`
    ] as const;
    }

    
export const getListBackendsApiConfigsBackendGetQueryOptions = <TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBackendsApiConfigsBackendGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>> = ({ signal }) => listBackendsApiConfigsBackendGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBackendsApiConfigsBackendGetQueryResult = NonNullable<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>>
export type ListBackendsApiConfigsBackendGetQueryError = unknown


export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Backends
 */

export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBackendsApiConfigsBackendGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Get info for a specific backend.
 * @summary Get Backend
 */
export type getBackendApiConfigsBackendNameGetResponse200 = {
  data: string
  status: 200
}

export type getBackendApiConfigsBackendNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getBackendApiConfigsBackendNameGetResponseSuccess = (getBackendApiConfigsBackendNameGetResponse200) & {
  headers: Headers;
};
export type getBackendApiConfigsBackendNameGetResponseError = (getBackendApiConfigsBackendNameGetResponse422) & {
  headers: Headers;
};

export type getBackendApiConfigsBackendNameGetResponse = (getBackendApiConfigsBackendNameGetResponseSuccess | getBackendApiConfigsBackendNameGetResponseError)

export const getGetBackendApiConfigsBackendNameGetUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const getBackendApiConfigsBackendNameGet = async (name: string, options?: RequestInit): Promise<getBackendApiConfigsBackendNameGetResponse> => {
  
  return customFetch<getBackendApiConfigsBackendNameGetResponse>(getGetBackendApiConfigsBackendNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetBackendApiConfigsBackendNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/backend/${name}`
    ] as const;
    }

    
export const getGetBackendApiConfigsBackendNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBackendApiConfigsBackendNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>> = ({ signal }) => getBackendApiConfigsBackendNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBackendApiConfigsBackendNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>>
export type GetBackendApiConfigsBackendNameGetQueryError = HTTPValidationError


export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>,
          TError,
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>,
          TError,
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Backend
 */

export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBackendApiConfigsBackendNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Override the config for a specific backend.
 * @summary Update Backend
 */
export type updateBackendApiConfigsBackendNamePostResponse200 = {
  data: unknown
  status: 200
}

export type updateBackendApiConfigsBackendNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateBackendApiConfigsBackendNamePostResponseSuccess = (updateBackendApiConfigsBackendNamePostResponse200) & {
  headers: Headers;
};
export type updateBackendApiConfigsBackendNamePostResponseError = (updateBackendApiConfigsBackendNamePostResponse422) & {
  headers: Headers;
};

export type updateBackendApiConfigsBackendNamePostResponse = (updateBackendApiConfigsBackendNamePostResponseSuccess | updateBackendApiConfigsBackendNamePostResponseError)

export const getUpdateBackendApiConfigsBackendNamePostUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const updateBackendApiConfigsBackendNamePost = async (name: string,
    postBackendRequest: PostBackendRequest, options?: RequestInit): Promise<updateBackendApiConfigsBackendNamePostResponse> => {
  
  return customFetch<updateBackendApiConfigsBackendNamePostResponse>(getUpdateBackendApiConfigsBackendNamePostUrl(name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postBackendRequest,)
  }
);}
  



export const getUpdateBackendApiConfigsBackendNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext> => {

const mutationKey = ['updateBackendApiConfigsBackendNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, {name: string;data: PostBackendRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  updateBackendApiConfigsBackendNamePost(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBackendApiConfigsBackendNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>>
    export type UpdateBackendApiConfigsBackendNamePostMutationBody = PostBackendRequest
    export type UpdateBackendApiConfigsBackendNamePostMutationError = HTTPValidationError

    /**
 * @summary Update Backend
 */
export const useUpdateBackendApiConfigsBackendNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>,
        TError,
        {name: string;data: PostBackendRequest},
        TContext
      > => {
      return useMutation(getUpdateBackendApiConfigsBackendNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Remove a backend.
 * @summary Delete Backend
 */
export type deleteBackendApiConfigsBackendNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteBackendApiConfigsBackendNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteBackendApiConfigsBackendNameDeleteResponseSuccess = (deleteBackendApiConfigsBackendNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteBackendApiConfigsBackendNameDeleteResponseError = (deleteBackendApiConfigsBackendNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteBackendApiConfigsBackendNameDeleteResponse = (deleteBackendApiConfigsBackendNameDeleteResponseSuccess | deleteBackendApiConfigsBackendNameDeleteResponseError)

export const getDeleteBackendApiConfigsBackendNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/backend/${name}`
}

export const deleteBackendApiConfigsBackendNameDelete = async (name: string,
    deleteBackendRequest: DeleteBackendRequest, options?: RequestInit): Promise<deleteBackendApiConfigsBackendNameDeleteResponse> => {
  
  return customFetch<deleteBackendApiConfigsBackendNameDeleteResponse>(getDeleteBackendApiConfigsBackendNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteBackendRequest,)
  }
);}
  



export const getDeleteBackendApiConfigsBackendNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext> => {

const mutationKey = ['deleteBackendApiConfigsBackendNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, {name: string;data: DeleteBackendRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteBackendApiConfigsBackendNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBackendApiConfigsBackendNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>>
    export type DeleteBackendApiConfigsBackendNameDeleteMutationBody = DeleteBackendRequest
    export type DeleteBackendApiConfigsBackendNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Backend
 */
export const useDeleteBackendApiConfigsBackendNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>,
        TError,
        {name: string;data: DeleteBackendRequest},
        TContext
      > => {
      return useMutation(getDeleteBackendApiConfigsBackendNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all Pools
 * @summary List Pools
 */
export type listPoolsApiConfigsPoolGetResponse200 = {
  data: string
  status: 200
}

export type listPoolsApiConfigsPoolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listPoolsApiConfigsPoolGetResponseSuccess = (listPoolsApiConfigsPoolGetResponse200) & {
  headers: Headers;
};
export type listPoolsApiConfigsPoolGetResponseError = (listPoolsApiConfigsPoolGetResponse422) & {
  headers: Headers;
};

export type listPoolsApiConfigsPoolGetResponse = (listPoolsApiConfigsPoolGetResponseSuccess | listPoolsApiConfigsPoolGetResponseError)

export const getListPoolsApiConfigsPoolGetUrl = (params?: ListPoolsApiConfigsPoolGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool?${stringifiedParams}` : `/api/configs/pool`
}

export const listPoolsApiConfigsPoolGet = async (params?: ListPoolsApiConfigsPoolGetParams, options?: RequestInit): Promise<listPoolsApiConfigsPoolGetResponse> => {
  
  return customFetch<listPoolsApiConfigsPoolGetResponse>(getListPoolsApiConfigsPoolGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListPoolsApiConfigsPoolGetQueryKey = (params?: ListPoolsApiConfigsPoolGetParams,) => {
    return [
    `/api/configs/pool`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListPoolsApiConfigsPoolGetQueryOptions = <TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPoolsApiConfigsPoolGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>> = ({ signal }) => listPoolsApiConfigsPoolGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPoolsApiConfigsPoolGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>>
export type ListPoolsApiConfigsPoolGetQueryError = HTTPValidationError


export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params: undefined |  ListPoolsApiConfigsPoolGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>,
          TError,
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>,
          TError,
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Pools
 */

export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPoolsApiConfigsPoolGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Pool configurations
 * @summary Put Pools
 */
export type putPoolsApiConfigsPoolPutResponse200 = {
  data: unknown
  status: 200
}

export type putPoolsApiConfigsPoolPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPoolsApiConfigsPoolPutResponseSuccess = (putPoolsApiConfigsPoolPutResponse200) & {
  headers: Headers;
};
export type putPoolsApiConfigsPoolPutResponseError = (putPoolsApiConfigsPoolPutResponse422) & {
  headers: Headers;
};

export type putPoolsApiConfigsPoolPutResponse = (putPoolsApiConfigsPoolPutResponseSuccess | putPoolsApiConfigsPoolPutResponseError)

export const getPutPoolsApiConfigsPoolPutUrl = () => {


  

  return `/api/configs/pool`
}

export const putPoolsApiConfigsPoolPut = async (putPoolsRequest: PutPoolsRequest, options?: RequestInit): Promise<putPoolsApiConfigsPoolPutResponse> => {
  
  return customFetch<putPoolsApiConfigsPoolPutResponse>(getPutPoolsApiConfigsPoolPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolsRequest,)
  }
);}
  



export const getPutPoolsApiConfigsPoolPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext> => {

const mutationKey = ['putPoolsApiConfigsPoolPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, {data: PutPoolsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putPoolsApiConfigsPoolPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPoolsApiConfigsPoolPutMutationResult = NonNullable<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>>
    export type PutPoolsApiConfigsPoolPutMutationBody = PutPoolsRequest
    export type PutPoolsApiConfigsPoolPutMutationError = HTTPValidationError

    /**
 * @summary Put Pools
 */
export const usePutPoolsApiConfigsPoolPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>,
        TError,
        {data: PutPoolsRequest},
        TContext
      > => {
      return useMutation(getPutPoolsApiConfigsPoolPutMutationOptions(options), queryClient);
    }
    
/**
 * Read Pool configuration

Return type Any to prevent unwanted artifacts between Pool and PoolEditable outputs
Should return Pool or PoolEditable objects
 * @summary Read Pool
 */
export type readPoolApiConfigsPoolNameGetResponse200 = {
  data: string
  status: 200
}

export type readPoolApiConfigsPoolNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPoolApiConfigsPoolNameGetResponseSuccess = (readPoolApiConfigsPoolNameGetResponse200) & {
  headers: Headers;
};
export type readPoolApiConfigsPoolNameGetResponseError = (readPoolApiConfigsPoolNameGetResponse422) & {
  headers: Headers;
};

export type readPoolApiConfigsPoolNameGetResponse = (readPoolApiConfigsPoolNameGetResponseSuccess | readPoolApiConfigsPoolNameGetResponseError)

export const getReadPoolApiConfigsPoolNameGetUrl = (name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}?${stringifiedParams}` : `/api/configs/pool/${name}`
}

export const readPoolApiConfigsPoolNameGet = async (name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: RequestInit): Promise<readPoolApiConfigsPoolNameGetResponse> => {
  
  return customFetch<readPoolApiConfigsPoolNameGetResponse>(getReadPoolApiConfigsPoolNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadPoolApiConfigsPoolNameGetQueryKey = (name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams,) => {
    return [
    `/api/configs/pool/${name}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getReadPoolApiConfigsPoolNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPoolApiConfigsPoolNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>> = ({ signal }) => readPoolApiConfigsPoolNameGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPoolApiConfigsPoolNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>>
export type ReadPoolApiConfigsPoolNameGetQueryError = HTTPValidationError


export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  ReadPoolApiConfigsPoolNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Pool
 */

export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPoolApiConfigsPoolNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Pool configurations
 * @summary Put Pool
 */
export type putPoolApiConfigsPoolNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPoolApiConfigsPoolNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPoolApiConfigsPoolNamePutResponseSuccess = (putPoolApiConfigsPoolNamePutResponse200) & {
  headers: Headers;
};
export type putPoolApiConfigsPoolNamePutResponseError = (putPoolApiConfigsPoolNamePutResponse422) & {
  headers: Headers;
};

export type putPoolApiConfigsPoolNamePutResponse = (putPoolApiConfigsPoolNamePutResponseSuccess | putPoolApiConfigsPoolNamePutResponseError)

export const getPutPoolApiConfigsPoolNamePutUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const putPoolApiConfigsPoolNamePut = async (name: string,
    putPoolRequest: PutPoolRequest, options?: RequestInit): Promise<putPoolApiConfigsPoolNamePutResponse> => {
  
  return customFetch<putPoolApiConfigsPoolNamePutResponse>(getPutPoolApiConfigsPoolNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolRequest,)
  }
);}
  



export const getPutPoolApiConfigsPoolNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext> => {

const mutationKey = ['putPoolApiConfigsPoolNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, {name: string;data: PutPoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putPoolApiConfigsPoolNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPoolApiConfigsPoolNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>>
    export type PutPoolApiConfigsPoolNamePutMutationBody = PutPoolRequest
    export type PutPoolApiConfigsPoolNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Pool
 */
export const usePutPoolApiConfigsPoolNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>,
        TError,
        {name: string;data: PutPoolRequest},
        TContext
      > => {
      return useMutation(getPutPoolApiConfigsPoolNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete Pool configurations
 * @summary Delete Pool
 */
export type deletePoolApiConfigsPoolNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deletePoolApiConfigsPoolNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deletePoolApiConfigsPoolNameDeleteResponseSuccess = (deletePoolApiConfigsPoolNameDeleteResponse200) & {
  headers: Headers;
};
export type deletePoolApiConfigsPoolNameDeleteResponseError = (deletePoolApiConfigsPoolNameDeleteResponse422) & {
  headers: Headers;
};

export type deletePoolApiConfigsPoolNameDeleteResponse = (deletePoolApiConfigsPoolNameDeleteResponseSuccess | deletePoolApiConfigsPoolNameDeleteResponseError)

export const getDeletePoolApiConfigsPoolNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const deletePoolApiConfigsPoolNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deletePoolApiConfigsPoolNameDeleteResponse> => {
  
  return customFetch<deletePoolApiConfigsPoolNameDeleteResponse>(getDeletePoolApiConfigsPoolNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeletePoolApiConfigsPoolNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deletePoolApiConfigsPoolNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deletePoolApiConfigsPoolNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePoolApiConfigsPoolNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>>
    export type DeletePoolApiConfigsPoolNameDeleteMutationBody = ConfigsRequest
    export type DeletePoolApiConfigsPoolNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Pool
 */
export const useDeletePoolApiConfigsPoolNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeletePoolApiConfigsPoolNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Patch Pool configurations
 * @summary Patch Pool
 */
export type patchPoolApiConfigsPoolNamePatchResponse200 = {
  data: unknown
  status: 200
}

export type patchPoolApiConfigsPoolNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchPoolApiConfigsPoolNamePatchResponseSuccess = (patchPoolApiConfigsPoolNamePatchResponse200) & {
  headers: Headers;
};
export type patchPoolApiConfigsPoolNamePatchResponseError = (patchPoolApiConfigsPoolNamePatchResponse422) & {
  headers: Headers;
};

export type patchPoolApiConfigsPoolNamePatchResponse = (patchPoolApiConfigsPoolNamePatchResponseSuccess | patchPoolApiConfigsPoolNamePatchResponseError)

export const getPatchPoolApiConfigsPoolNamePatchUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}`
}

export const patchPoolApiConfigsPoolNamePatch = async (name: string,
    patchPoolRequest: PatchPoolRequest, options?: RequestInit): Promise<patchPoolApiConfigsPoolNamePatchResponse> => {
  
  return customFetch<patchPoolApiConfigsPoolNamePatchResponse>(getPatchPoolApiConfigsPoolNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchPoolRequest,)
  }
);}
  



export const getPatchPoolApiConfigsPoolNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext> => {

const mutationKey = ['patchPoolApiConfigsPoolNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, {name: string;data: PatchPoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchPoolApiConfigsPoolNamePatch(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchPoolApiConfigsPoolNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>>
    export type PatchPoolApiConfigsPoolNamePatchMutationBody = PatchPoolRequest
    export type PatchPoolApiConfigsPoolNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Pool
 */
export const usePatchPoolApiConfigsPoolNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>,
        TError,
        {name: string;data: PatchPoolRequest},
        TContext
      > => {
      return useMutation(getPatchPoolApiConfigsPoolNamePatchMutationOptions(options), queryClient);
    }
    
/**
 * Rename Pool
 * @summary Rename Pool
 */
export type renamePoolApiConfigsPoolNameRenamePutResponse200 = {
  data: unknown
  status: 200
}

export type renamePoolApiConfigsPoolNameRenamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renamePoolApiConfigsPoolNameRenamePutResponseSuccess = (renamePoolApiConfigsPoolNameRenamePutResponse200) & {
  headers: Headers;
};
export type renamePoolApiConfigsPoolNameRenamePutResponseError = (renamePoolApiConfigsPoolNameRenamePutResponse422) & {
  headers: Headers;
};

export type renamePoolApiConfigsPoolNameRenamePutResponse = (renamePoolApiConfigsPoolNameRenamePutResponseSuccess | renamePoolApiConfigsPoolNameRenamePutResponseError)

export const getRenamePoolApiConfigsPoolNameRenamePutUrl = (name: string,) => {


  

  return `/api/configs/pool/${name}/rename`
}

export const renamePoolApiConfigsPoolNameRenamePut = async (name: string,
    renamePoolRequest: RenamePoolRequest, options?: RequestInit): Promise<renamePoolApiConfigsPoolNameRenamePutResponse> => {
  
  return customFetch<renamePoolApiConfigsPoolNameRenamePutResponse>(getRenamePoolApiConfigsPoolNameRenamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renamePoolRequest,)
  }
);}
  



export const getRenamePoolApiConfigsPoolNameRenamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext> => {

const mutationKey = ['renamePoolApiConfigsPoolNameRenamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, {name: string;data: RenamePoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  renamePoolApiConfigsPoolNameRenamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RenamePoolApiConfigsPoolNameRenamePutMutationResult = NonNullable<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>>
    export type RenamePoolApiConfigsPoolNameRenamePutMutationBody = RenamePoolRequest
    export type RenamePoolApiConfigsPoolNameRenamePutMutationError = HTTPValidationError

    /**
 * @summary Rename Pool
 */
export const useRenamePoolApiConfigsPoolNameRenamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>,
        TError,
        {name: string;data: RenamePoolRequest},
        TContext
      > => {
      return useMutation(getRenamePoolApiConfigsPoolNameRenamePutMutationOptions(options), queryClient);
    }
    
/**
 * List all Platforms

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Dict[str, Platform] or Dict[str, PlatformEditable] objects
 * @summary List Platforms In Pool
 */
export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse200 = {
  data: string
  status: 200
}

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseSuccess = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse200) & {
  headers: Headers;
};
export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseError = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse422) & {
  headers: Headers;
};

export type listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse = (listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseSuccess | listPlatformsInPoolApiConfigsPoolNamePlatformGetResponseError)

export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetUrl = (name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}/platform?${stringifiedParams}` : `/api/configs/pool/${name}/platform`
}

export const listPlatformsInPoolApiConfigsPoolNamePlatformGet = async (name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: RequestInit): Promise<listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse> => {
  
  return customFetch<listPlatformsInPoolApiConfigsPoolNamePlatformGetResponse>(getListPlatformsInPoolApiConfigsPoolNamePlatformGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryKey = (name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams,) => {
    return [
    `/api/configs/pool/${name}/platform`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryOptions = <TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>> = ({ signal }) => listPlatformsInPoolApiConfigsPoolNamePlatformGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>>
export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryError = HTTPValidationError


export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>,
          TError,
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>,
          TError,
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Platforms In Pool
 */

export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Read Platform

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Platform or PlatformEditable objects
 * @summary Read Platform In Pool
 */
export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse200 = {
  data: string
  status: 200
}

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseSuccess = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse200) & {
  headers: Headers;
};
export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseError = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse422) & {
  headers: Headers;
};

export type readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse = (readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseSuccess | readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponseError)

export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetUrl = (name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/pool/${name}/platform/${platformName}?${stringifiedParams}` : `/api/configs/pool/${name}/platform/${platformName}`
}

export const readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet = async (name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: RequestInit): Promise<readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse> => {
  
  return customFetch<readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetResponse>(getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetUrl(name,platformName,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryKey = (name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams,) => {
    return [
    `/api/configs/pool/${name}/platform/${platformName}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryKey(name,platformName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>> = ({ signal }) => readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet(name,platformName,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name && platformName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>>
export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryError = HTTPValidationError


export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params: undefined |  ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Platform In Pool
 */

export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryOptions(name,platformName,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Platform configurations
 * @summary Put Platform In Pool
 */
export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseSuccess = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse200) & {
  headers: Headers;
};
export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseError = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse422) & {
  headers: Headers;
};

export type putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse = (putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseSuccess | putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponseError)

export const getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutUrl = (name: string,
    platformName: string,) => {


  

  return `/api/configs/pool/${name}/platform/${platformName}`
}

export const putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut = async (name: string,
    platformName: string,
    putPoolPlatformRequest: PutPoolPlatformRequest, options?: RequestInit): Promise<putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse> => {
  
  return customFetch<putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutResponse>(getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutUrl(name,platformName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPoolPlatformRequest,)
  }
);}
  



export const getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext> => {

const mutationKey = ['putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, {name: string;platformName: string;data: PutPoolPlatformRequest}> = (props) => {
          const {name,platformName,data} = props ?? {};

          return  putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut(name,platformName,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>>
    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationBody = PutPoolPlatformRequest
    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Platform In Pool
 */
export const usePutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>,
        TError,
        {name: string;platformName: string;data: PutPoolPlatformRequest},
        TContext
      > => {
      return useMutation(getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Rename Platform
 * @summary Rename Platform In Pool
 */
export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse200 = {
  data: unknown
  status: 200
}

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseSuccess = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse200) & {
  headers: Headers;
};
export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseError = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse422) & {
  headers: Headers;
};

export type renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse = (renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseSuccess | renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponseError)

export const getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutUrl = (name: string,
    platformName: string,) => {


  

  return `/api/configs/pool/${name}/platform/${platformName}/rename`
}

export const renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut = async (name: string,
    platformName: string,
    renamePoolPlatformRequest: RenamePoolPlatformRequest, options?: RequestInit): Promise<renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse> => {
  
  return customFetch<renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutResponse>(getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutUrl(name,platformName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renamePoolPlatformRequest,)
  }
);}
  



export const getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext> => {

const mutationKey = ['renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, {name: string;platformName: string;data: RenamePoolPlatformRequest}> = (props) => {
          const {name,platformName,data} = props ?? {};

          return  renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut(name,platformName,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationResult = NonNullable<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>>
    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationBody = RenamePoolPlatformRequest
    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationError = HTTPValidationError

    /**
 * @summary Rename Platform In Pool
 */
export const useRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>,
        TError,
        {name: string;platformName: string;data: RenamePoolPlatformRequest},
        TContext
      > => {
      return useMutation(getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationOptions(options), queryClient);
    }
    
/**
 * List all Pod Template configurations
 * @summary List Pod Templates
 */
export type listPodTemplatesApiConfigsPodTemplateGetResponse200 = {
  data: string
  status: 200
}

export type listPodTemplatesApiConfigsPodTemplateGetResponseSuccess = (listPodTemplatesApiConfigsPodTemplateGetResponse200) & {
  headers: Headers;
};
;

export type listPodTemplatesApiConfigsPodTemplateGetResponse = (listPodTemplatesApiConfigsPodTemplateGetResponseSuccess)

export const getListPodTemplatesApiConfigsPodTemplateGetUrl = () => {


  

  return `/api/configs/pod_template`
}

export const listPodTemplatesApiConfigsPodTemplateGet = async ( options?: RequestInit): Promise<listPodTemplatesApiConfigsPodTemplateGetResponse> => {
  
  return customFetch<listPodTemplatesApiConfigsPodTemplateGetResponse>(getListPodTemplatesApiConfigsPodTemplateGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListPodTemplatesApiConfigsPodTemplateGetQueryKey = () => {
    return [
    `/api/configs/pod_template`
    ] as const;
    }

    
export const getListPodTemplatesApiConfigsPodTemplateGetQueryOptions = <TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPodTemplatesApiConfigsPodTemplateGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>> = ({ signal }) => listPodTemplatesApiConfigsPodTemplateGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPodTemplatesApiConfigsPodTemplateGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>>
export type ListPodTemplatesApiConfigsPodTemplateGetQueryError = unknown


export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Pod Templates
 */

export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPodTemplatesApiConfigsPodTemplateGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Set Dict of Pod Templates configurations
 * @summary Put Pod Templates
 */
export type putPodTemplatesApiConfigsPodTemplatePutResponse200 = {
  data: unknown
  status: 200
}

export type putPodTemplatesApiConfigsPodTemplatePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPodTemplatesApiConfigsPodTemplatePutResponseSuccess = (putPodTemplatesApiConfigsPodTemplatePutResponse200) & {
  headers: Headers;
};
export type putPodTemplatesApiConfigsPodTemplatePutResponseError = (putPodTemplatesApiConfigsPodTemplatePutResponse422) & {
  headers: Headers;
};

export type putPodTemplatesApiConfigsPodTemplatePutResponse = (putPodTemplatesApiConfigsPodTemplatePutResponseSuccess | putPodTemplatesApiConfigsPodTemplatePutResponseError)

export const getPutPodTemplatesApiConfigsPodTemplatePutUrl = () => {


  

  return `/api/configs/pod_template`
}

export const putPodTemplatesApiConfigsPodTemplatePut = async (putPodTemplatesRequest: PutPodTemplatesRequest, options?: RequestInit): Promise<putPodTemplatesApiConfigsPodTemplatePutResponse> => {
  
  return customFetch<putPodTemplatesApiConfigsPodTemplatePutResponse>(getPutPodTemplatesApiConfigsPodTemplatePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPodTemplatesRequest,)
  }
);}
  



export const getPutPodTemplatesApiConfigsPodTemplatePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext> => {

const mutationKey = ['putPodTemplatesApiConfigsPodTemplatePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, {data: PutPodTemplatesRequest}> = (props) => {
          const {data} = props ?? {};

          return  putPodTemplatesApiConfigsPodTemplatePut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPodTemplatesApiConfigsPodTemplatePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>>
    export type PutPodTemplatesApiConfigsPodTemplatePutMutationBody = PutPodTemplatesRequest
    export type PutPodTemplatesApiConfigsPodTemplatePutMutationError = HTTPValidationError

    /**
 * @summary Put Pod Templates
 */
export const usePutPodTemplatesApiConfigsPodTemplatePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>,
        TError,
        {data: PutPodTemplatesRequest},
        TContext
      > => {
      return useMutation(getPutPodTemplatesApiConfigsPodTemplatePutMutationOptions(options), queryClient);
    }
    
/**
 * Read Pod Template configurations
 * @summary Read Pod Template
 */
export type readPodTemplateApiConfigsPodTemplateNameGetResponse200 = {
  data: string
  status: 200
}

export type readPodTemplateApiConfigsPodTemplateNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readPodTemplateApiConfigsPodTemplateNameGetResponseSuccess = (readPodTemplateApiConfigsPodTemplateNameGetResponse200) & {
  headers: Headers;
};
export type readPodTemplateApiConfigsPodTemplateNameGetResponseError = (readPodTemplateApiConfigsPodTemplateNameGetResponse422) & {
  headers: Headers;
};

export type readPodTemplateApiConfigsPodTemplateNameGetResponse = (readPodTemplateApiConfigsPodTemplateNameGetResponseSuccess | readPodTemplateApiConfigsPodTemplateNameGetResponseError)

export const getReadPodTemplateApiConfigsPodTemplateNameGetUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const readPodTemplateApiConfigsPodTemplateNameGet = async (name: string, options?: RequestInit): Promise<readPodTemplateApiConfigsPodTemplateNameGetResponse> => {
  
  return customFetch<readPodTemplateApiConfigsPodTemplateNameGetResponse>(getReadPodTemplateApiConfigsPodTemplateNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadPodTemplateApiConfigsPodTemplateNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/pod_template/${name}`
    ] as const;
    }

    
export const getReadPodTemplateApiConfigsPodTemplateNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPodTemplateApiConfigsPodTemplateNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>> = ({ signal }) => readPodTemplateApiConfigsPodTemplateNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPodTemplateApiConfigsPodTemplateNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>>
export type ReadPodTemplateApiConfigsPodTemplateNameGetQueryError = HTTPValidationError


export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Pod Template
 */

export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPodTemplateApiConfigsPodTemplateNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Pod Template configurations
 * @summary Put Pod Template
 */
export type putPodTemplateApiConfigsPodTemplateNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putPodTemplateApiConfigsPodTemplateNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putPodTemplateApiConfigsPodTemplateNamePutResponseSuccess = (putPodTemplateApiConfigsPodTemplateNamePutResponse200) & {
  headers: Headers;
};
export type putPodTemplateApiConfigsPodTemplateNamePutResponseError = (putPodTemplateApiConfigsPodTemplateNamePutResponse422) & {
  headers: Headers;
};

export type putPodTemplateApiConfigsPodTemplateNamePutResponse = (putPodTemplateApiConfigsPodTemplateNamePutResponseSuccess | putPodTemplateApiConfigsPodTemplateNamePutResponseError)

export const getPutPodTemplateApiConfigsPodTemplateNamePutUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const putPodTemplateApiConfigsPodTemplateNamePut = async (name: string,
    putPodTemplateRequest: PutPodTemplateRequest, options?: RequestInit): Promise<putPodTemplateApiConfigsPodTemplateNamePutResponse> => {
  
  return customFetch<putPodTemplateApiConfigsPodTemplateNamePutResponse>(getPutPodTemplateApiConfigsPodTemplateNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putPodTemplateRequest,)
  }
);}
  



export const getPutPodTemplateApiConfigsPodTemplateNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext> => {

const mutationKey = ['putPodTemplateApiConfigsPodTemplateNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, {name: string;data: PutPodTemplateRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putPodTemplateApiConfigsPodTemplateNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>>
    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationBody = PutPodTemplateRequest
    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Pod Template
 */
export const usePutPodTemplateApiConfigsPodTemplateNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>,
        TError,
        {name: string;data: PutPodTemplateRequest},
        TContext
      > => {
      return useMutation(getPutPodTemplateApiConfigsPodTemplateNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete Pod Template configurations
 * @summary Delete Pod Template
 */
export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponseSuccess = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponse200) & {
  headers: Headers;
};
export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponseError = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponse422) & {
  headers: Headers;
};

export type deletePodTemplateApiConfigsPodTemplateNameDeleteResponse = (deletePodTemplateApiConfigsPodTemplateNameDeleteResponseSuccess | deletePodTemplateApiConfigsPodTemplateNameDeleteResponseError)

export const getDeletePodTemplateApiConfigsPodTemplateNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/pod_template/${name}`
}

export const deletePodTemplateApiConfigsPodTemplateNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deletePodTemplateApiConfigsPodTemplateNameDeleteResponse> => {
  
  return customFetch<deletePodTemplateApiConfigsPodTemplateNameDeleteResponse>(getDeletePodTemplateApiConfigsPodTemplateNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeletePodTemplateApiConfigsPodTemplateNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deletePodTemplateApiConfigsPodTemplateNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deletePodTemplateApiConfigsPodTemplateNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>>
    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationBody = ConfigsRequest
    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Pod Template
 */
export const useDeletePodTemplateApiConfigsPodTemplateNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeletePodTemplateApiConfigsPodTemplateNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all Group Template configurations
 * @summary List Group Templates
 */
export type listGroupTemplatesApiConfigsGroupTemplateGetResponse200 = {
  data: string
  status: 200
}

export type listGroupTemplatesApiConfigsGroupTemplateGetResponseSuccess = (listGroupTemplatesApiConfigsGroupTemplateGetResponse200) & {
  headers: Headers;
};
;

export type listGroupTemplatesApiConfigsGroupTemplateGetResponse = (listGroupTemplatesApiConfigsGroupTemplateGetResponseSuccess)

export const getListGroupTemplatesApiConfigsGroupTemplateGetUrl = () => {


  

  return `/api/configs/group_template`
}

export const listGroupTemplatesApiConfigsGroupTemplateGet = async ( options?: RequestInit): Promise<listGroupTemplatesApiConfigsGroupTemplateGetResponse> => {
  
  return customFetch<listGroupTemplatesApiConfigsGroupTemplateGetResponse>(getListGroupTemplatesApiConfigsGroupTemplateGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListGroupTemplatesApiConfigsGroupTemplateGetQueryKey = () => {
    return [
    `/api/configs/group_template`
    ] as const;
    }

    
export const getListGroupTemplatesApiConfigsGroupTemplateGetQueryOptions = <TData = Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListGroupTemplatesApiConfigsGroupTemplateGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>> = ({ signal }) => listGroupTemplatesApiConfigsGroupTemplateGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListGroupTemplatesApiConfigsGroupTemplateGetQueryResult = NonNullable<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>>
export type ListGroupTemplatesApiConfigsGroupTemplateGetQueryError = unknown


export function useListGroupTemplatesApiConfigsGroupTemplateGet<TData = Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListGroupTemplatesApiConfigsGroupTemplateGet<TData = Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListGroupTemplatesApiConfigsGroupTemplateGet<TData = Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Group Templates
 */

export function useListGroupTemplatesApiConfigsGroupTemplateGet<TData = Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGroupTemplatesApiConfigsGroupTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListGroupTemplatesApiConfigsGroupTemplateGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Set Dict of Group Templates configurations
 * @summary Put Group Templates
 */
export type putGroupTemplatesApiConfigsGroupTemplatePutResponse200 = {
  data: unknown
  status: 200
}

export type putGroupTemplatesApiConfigsGroupTemplatePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putGroupTemplatesApiConfigsGroupTemplatePutResponseSuccess = (putGroupTemplatesApiConfigsGroupTemplatePutResponse200) & {
  headers: Headers;
};
export type putGroupTemplatesApiConfigsGroupTemplatePutResponseError = (putGroupTemplatesApiConfigsGroupTemplatePutResponse422) & {
  headers: Headers;
};

export type putGroupTemplatesApiConfigsGroupTemplatePutResponse = (putGroupTemplatesApiConfigsGroupTemplatePutResponseSuccess | putGroupTemplatesApiConfigsGroupTemplatePutResponseError)

export const getPutGroupTemplatesApiConfigsGroupTemplatePutUrl = () => {


  

  return `/api/configs/group_template`
}

export const putGroupTemplatesApiConfigsGroupTemplatePut = async (putGroupTemplatesRequest: PutGroupTemplatesRequest, options?: RequestInit): Promise<putGroupTemplatesApiConfigsGroupTemplatePutResponse> => {
  
  return customFetch<putGroupTemplatesApiConfigsGroupTemplatePutResponse>(getPutGroupTemplatesApiConfigsGroupTemplatePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putGroupTemplatesRequest,)
  }
);}
  



export const getPutGroupTemplatesApiConfigsGroupTemplatePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>, TError,{data: PutGroupTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>, TError,{data: PutGroupTemplatesRequest}, TContext> => {

const mutationKey = ['putGroupTemplatesApiConfigsGroupTemplatePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>, {data: PutGroupTemplatesRequest}> = (props) => {
          const {data} = props ?? {};

          return  putGroupTemplatesApiConfigsGroupTemplatePut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutGroupTemplatesApiConfigsGroupTemplatePutMutationResult = NonNullable<Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>>
    export type PutGroupTemplatesApiConfigsGroupTemplatePutMutationBody = PutGroupTemplatesRequest
    export type PutGroupTemplatesApiConfigsGroupTemplatePutMutationError = HTTPValidationError

    /**
 * @summary Put Group Templates
 */
export const usePutGroupTemplatesApiConfigsGroupTemplatePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>, TError,{data: PutGroupTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putGroupTemplatesApiConfigsGroupTemplatePut>>,
        TError,
        {data: PutGroupTemplatesRequest},
        TContext
      > => {
      return useMutation(getPutGroupTemplatesApiConfigsGroupTemplatePutMutationOptions(options), queryClient);
    }
    
/**
 * Read Group Template configurations
 * @summary Read Group Template
 */
export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse200 = {
  data: string
  status: 200
}

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponseSuccess = (readGroupTemplateApiConfigsGroupTemplateNameGetResponse200) & {
  headers: Headers;
};
export type readGroupTemplateApiConfigsGroupTemplateNameGetResponseError = (readGroupTemplateApiConfigsGroupTemplateNameGetResponse422) & {
  headers: Headers;
};

export type readGroupTemplateApiConfigsGroupTemplateNameGetResponse = (readGroupTemplateApiConfigsGroupTemplateNameGetResponseSuccess | readGroupTemplateApiConfigsGroupTemplateNameGetResponseError)

export const getReadGroupTemplateApiConfigsGroupTemplateNameGetUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const readGroupTemplateApiConfigsGroupTemplateNameGet = async (name: string, options?: RequestInit): Promise<readGroupTemplateApiConfigsGroupTemplateNameGetResponse> => {
  
  return customFetch<readGroupTemplateApiConfigsGroupTemplateNameGetResponse>(getReadGroupTemplateApiConfigsGroupTemplateNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadGroupTemplateApiConfigsGroupTemplateNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/group_template/${name}`
    ] as const;
    }

    
export const getReadGroupTemplateApiConfigsGroupTemplateNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadGroupTemplateApiConfigsGroupTemplateNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>> = ({ signal }) => readGroupTemplateApiConfigsGroupTemplateNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadGroupTemplateApiConfigsGroupTemplateNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>>
export type ReadGroupTemplateApiConfigsGroupTemplateNameGetQueryError = HTTPValidationError


export function useReadGroupTemplateApiConfigsGroupTemplateNameGet<TData = Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadGroupTemplateApiConfigsGroupTemplateNameGet<TData = Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadGroupTemplateApiConfigsGroupTemplateNameGet<TData = Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Group Template
 */

export function useReadGroupTemplateApiConfigsGroupTemplateNameGet<TData = Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readGroupTemplateApiConfigsGroupTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadGroupTemplateApiConfigsGroupTemplateNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Group Template configurations
 * @summary Put Group Template
 */
export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponseSuccess = (putGroupTemplateApiConfigsGroupTemplateNamePutResponse200) & {
  headers: Headers;
};
export type putGroupTemplateApiConfigsGroupTemplateNamePutResponseError = (putGroupTemplateApiConfigsGroupTemplateNamePutResponse422) & {
  headers: Headers;
};

export type putGroupTemplateApiConfigsGroupTemplateNamePutResponse = (putGroupTemplateApiConfigsGroupTemplateNamePutResponseSuccess | putGroupTemplateApiConfigsGroupTemplateNamePutResponseError)

export const getPutGroupTemplateApiConfigsGroupTemplateNamePutUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const putGroupTemplateApiConfigsGroupTemplateNamePut = async (name: string,
    putGroupTemplateRequest: PutGroupTemplateRequest, options?: RequestInit): Promise<putGroupTemplateApiConfigsGroupTemplateNamePutResponse> => {
  
  return customFetch<putGroupTemplateApiConfigsGroupTemplateNamePutResponse>(getPutGroupTemplateApiConfigsGroupTemplateNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putGroupTemplateRequest,)
  }
);}
  



export const getPutGroupTemplateApiConfigsGroupTemplateNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>, TError,{name: string;data: PutGroupTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>, TError,{name: string;data: PutGroupTemplateRequest}, TContext> => {

const mutationKey = ['putGroupTemplateApiConfigsGroupTemplateNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>, {name: string;data: PutGroupTemplateRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putGroupTemplateApiConfigsGroupTemplateNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutGroupTemplateApiConfigsGroupTemplateNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>>
    export type PutGroupTemplateApiConfigsGroupTemplateNamePutMutationBody = PutGroupTemplateRequest
    export type PutGroupTemplateApiConfigsGroupTemplateNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Group Template
 */
export const usePutGroupTemplateApiConfigsGroupTemplateNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>, TError,{name: string;data: PutGroupTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putGroupTemplateApiConfigsGroupTemplateNamePut>>,
        TError,
        {name: string;data: PutGroupTemplateRequest},
        TContext
      > => {
      return useMutation(getPutGroupTemplateApiConfigsGroupTemplateNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete Group Template configurations
 * @summary Delete Group Template
 */
export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseSuccess = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseError = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse = (deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseSuccess | deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponseError)

export const getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/group_template/${name}`
}

export const deleteGroupTemplateApiConfigsGroupTemplateNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse> => {
  
  return customFetch<deleteGroupTemplateApiConfigsGroupTemplateNameDeleteResponse>(getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteGroupTemplateApiConfigsGroupTemplateNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteGroupTemplateApiConfigsGroupTemplateNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>>
    export type DeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMutationBody = ConfigsRequest
    export type DeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Group Template
 */
export const useDeleteGroupTemplateApiConfigsGroupTemplateNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroupTemplateApiConfigsGroupTemplateNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeleteGroupTemplateApiConfigsGroupTemplateNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all Resource Validation configurations
 * @summary List Resource Validations
 */
export type listResourceValidationsApiConfigsResourceValidationGetResponse200 = {
  data: string
  status: 200
}

export type listResourceValidationsApiConfigsResourceValidationGetResponseSuccess = (listResourceValidationsApiConfigsResourceValidationGetResponse200) & {
  headers: Headers;
};
;

export type listResourceValidationsApiConfigsResourceValidationGetResponse = (listResourceValidationsApiConfigsResourceValidationGetResponseSuccess)

export const getListResourceValidationsApiConfigsResourceValidationGetUrl = () => {


  

  return `/api/configs/resource_validation`
}

export const listResourceValidationsApiConfigsResourceValidationGet = async ( options?: RequestInit): Promise<listResourceValidationsApiConfigsResourceValidationGetResponse> => {
  
  return customFetch<listResourceValidationsApiConfigsResourceValidationGetResponse>(getListResourceValidationsApiConfigsResourceValidationGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListResourceValidationsApiConfigsResourceValidationGetQueryKey = () => {
    return [
    `/api/configs/resource_validation`
    ] as const;
    }

    
export const getListResourceValidationsApiConfigsResourceValidationGetQueryOptions = <TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListResourceValidationsApiConfigsResourceValidationGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>> = ({ signal }) => listResourceValidationsApiConfigsResourceValidationGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListResourceValidationsApiConfigsResourceValidationGetQueryResult = NonNullable<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>>
export type ListResourceValidationsApiConfigsResourceValidationGetQueryError = unknown


export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>,
          TError,
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>,
          TError,
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Resource Validations
 */

export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListResourceValidationsApiConfigsResourceValidationGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Resource Validation configurations
 * @summary Put Resource Validations
 */
export type putResourceValidationsApiConfigsResourceValidationPutResponse200 = {
  data: unknown
  status: 200
}

export type putResourceValidationsApiConfigsResourceValidationPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putResourceValidationsApiConfigsResourceValidationPutResponseSuccess = (putResourceValidationsApiConfigsResourceValidationPutResponse200) & {
  headers: Headers;
};
export type putResourceValidationsApiConfigsResourceValidationPutResponseError = (putResourceValidationsApiConfigsResourceValidationPutResponse422) & {
  headers: Headers;
};

export type putResourceValidationsApiConfigsResourceValidationPutResponse = (putResourceValidationsApiConfigsResourceValidationPutResponseSuccess | putResourceValidationsApiConfigsResourceValidationPutResponseError)

export const getPutResourceValidationsApiConfigsResourceValidationPutUrl = () => {


  

  return `/api/configs/resource_validation`
}

export const putResourceValidationsApiConfigsResourceValidationPut = async (putResourceValidationsRequest: PutResourceValidationsRequest, options?: RequestInit): Promise<putResourceValidationsApiConfigsResourceValidationPutResponse> => {
  
  return customFetch<putResourceValidationsApiConfigsResourceValidationPutResponse>(getPutResourceValidationsApiConfigsResourceValidationPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putResourceValidationsRequest,)
  }
);}
  



export const getPutResourceValidationsApiConfigsResourceValidationPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext> => {

const mutationKey = ['putResourceValidationsApiConfigsResourceValidationPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, {data: PutResourceValidationsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putResourceValidationsApiConfigsResourceValidationPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutResourceValidationsApiConfigsResourceValidationPutMutationResult = NonNullable<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>>
    export type PutResourceValidationsApiConfigsResourceValidationPutMutationBody = PutResourceValidationsRequest
    export type PutResourceValidationsApiConfigsResourceValidationPutMutationError = HTTPValidationError

    /**
 * @summary Put Resource Validations
 */
export const usePutResourceValidationsApiConfigsResourceValidationPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>,
        TError,
        {data: PutResourceValidationsRequest},
        TContext
      > => {
      return useMutation(getPutResourceValidationsApiConfigsResourceValidationPutMutationOptions(options), queryClient);
    }
    
/**
 * Read Resource Validation configurations
 * @summary Read Resource Validation
 */
export type readResourceValidationApiConfigsResourceValidationNameGetResponse200 = {
  data: string
  status: 200
}

export type readResourceValidationApiConfigsResourceValidationNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readResourceValidationApiConfigsResourceValidationNameGetResponseSuccess = (readResourceValidationApiConfigsResourceValidationNameGetResponse200) & {
  headers: Headers;
};
export type readResourceValidationApiConfigsResourceValidationNameGetResponseError = (readResourceValidationApiConfigsResourceValidationNameGetResponse422) & {
  headers: Headers;
};

export type readResourceValidationApiConfigsResourceValidationNameGetResponse = (readResourceValidationApiConfigsResourceValidationNameGetResponseSuccess | readResourceValidationApiConfigsResourceValidationNameGetResponseError)

export const getReadResourceValidationApiConfigsResourceValidationNameGetUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const readResourceValidationApiConfigsResourceValidationNameGet = async (name: string, options?: RequestInit): Promise<readResourceValidationApiConfigsResourceValidationNameGetResponse> => {
  
  return customFetch<readResourceValidationApiConfigsResourceValidationNameGetResponse>(getReadResourceValidationApiConfigsResourceValidationNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadResourceValidationApiConfigsResourceValidationNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/resource_validation/${name}`
    ] as const;
    }

    
export const getReadResourceValidationApiConfigsResourceValidationNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadResourceValidationApiConfigsResourceValidationNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>> = ({ signal }) => readResourceValidationApiConfigsResourceValidationNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadResourceValidationApiConfigsResourceValidationNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>>
export type ReadResourceValidationApiConfigsResourceValidationNameGetQueryError = HTTPValidationError


export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>,
          TError,
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>,
          TError,
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Resource Validation
 */

export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadResourceValidationApiConfigsResourceValidationNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Resource Validation configurations
 * @summary Put Resource Validation
 */
export type putResourceValidationApiConfigsResourceValidationNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putResourceValidationApiConfigsResourceValidationNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putResourceValidationApiConfigsResourceValidationNamePutResponseSuccess = (putResourceValidationApiConfigsResourceValidationNamePutResponse200) & {
  headers: Headers;
};
export type putResourceValidationApiConfigsResourceValidationNamePutResponseError = (putResourceValidationApiConfigsResourceValidationNamePutResponse422) & {
  headers: Headers;
};

export type putResourceValidationApiConfigsResourceValidationNamePutResponse = (putResourceValidationApiConfigsResourceValidationNamePutResponseSuccess | putResourceValidationApiConfigsResourceValidationNamePutResponseError)

export const getPutResourceValidationApiConfigsResourceValidationNamePutUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const putResourceValidationApiConfigsResourceValidationNamePut = async (name: string,
    putResourceValidationRequest: PutResourceValidationRequest, options?: RequestInit): Promise<putResourceValidationApiConfigsResourceValidationNamePutResponse> => {
  
  return customFetch<putResourceValidationApiConfigsResourceValidationNamePutResponse>(getPutResourceValidationApiConfigsResourceValidationNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putResourceValidationRequest,)
  }
);}
  



export const getPutResourceValidationApiConfigsResourceValidationNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext> => {

const mutationKey = ['putResourceValidationApiConfigsResourceValidationNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, {name: string;data: PutResourceValidationRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putResourceValidationApiConfigsResourceValidationNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>>
    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationBody = PutResourceValidationRequest
    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Resource Validation
 */
export const usePutResourceValidationApiConfigsResourceValidationNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>,
        TError,
        {name: string;data: PutResourceValidationRequest},
        TContext
      > => {
      return useMutation(getPutResourceValidationApiConfigsResourceValidationNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete Resource Validation configurations
 * @summary Delete Resource Validation
 */
export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseSuccess = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseError = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse = (deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseSuccess | deleteResourceValidationApiConfigsResourceValidationNameDeleteResponseError)

export const getDeleteResourceValidationApiConfigsResourceValidationNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/resource_validation/${name}`
}

export const deleteResourceValidationApiConfigsResourceValidationNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse> => {
  
  return customFetch<deleteResourceValidationApiConfigsResourceValidationNameDeleteResponse>(getDeleteResourceValidationApiConfigsResourceValidationNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteResourceValidationApiConfigsResourceValidationNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteResourceValidationApiConfigsResourceValidationNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>>
    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationBody = ConfigsRequest
    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Resource Validation
 */
export const useDeleteResourceValidationApiConfigsResourceValidationNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all Roles
 * @summary List Roles
 */
export type listRolesApiConfigsRoleGetResponse200 = {
  data: string
  status: 200
}

export type listRolesApiConfigsRoleGetResponseSuccess = (listRolesApiConfigsRoleGetResponse200) & {
  headers: Headers;
};
;

export type listRolesApiConfigsRoleGetResponse = (listRolesApiConfigsRoleGetResponseSuccess)

export const getListRolesApiConfigsRoleGetUrl = () => {


  

  return `/api/configs/role`
}

export const listRolesApiConfigsRoleGet = async ( options?: RequestInit): Promise<listRolesApiConfigsRoleGetResponse> => {
  
  return customFetch<listRolesApiConfigsRoleGetResponse>(getListRolesApiConfigsRoleGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListRolesApiConfigsRoleGetQueryKey = () => {
    return [
    `/api/configs/role`
    ] as const;
    }

    
export const getListRolesApiConfigsRoleGetQueryOptions = <TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRolesApiConfigsRoleGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>> = ({ signal }) => listRolesApiConfigsRoleGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListRolesApiConfigsRoleGetQueryResult = NonNullable<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>>
export type ListRolesApiConfigsRoleGetQueryError = unknown


export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>,
          TError,
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>,
          TError,
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Roles
 */

export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListRolesApiConfigsRoleGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put Roles
 * @summary Put Roles
 */
export type putRolesApiConfigsRolePutResponse200 = {
  data: unknown
  status: 200
}

export type putRolesApiConfigsRolePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putRolesApiConfigsRolePutResponseSuccess = (putRolesApiConfigsRolePutResponse200) & {
  headers: Headers;
};
export type putRolesApiConfigsRolePutResponseError = (putRolesApiConfigsRolePutResponse422) & {
  headers: Headers;
};

export type putRolesApiConfigsRolePutResponse = (putRolesApiConfigsRolePutResponseSuccess | putRolesApiConfigsRolePutResponseError)

export const getPutRolesApiConfigsRolePutUrl = () => {


  

  return `/api/configs/role`
}

export const putRolesApiConfigsRolePut = async (putRolesRequest: PutRolesRequest, options?: RequestInit): Promise<putRolesApiConfigsRolePutResponse> => {
  
  return customFetch<putRolesApiConfigsRolePutResponse>(getPutRolesApiConfigsRolePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putRolesRequest,)
  }
);}
  



export const getPutRolesApiConfigsRolePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext> => {

const mutationKey = ['putRolesApiConfigsRolePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, {data: PutRolesRequest}> = (props) => {
          const {data} = props ?? {};

          return  putRolesApiConfigsRolePut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutRolesApiConfigsRolePutMutationResult = NonNullable<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>>
    export type PutRolesApiConfigsRolePutMutationBody = PutRolesRequest
    export type PutRolesApiConfigsRolePutMutationError = HTTPValidationError

    /**
 * @summary Put Roles
 */
export const usePutRolesApiConfigsRolePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>,
        TError,
        {data: PutRolesRequest},
        TContext
      > => {
      return useMutation(getPutRolesApiConfigsRolePutMutationOptions(options), queryClient);
    }
    
/**
 * Read Role
 * @summary Read Role
 */
export type readRoleApiConfigsRoleNameGetResponse200 = {
  data: string
  status: 200
}

export type readRoleApiConfigsRoleNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readRoleApiConfigsRoleNameGetResponseSuccess = (readRoleApiConfigsRoleNameGetResponse200) & {
  headers: Headers;
};
export type readRoleApiConfigsRoleNameGetResponseError = (readRoleApiConfigsRoleNameGetResponse422) & {
  headers: Headers;
};

export type readRoleApiConfigsRoleNameGetResponse = (readRoleApiConfigsRoleNameGetResponseSuccess | readRoleApiConfigsRoleNameGetResponseError)

export const getReadRoleApiConfigsRoleNameGetUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const readRoleApiConfigsRoleNameGet = async (name: string, options?: RequestInit): Promise<readRoleApiConfigsRoleNameGetResponse> => {
  
  return customFetch<readRoleApiConfigsRoleNameGetResponse>(getReadRoleApiConfigsRoleNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadRoleApiConfigsRoleNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/role/${name}`
    ] as const;
    }

    
export const getReadRoleApiConfigsRoleNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoleApiConfigsRoleNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>> = ({ signal }) => readRoleApiConfigsRoleNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoleApiConfigsRoleNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>>
export type ReadRoleApiConfigsRoleNameGetQueryError = HTTPValidationError


export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>,
          TError,
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>,
          TError,
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Role
 */

export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoleApiConfigsRoleNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Patch Role configurations
 * @summary Put Role
 */
export type putRoleApiConfigsRoleNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putRoleApiConfigsRoleNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putRoleApiConfigsRoleNamePutResponseSuccess = (putRoleApiConfigsRoleNamePutResponse200) & {
  headers: Headers;
};
export type putRoleApiConfigsRoleNamePutResponseError = (putRoleApiConfigsRoleNamePutResponse422) & {
  headers: Headers;
};

export type putRoleApiConfigsRoleNamePutResponse = (putRoleApiConfigsRoleNamePutResponseSuccess | putRoleApiConfigsRoleNamePutResponseError)

export const getPutRoleApiConfigsRoleNamePutUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const putRoleApiConfigsRoleNamePut = async (name: string,
    putRoleRequest: PutRoleRequest, options?: RequestInit): Promise<putRoleApiConfigsRoleNamePutResponse> => {
  
  return customFetch<putRoleApiConfigsRoleNamePutResponse>(getPutRoleApiConfigsRoleNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putRoleRequest,)
  }
);}
  



export const getPutRoleApiConfigsRoleNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext> => {

const mutationKey = ['putRoleApiConfigsRoleNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, {name: string;data: PutRoleRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putRoleApiConfigsRoleNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutRoleApiConfigsRoleNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>>
    export type PutRoleApiConfigsRoleNamePutMutationBody = PutRoleRequest
    export type PutRoleApiConfigsRoleNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Role
 */
export const usePutRoleApiConfigsRoleNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>,
        TError,
        {name: string;data: PutRoleRequest},
        TContext
      > => {
      return useMutation(getPutRoleApiConfigsRoleNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete Role
 * @summary Delete Role
 */
export type deleteRoleApiConfigsRoleNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteRoleApiConfigsRoleNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteRoleApiConfigsRoleNameDeleteResponseSuccess = (deleteRoleApiConfigsRoleNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteRoleApiConfigsRoleNameDeleteResponseError = (deleteRoleApiConfigsRoleNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteRoleApiConfigsRoleNameDeleteResponse = (deleteRoleApiConfigsRoleNameDeleteResponseSuccess | deleteRoleApiConfigsRoleNameDeleteResponseError)

export const getDeleteRoleApiConfigsRoleNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/role/${name}`
}

export const deleteRoleApiConfigsRoleNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteRoleApiConfigsRoleNameDeleteResponse> => {
  
  return customFetch<deleteRoleApiConfigsRoleNameDeleteResponse>(getDeleteRoleApiConfigsRoleNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeleteRoleApiConfigsRoleNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteRoleApiConfigsRoleNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteRoleApiConfigsRoleNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleApiConfigsRoleNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>>
    export type DeleteRoleApiConfigsRoleNameDeleteMutationBody = ConfigsRequest
    export type DeleteRoleApiConfigsRoleNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Role
 */
export const useDeleteRoleApiConfigsRoleNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeleteRoleApiConfigsRoleNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all backend test configurations
 * @summary List Backend Tests
 */
export type listBackendTestsApiConfigsBackendTestGetResponse200 = {
  data: string
  status: 200
}

export type listBackendTestsApiConfigsBackendTestGetResponseSuccess = (listBackendTestsApiConfigsBackendTestGetResponse200) & {
  headers: Headers;
};
;

export type listBackendTestsApiConfigsBackendTestGetResponse = (listBackendTestsApiConfigsBackendTestGetResponseSuccess)

export const getListBackendTestsApiConfigsBackendTestGetUrl = () => {


  

  return `/api/configs/backend_test`
}

export const listBackendTestsApiConfigsBackendTestGet = async ( options?: RequestInit): Promise<listBackendTestsApiConfigsBackendTestGetResponse> => {
  
  return customFetch<listBackendTestsApiConfigsBackendTestGetResponse>(getListBackendTestsApiConfigsBackendTestGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListBackendTestsApiConfigsBackendTestGetQueryKey = () => {
    return [
    `/api/configs/backend_test`
    ] as const;
    }

    
export const getListBackendTestsApiConfigsBackendTestGetQueryOptions = <TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBackendTestsApiConfigsBackendTestGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>> = ({ signal }) => listBackendTestsApiConfigsBackendTestGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBackendTestsApiConfigsBackendTestGetQueryResult = NonNullable<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>>
export type ListBackendTestsApiConfigsBackendTestGetQueryError = unknown


export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Backend Tests
 */

export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBackendTestsApiConfigsBackendTestGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put backend test configurations
 * @summary Put Backend Tests
 */
export type putBackendTestsApiConfigsBackendTestPutResponse200 = {
  data: unknown
  status: 200
}

export type putBackendTestsApiConfigsBackendTestPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putBackendTestsApiConfigsBackendTestPutResponseSuccess = (putBackendTestsApiConfigsBackendTestPutResponse200) & {
  headers: Headers;
};
export type putBackendTestsApiConfigsBackendTestPutResponseError = (putBackendTestsApiConfigsBackendTestPutResponse422) & {
  headers: Headers;
};

export type putBackendTestsApiConfigsBackendTestPutResponse = (putBackendTestsApiConfigsBackendTestPutResponseSuccess | putBackendTestsApiConfigsBackendTestPutResponseError)

export const getPutBackendTestsApiConfigsBackendTestPutUrl = () => {


  

  return `/api/configs/backend_test`
}

export const putBackendTestsApiConfigsBackendTestPut = async (putBackendTestsRequest: PutBackendTestsRequest, options?: RequestInit): Promise<putBackendTestsApiConfigsBackendTestPutResponse> => {
  
  return customFetch<putBackendTestsApiConfigsBackendTestPutResponse>(getPutBackendTestsApiConfigsBackendTestPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putBackendTestsRequest,)
  }
);}
  



export const getPutBackendTestsApiConfigsBackendTestPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext> => {

const mutationKey = ['putBackendTestsApiConfigsBackendTestPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, {data: PutBackendTestsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putBackendTestsApiConfigsBackendTestPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutBackendTestsApiConfigsBackendTestPutMutationResult = NonNullable<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>>
    export type PutBackendTestsApiConfigsBackendTestPutMutationBody = PutBackendTestsRequest
    export type PutBackendTestsApiConfigsBackendTestPutMutationError = HTTPValidationError

    /**
 * @summary Put Backend Tests
 */
export const usePutBackendTestsApiConfigsBackendTestPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>,
        TError,
        {data: PutBackendTestsRequest},
        TContext
      > => {
      return useMutation(getPutBackendTestsApiConfigsBackendTestPutMutationOptions(options), queryClient);
    }
    
/**
 * Read backend test configuration
 * @summary Read Backend Test
 */
export type readBackendTestApiConfigsBackendTestNameGetResponse200 = {
  data: string
  status: 200
}

export type readBackendTestApiConfigsBackendTestNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type readBackendTestApiConfigsBackendTestNameGetResponseSuccess = (readBackendTestApiConfigsBackendTestNameGetResponse200) & {
  headers: Headers;
};
export type readBackendTestApiConfigsBackendTestNameGetResponseError = (readBackendTestApiConfigsBackendTestNameGetResponse422) & {
  headers: Headers;
};

export type readBackendTestApiConfigsBackendTestNameGetResponse = (readBackendTestApiConfigsBackendTestNameGetResponseSuccess | readBackendTestApiConfigsBackendTestNameGetResponseError)

export const getReadBackendTestApiConfigsBackendTestNameGetUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const readBackendTestApiConfigsBackendTestNameGet = async (name: string, options?: RequestInit): Promise<readBackendTestApiConfigsBackendTestNameGetResponse> => {
  
  return customFetch<readBackendTestApiConfigsBackendTestNameGetResponse>(getReadBackendTestApiConfigsBackendTestNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getReadBackendTestApiConfigsBackendTestNameGetQueryKey = (name: string,) => {
    return [
    `/api/configs/backend_test/${name}`
    ] as const;
    }

    
export const getReadBackendTestApiConfigsBackendTestNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadBackendTestApiConfigsBackendTestNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>> = ({ signal }) => readBackendTestApiConfigsBackendTestNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadBackendTestApiConfigsBackendTestNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>>
export type ReadBackendTestApiConfigsBackendTestNameGetQueryError = HTTPValidationError


export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>,
          TError,
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>,
          TError,
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Backend Test
 */

export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadBackendTestApiConfigsBackendTestNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Put backend test configuration
 * @summary Put Backend Test
 */
export type putBackendTestApiConfigsBackendTestNamePutResponse200 = {
  data: unknown
  status: 200
}

export type putBackendTestApiConfigsBackendTestNamePutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type putBackendTestApiConfigsBackendTestNamePutResponseSuccess = (putBackendTestApiConfigsBackendTestNamePutResponse200) & {
  headers: Headers;
};
export type putBackendTestApiConfigsBackendTestNamePutResponseError = (putBackendTestApiConfigsBackendTestNamePutResponse422) & {
  headers: Headers;
};

export type putBackendTestApiConfigsBackendTestNamePutResponse = (putBackendTestApiConfigsBackendTestNamePutResponseSuccess | putBackendTestApiConfigsBackendTestNamePutResponseError)

export const getPutBackendTestApiConfigsBackendTestNamePutUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const putBackendTestApiConfigsBackendTestNamePut = async (name: string,
    putBackendTestRequest: PutBackendTestRequest, options?: RequestInit): Promise<putBackendTestApiConfigsBackendTestNamePutResponse> => {
  
  return customFetch<putBackendTestApiConfigsBackendTestNamePutResponse>(getPutBackendTestApiConfigsBackendTestNamePutUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putBackendTestRequest,)
  }
);}
  



export const getPutBackendTestApiConfigsBackendTestNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext> => {

const mutationKey = ['putBackendTestApiConfigsBackendTestNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, {name: string;data: PutBackendTestRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putBackendTestApiConfigsBackendTestNamePut(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutBackendTestApiConfigsBackendTestNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>>
    export type PutBackendTestApiConfigsBackendTestNamePutMutationBody = PutBackendTestRequest
    export type PutBackendTestApiConfigsBackendTestNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Backend Test
 */
export const usePutBackendTestApiConfigsBackendTestNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>,
        TError,
        {name: string;data: PutBackendTestRequest},
        TContext
      > => {
      return useMutation(getPutBackendTestApiConfigsBackendTestNamePutMutationOptions(options), queryClient);
    }
    
/**
 * Delete test configuration
 * @summary Delete Backend Test
 */
export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponseSuccess = (deleteBackendTestApiConfigsBackendTestNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteBackendTestApiConfigsBackendTestNameDeleteResponseError = (deleteBackendTestApiConfigsBackendTestNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteBackendTestApiConfigsBackendTestNameDeleteResponse = (deleteBackendTestApiConfigsBackendTestNameDeleteResponseSuccess | deleteBackendTestApiConfigsBackendTestNameDeleteResponseError)

export const getDeleteBackendTestApiConfigsBackendTestNameDeleteUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const deleteBackendTestApiConfigsBackendTestNameDelete = async (name: string,
    configsRequest: ConfigsRequest, options?: RequestInit): Promise<deleteBackendTestApiConfigsBackendTestNameDeleteResponse> => {
  
  return customFetch<deleteBackendTestApiConfigsBackendTestNameDeleteResponse>(getDeleteBackendTestApiConfigsBackendTestNameDeleteUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      configsRequest,)
  }
);}
  



export const getDeleteBackendTestApiConfigsBackendTestNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteBackendTestApiConfigsBackendTestNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteBackendTestApiConfigsBackendTestNameDelete(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>>
    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationBody = ConfigsRequest
    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Backend Test
 */
export const useDeleteBackendTestApiConfigsBackendTestNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {
      return useMutation(getDeleteBackendTestApiConfigsBackendTestNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Patch backend test configuration
 * @summary Patch Backend Test
 */
export type patchBackendTestApiConfigsBackendTestNamePatchResponse200 = {
  data: unknown
  status: 200
}

export type patchBackendTestApiConfigsBackendTestNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type patchBackendTestApiConfigsBackendTestNamePatchResponseSuccess = (patchBackendTestApiConfigsBackendTestNamePatchResponse200) & {
  headers: Headers;
};
export type patchBackendTestApiConfigsBackendTestNamePatchResponseError = (patchBackendTestApiConfigsBackendTestNamePatchResponse422) & {
  headers: Headers;
};

export type patchBackendTestApiConfigsBackendTestNamePatchResponse = (patchBackendTestApiConfigsBackendTestNamePatchResponseSuccess | patchBackendTestApiConfigsBackendTestNamePatchResponseError)

export const getPatchBackendTestApiConfigsBackendTestNamePatchUrl = (name: string,) => {


  

  return `/api/configs/backend_test/${name}`
}

export const patchBackendTestApiConfigsBackendTestNamePatch = async (name: string,
    patchBackendTestRequest: PatchBackendTestRequest, options?: RequestInit): Promise<patchBackendTestApiConfigsBackendTestNamePatchResponse> => {
  
  return customFetch<patchBackendTestApiConfigsBackendTestNamePatchResponse>(getPatchBackendTestApiConfigsBackendTestNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchBackendTestRequest,)
  }
);}
  



export const getPatchBackendTestApiConfigsBackendTestNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext> => {

const mutationKey = ['patchBackendTestApiConfigsBackendTestNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, {name: string;data: PatchBackendTestRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchBackendTestApiConfigsBackendTestNamePatch(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>>
    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationBody = PatchBackendTestRequest
    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Backend Test
 */
export const usePatchBackendTestApiConfigsBackendTestNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>,
        TError,
        {name: string;data: PatchBackendTestRequest},
        TContext
      > => {
      return useMutation(getPatchBackendTestApiConfigsBackendTestNamePatchMutationOptions(options), queryClient);
    }
    
/**
 * List history of all configs
 * @summary Get Configs History
 */
export type getConfigsHistoryApiConfigsHistoryGetResponse200 = {
  data: GetConfigsHistoryResponse
  status: 200
}

export type getConfigsHistoryApiConfigsHistoryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getConfigsHistoryApiConfigsHistoryGetResponseSuccess = (getConfigsHistoryApiConfigsHistoryGetResponse200) & {
  headers: Headers;
};
export type getConfigsHistoryApiConfigsHistoryGetResponseError = (getConfigsHistoryApiConfigsHistoryGetResponse422) & {
  headers: Headers;
};

export type getConfigsHistoryApiConfigsHistoryGetResponse = (getConfigsHistoryApiConfigsHistoryGetResponseSuccess | getConfigsHistoryApiConfigsHistoryGetResponseError)

export const getGetConfigsHistoryApiConfigsHistoryGetUrl = (params?: GetConfigsHistoryApiConfigsHistoryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/history?${stringifiedParams}` : `/api/configs/history`
}

export const getConfigsHistoryApiConfigsHistoryGet = async (params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: RequestInit): Promise<getConfigsHistoryApiConfigsHistoryGetResponse> => {
  
  return customFetch<getConfigsHistoryApiConfigsHistoryGetResponse>(getGetConfigsHistoryApiConfigsHistoryGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetConfigsHistoryApiConfigsHistoryGetQueryKey = (params?: GetConfigsHistoryApiConfigsHistoryGetParams,) => {
    return [
    `/api/configs/history`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetConfigsHistoryApiConfigsHistoryGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfigsHistoryApiConfigsHistoryGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>> = ({ signal }) => getConfigsHistoryApiConfigsHistoryGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigsHistoryApiConfigsHistoryGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>>
export type GetConfigsHistoryApiConfigsHistoryGetQueryError = HTTPValidationError


export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params: undefined |  GetConfigsHistoryApiConfigsHistoryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Configs History
 */

export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConfigsHistoryApiConfigsHistoryGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Roll back a config to a particular revision.
 * @summary Rollback Config
 */
export type rollbackConfigApiConfigsHistoryRollbackPostResponse200 = {
  data: unknown
  status: 200
}

export type rollbackConfigApiConfigsHistoryRollbackPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type rollbackConfigApiConfigsHistoryRollbackPostResponseSuccess = (rollbackConfigApiConfigsHistoryRollbackPostResponse200) & {
  headers: Headers;
};
export type rollbackConfigApiConfigsHistoryRollbackPostResponseError = (rollbackConfigApiConfigsHistoryRollbackPostResponse422) & {
  headers: Headers;
};

export type rollbackConfigApiConfigsHistoryRollbackPostResponse = (rollbackConfigApiConfigsHistoryRollbackPostResponseSuccess | rollbackConfigApiConfigsHistoryRollbackPostResponseError)

export const getRollbackConfigApiConfigsHistoryRollbackPostUrl = () => {


  

  return `/api/configs/history/rollback`
}

export const rollbackConfigApiConfigsHistoryRollbackPost = async (rollbackConfigRequest: RollbackConfigRequest, options?: RequestInit): Promise<rollbackConfigApiConfigsHistoryRollbackPostResponse> => {
  
  return customFetch<rollbackConfigApiConfigsHistoryRollbackPostResponse>(getRollbackConfigApiConfigsHistoryRollbackPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rollbackConfigRequest,)
  }
);}
  



export const getRollbackConfigApiConfigsHistoryRollbackPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext> => {

const mutationKey = ['rollbackConfigApiConfigsHistoryRollbackPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, {data: RollbackConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  rollbackConfigApiConfigsHistoryRollbackPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RollbackConfigApiConfigsHistoryRollbackPostMutationResult = NonNullable<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>>
    export type RollbackConfigApiConfigsHistoryRollbackPostMutationBody = RollbackConfigRequest
    export type RollbackConfigApiConfigsHistoryRollbackPostMutationError = HTTPValidationError

    /**
 * @summary Rollback Config
 */
export const useRollbackConfigApiConfigsHistoryRollbackPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>,
        TError,
        {data: RollbackConfigRequest},
        TContext
      > => {
      return useMutation(getRollbackConfigApiConfigsHistoryRollbackPostMutationOptions(options), queryClient);
    }
    
/**
 * Delete a specific config history revision. This performs a soft delete of the revision.

Args:
    config_type: Type of config to delete
    revision: Revision number to delete (must be greater than 0)
    username: Username of the person performing the delete

Raises:
    OSMOUserError: If the revision doesn't exist or is the current revision
 * @summary Delete Config History Revision
 */
export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseSuccess = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse200) & {
  headers: Headers;
};
export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseError = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse422) & {
  headers: Headers;
};

export type deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse = (deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseSuccess | deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponseError)

export const getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteUrl = (configType: string,
    revision: number,) => {


  

  return `/api/configs/history/${configType}/revision/${revision}`
}

export const deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete = async (configType: string,
    revision: number, options?: RequestInit): Promise<deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse> => {
  
  return customFetch<deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteResponse>(getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteUrl(configType,revision),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext> => {

const mutationKey = ['deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, {configType: string;revision: number}> = (props) => {
          const {configType,revision} = props ?? {};

          return  deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete(configType,revision,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>>
    
    export type DeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Config History Revision
 */
export const useDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>,
        TError,
        {configType: string;revision: number},
        TContext
      > => {
      return useMutation(getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Update tags for a specific config history revision.

Args:
    config_type: Type of config to update
    revision: Revision number to update (must be greater than 0)
    request: Request containing tags to add and delete
    username: Username of the person performing the update

Raises:
    OSMOUserError: If the revision doesn't exist or is invalid
 * @summary Update Config History Tags
 */
export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse200 = {
  data: unknown
  status: 200
}

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseSuccess = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse200) & {
  headers: Headers;
};
export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseError = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse422) & {
  headers: Headers;
};

export type updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse = (updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseSuccess | updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponseError)

export const getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostUrl = (configType: string,
    revision: number,) => {


  

  return `/api/configs/history/${configType}/revision/${revision}/tags`
}

export const updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost = async (configType: string,
    revision: number,
    updateConfigTagsRequest: UpdateConfigTagsRequest, options?: RequestInit): Promise<updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse> => {
  
  return customFetch<updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostResponse>(getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostUrl(configType,revision),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateConfigTagsRequest,)
  }
);}
  



export const getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext> => {

const mutationKey = ['updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, {configType: string;revision: number;data: UpdateConfigTagsRequest}> = (props) => {
          const {configType,revision,data} = props ?? {};

          return  updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost(configType,revision,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>>
    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationBody = UpdateConfigTagsRequest
    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationError = HTTPValidationError

    /**
 * @summary Update Config History Tags
 */
export const useUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>,
        TError,
        {configType: string;revision: number;data: UpdateConfigTagsRequest},
        TContext
      > => {
      return useMutation(getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationOptions(options), queryClient);
    }
    
/**
 * Returns two config revisions, similar to
GET /api/configs/history/{config_type}/revision/{revision}, but with obfuscated secret strings
that say if a secret string is changed. Intended for use with the `diff` command.

Args:
    request: Request containing config type and revisions to compare

Returns:
    ConfigDiffResponse containing the two revisions

Raises:
    OSMOUserError: If either revision doesn't exist or is invalid
 * @summary Get Config Diff
 */
export type getConfigDiffApiConfigsDiffGetResponse200 = {
  data: string
  status: 200
}

export type getConfigDiffApiConfigsDiffGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getConfigDiffApiConfigsDiffGetResponseSuccess = (getConfigDiffApiConfigsDiffGetResponse200) & {
  headers: Headers;
};
export type getConfigDiffApiConfigsDiffGetResponseError = (getConfigDiffApiConfigsDiffGetResponse422) & {
  headers: Headers;
};

export type getConfigDiffApiConfigsDiffGetResponse = (getConfigDiffApiConfigsDiffGetResponseSuccess | getConfigDiffApiConfigsDiffGetResponseError)

export const getGetConfigDiffApiConfigsDiffGetUrl = (params: GetConfigDiffApiConfigsDiffGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/configs/diff?${stringifiedParams}` : `/api/configs/diff`
}

export const getConfigDiffApiConfigsDiffGet = async (params: GetConfigDiffApiConfigsDiffGetParams, options?: RequestInit): Promise<getConfigDiffApiConfigsDiffGetResponse> => {
  
  return customFetch<getConfigDiffApiConfigsDiffGetResponse>(getGetConfigDiffApiConfigsDiffGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetConfigDiffApiConfigsDiffGetQueryKey = (params?: GetConfigDiffApiConfigsDiffGetParams,) => {
    return [
    `/api/configs/diff`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetConfigDiffApiConfigsDiffGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfigDiffApiConfigsDiffGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>> = ({ signal }) => getConfigDiffApiConfigsDiffGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigDiffApiConfigsDiffGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>>
export type GetConfigDiffApiConfigsDiffGetQueryError = HTTPValidationError


export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Config Diff
 */

export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConfigDiffApiConfigsDiffGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * API to fetch for a new access token using a refresh token.
 * @summary Get New Jwt Token
 */
export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse200 = {
  data: unknown
  status: 200
}

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponseSuccess = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponse200) & {
  headers: Headers;
};
export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponseError = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponse422) & {
  headers: Headers;
};

export type getNewJwtTokenApiAuthJwtRefreshTokenGetResponse = (getNewJwtTokenApiAuthJwtRefreshTokenGetResponseSuccess | getNewJwtTokenApiAuthJwtRefreshTokenGetResponseError)

export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetUrl = (params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/jwt/refresh_token?${stringifiedParams}` : `/api/auth/jwt/refresh_token`
}

export const getNewJwtTokenApiAuthJwtRefreshTokenGet = async (params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: RequestInit): Promise<getNewJwtTokenApiAuthJwtRefreshTokenGetResponse> => {
  
  return customFetch<getNewJwtTokenApiAuthJwtRefreshTokenGetResponse>(getGetNewJwtTokenApiAuthJwtRefreshTokenGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryKey = (params?: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams,) => {
    return [
    `/api/auth/jwt/refresh_token`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>> = ({ signal }) => getNewJwtTokenApiAuthJwtRefreshTokenGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewJwtTokenApiAuthJwtRefreshTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>>
export type GetNewJwtTokenApiAuthJwtRefreshTokenGetQueryError = HTTPValidationError


export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get New Jwt Token
 */

export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * API to create a new jwt token from an access token.
 * @summary Get Jwt Token From Access Token
 */
export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse200 = {
  data: unknown
  status: 200
}

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseSuccess = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse200) & {
  headers: Headers;
};
export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseError = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse422) & {
  headers: Headers;
};

export type getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse = (getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseSuccess | getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponseError)

export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetUrl = (params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/jwt/access_token?${stringifiedParams}` : `/api/auth/jwt/access_token`
}

export const getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet = async (params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: RequestInit): Promise<getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse> => {
  
  return customFetch<getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetResponse>(getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryKey = (params?: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams,) => {
    return [
    `/api/auth/jwt/access_token`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>> = ({ signal }) => getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>>
export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryError = HTTPValidationError


export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Jwt Token From Access Token
 */

export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * API to create a new access token.

If roles are specified, all specified roles must be assigned to the user.
If any role is not assigned to the user, the request fails and no token
is created. If no roles are specified, the access token inherits all of the user's
current roles from the user_roles table.
 * @summary Create Access Token
 */
export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse200 = {
  data: unknown
  status: 200
}

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponseSuccess = (createAccessTokenApiAuthAccessTokenTokenNamePostResponse200) & {
  headers: Headers;
};
export type createAccessTokenApiAuthAccessTokenTokenNamePostResponseError = (createAccessTokenApiAuthAccessTokenTokenNamePostResponse422) & {
  headers: Headers;
};

export type createAccessTokenApiAuthAccessTokenTokenNamePostResponse = (createAccessTokenApiAuthAccessTokenTokenNamePostResponseSuccess | createAccessTokenApiAuthAccessTokenTokenNamePostResponseError)

export const getCreateAccessTokenApiAuthAccessTokenTokenNamePostUrl = (tokenName: string,
    params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/access_token/${tokenName}?${stringifiedParams}` : `/api/auth/access_token/${tokenName}`
}

export const createAccessTokenApiAuthAccessTokenTokenNamePost = async (tokenName: string,
    params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams, options?: RequestInit): Promise<createAccessTokenApiAuthAccessTokenTokenNamePostResponse> => {
  
  return customFetch<createAccessTokenApiAuthAccessTokenTokenNamePostResponse>(getCreateAccessTokenApiAuthAccessTokenTokenNamePostUrl(tokenName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getCreateAccessTokenApiAuthAccessTokenTokenNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams}, TContext> => {

const mutationKey = ['createAccessTokenApiAuthAccessTokenTokenNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>, {tokenName: string;params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams}> = (props) => {
          const {tokenName,params} = props ?? {};

          return  createAccessTokenApiAuthAccessTokenTokenNamePost(tokenName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAccessTokenApiAuthAccessTokenTokenNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>>
    
    export type CreateAccessTokenApiAuthAccessTokenTokenNamePostMutationError = HTTPValidationError

    /**
 * @summary Create Access Token
 */
export const useCreateAccessTokenApiAuthAccessTokenTokenNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenTokenNamePost>>,
        TError,
        {tokenName: string;params: CreateAccessTokenApiAuthAccessTokenTokenNamePostParams},
        TContext
      > => {
      return useMutation(getCreateAccessTokenApiAuthAccessTokenTokenNamePostMutationOptions(options), queryClient);
    }
    
/**
 * API to delete an access token.
 * @summary Delete Access Token
 */
export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseSuccess = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseError = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse = (deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseSuccess | deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponseError)

export const getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteUrl = (tokenName: string,) => {


  

  return `/api/auth/access_token/${tokenName}`
}

export const deleteAccessTokenApiAuthAccessTokenTokenNameDelete = async (tokenName: string, options?: RequestInit): Promise<deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse> => {
  
  return customFetch<deleteAccessTokenApiAuthAccessTokenTokenNameDeleteResponse>(getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteUrl(tokenName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>, TError,{tokenName: string}, TContext> => {

const mutationKey = ['deleteAccessTokenApiAuthAccessTokenTokenNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>, {tokenName: string}> = (props) => {
          const {tokenName} = props ?? {};

          return  deleteAccessTokenApiAuthAccessTokenTokenNameDelete(tokenName,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>>
    
    export type DeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Access Token
 */
export const useDeleteAccessTokenApiAuthAccessTokenTokenNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenTokenNameDelete>>,
        TError,
        {tokenName: string},
        TContext
      > => {
      return useMutation(getDeleteAccessTokenApiAuthAccessTokenTokenNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all roles assigned to an access token.

Args:
    token_name: The token name
    user_name: Authenticated user (owner of the token)

Returns:
    AccessTokenRolesResponse with list of role assignments
 * @summary List Access Token Roles
 */
export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse200 = {
  data: AccessTokenRolesResponse
  status: 200
}

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseSuccess = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse200) & {
  headers: Headers;
};
export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseError = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse422) & {
  headers: Headers;
};

export type listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse = (listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseSuccess | listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponseError)

export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetUrl = (tokenName: string,) => {


  

  return `/api/auth/access_token/${tokenName}/roles`
}

export const listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet = async (tokenName: string, options?: RequestInit): Promise<listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse> => {
  
  return customFetch<listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetResponse>(getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetUrl(tokenName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryKey = (tokenName: string,) => {
    return [
    `/api/auth/access_token/${tokenName}/roles`
    ] as const;
    }

    
export const getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryOptions = <TData = Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError = HTTPValidationError>(tokenName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryKey(tokenName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>> = ({ signal }) => listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet(tokenName, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(tokenName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>>
export type ListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryError = HTTPValidationError


export function useListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet<TData = Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError = HTTPValidationError>(
 tokenName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet<TData = Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError = HTTPValidationError>(
 tokenName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet<TData = Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError = HTTPValidationError>(
 tokenName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Access Token Roles
 */

export function useListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet<TData = Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError = HTTPValidationError>(
 tokenName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokenRolesApiAuthAccessTokenTokenNameRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAccessTokenRolesApiAuthAccessTokenTokenNameRolesGetQueryOptions(tokenName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * API to list all access tokens for a user, including their assigned roles.
 * @summary List Access Tokens
 */
export type listAccessTokensApiAuthAccessTokenGetResponse200 = {
  data: AccessTokenWithRoles[]
  status: 200
}

export type listAccessTokensApiAuthAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAccessTokensApiAuthAccessTokenGetResponseSuccess = (listAccessTokensApiAuthAccessTokenGetResponse200) & {
  headers: Headers;
};
export type listAccessTokensApiAuthAccessTokenGetResponseError = (listAccessTokensApiAuthAccessTokenGetResponse422) & {
  headers: Headers;
};

export type listAccessTokensApiAuthAccessTokenGetResponse = (listAccessTokensApiAuthAccessTokenGetResponseSuccess | listAccessTokensApiAuthAccessTokenGetResponseError)

export const getListAccessTokensApiAuthAccessTokenGetUrl = () => {


  

  return `/api/auth/access_token`
}

export const listAccessTokensApiAuthAccessTokenGet = async ( options?: RequestInit): Promise<listAccessTokensApiAuthAccessTokenGetResponse> => {
  
  return customFetch<listAccessTokensApiAuthAccessTokenGetResponse>(getListAccessTokensApiAuthAccessTokenGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListAccessTokensApiAuthAccessTokenGetQueryKey = () => {
    return [
    `/api/auth/access_token`
    ] as const;
    }

    
export const getListAccessTokensApiAuthAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAccessTokensApiAuthAccessTokenGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>> = ({ signal }) => listAccessTokensApiAuthAccessTokenGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAccessTokensApiAuthAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>>
export type ListAccessTokensApiAuthAccessTokenGetQueryError = HTTPValidationError


export function useListAccessTokensApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokensApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokensApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Access Tokens
 */

export function useListAccessTokensApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAccessTokensApiAuthAccessTokenGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Admin API to create an access token for a specific user.

This endpoint allows administrators to create an access token
on behalf of any user in the system.

If roles are specified, all specified roles must be assigned to the target
user. If any role is not assigned to the user, the request fails and no
token is created. If no roles are specified, the access token inherits all of the
target user's current roles from the user_roles table.

Args:
    user_id: The user ID to create the token for
    token_name: Name for the access token
    expires_at: Expiration date in YYYY-MM-DD format
    description: Optional description for the token
    roles: Optional list of roles to assign (must all be assigned to user)
    admin_user: Authenticated admin user making the request

Returns:
    The generated access token string
 * @summary Admin Create Access Token
 */
export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse200 = {
  data: unknown
  status: 200
}

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseSuccess = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse200) & {
  headers: Headers;
};
export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseError = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse422) & {
  headers: Headers;
};

export type adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse = (adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseSuccess | adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponseError)

export const getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostUrl = (userId: string,
    tokenName: string,
    params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/user/${userId}/access_token/${tokenName}?${stringifiedParams}` : `/api/auth/user/${userId}/access_token/${tokenName}`
}

export const adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost = async (userId: string,
    tokenName: string,
    params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams, options?: RequestInit): Promise<adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse> => {
  
  return customFetch<adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostResponse>(getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostUrl(userId,tokenName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>, TError,{userId: string;tokenName: string;params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>, TError,{userId: string;tokenName: string;params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams}, TContext> => {

const mutationKey = ['adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>, {userId: string;tokenName: string;params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams}> = (props) => {
          const {userId,tokenName,params} = props ?? {};

          return  adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost(userId,tokenName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>>
    
    export type AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMutationError = HTTPValidationError

    /**
 * @summary Admin Create Access Token
 */
export const useAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>, TError,{userId: string;tokenName: string;params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePost>>,
        TError,
        {userId: string;tokenName: string;params: AdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostParams},
        TContext
      > => {
      return useMutation(getAdminCreateAccessTokenApiAuthUserUserIdAccessTokenTokenNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Admin API to delete an access token for a specific user.

Args:
    user_id: The user ID who owns the token
    token_name: Name of the token to delete
 * @summary Admin Delete Access Token
 */
export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseSuccess = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse200) & {
  headers: Headers;
};
export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseError = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse422) & {
  headers: Headers;
};

export type adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse = (adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseSuccess | adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponseError)

export const getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteUrl = (userId: string,
    tokenName: string,) => {


  

  return `/api/auth/user/${userId}/access_token/${tokenName}`
}

export const adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete = async (userId: string,
    tokenName: string, options?: RequestInit): Promise<adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse> => {
  
  return customFetch<adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteResponse>(getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteUrl(userId,tokenName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>, TError,{userId: string;tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>, TError,{userId: string;tokenName: string}, TContext> => {

const mutationKey = ['adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>, {userId: string;tokenName: string}> = (props) => {
          const {userId,tokenName} = props ?? {};

          return  adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete(userId,tokenName,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>>
    
    export type AdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Admin Delete Access Token
 */
export const useAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>, TError,{userId: string;tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDelete>>,
        TError,
        {userId: string;tokenName: string},
        TContext
      > => {
      return useMutation(getAdminDeleteAccessTokenApiAuthUserUserIdAccessTokenTokenNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Admin API to list all access tokens for a specific user, including their assigned roles.

Args:
    user_id: The user ID to list tokens for

Returns:
    List of AccessTokenWithRoles objects
 * @summary Admin List Access Tokens
 */
export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse200 = {
  data: AccessTokenWithRoles[]
  status: 200
}

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseSuccess = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse200) & {
  headers: Headers;
};
export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseError = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse422) & {
  headers: Headers;
};

export type adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse = (adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseSuccess | adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponseError)

export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/access_token`
}

export const adminListAccessTokensApiAuthUserUserIdAccessTokenGet = async (userId: string, options?: RequestInit): Promise<adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse> => {
  
  return customFetch<adminListAccessTokensApiAuthUserUserIdAccessTokenGetResponse>(getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryKey = (userId: string,) => {
    return [
    `/api/auth/user/${userId}/access_token`
    ] as const;
    }

    
export const getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>> = ({ signal }) => adminListAccessTokensApiAuthUserUserIdAccessTokenGet(userId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>>
export type AdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryError = HTTPValidationError


export function useAdminListAccessTokensApiAuthUserUserIdAccessTokenGet<TData = Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminListAccessTokensApiAuthUserUserIdAccessTokenGet<TData = Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAdminListAccessTokensApiAuthUserUserIdAccessTokenGet<TData = Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Admin List Access Tokens
 */

export function useAdminListAccessTokensApiAuthUserUserIdAccessTokenGet<TData = Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListAccessTokensApiAuthUserUserIdAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListAccessTokensApiAuthUserUserIdAccessTokenGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * List all users with optional filtering.

Args:
    start_index: Pagination start (1-based, default: 1)
    count: Results per page (default: 100, max: 1000)
    id_prefix: Filter users whose ID starts with this prefix
    roles: List of role names. Returns users who have ANY of these roles.
           Use multiple query params: ?roles=admin&roles=user

Returns:
    UserListResponse with paginated user list
 * @summary List Users
 */
export type listUsersApiAuthUserGetResponse200 = {
  data: UserListResponse
  status: 200
}

export type listUsersApiAuthUserGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUsersApiAuthUserGetResponseSuccess = (listUsersApiAuthUserGetResponse200) & {
  headers: Headers;
};
export type listUsersApiAuthUserGetResponseError = (listUsersApiAuthUserGetResponse422) & {
  headers: Headers;
};

export type listUsersApiAuthUserGetResponse = (listUsersApiAuthUserGetResponseSuccess | listUsersApiAuthUserGetResponseError)

export const getListUsersApiAuthUserGetUrl = (params?: ListUsersApiAuthUserGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/auth/user?${stringifiedParams}` : `/api/auth/user`
}

export const listUsersApiAuthUserGet = async (params?: ListUsersApiAuthUserGetParams, options?: RequestInit): Promise<listUsersApiAuthUserGetResponse> => {
  
  return customFetch<listUsersApiAuthUserGetResponse>(getListUsersApiAuthUserGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListUsersApiAuthUserGetQueryKey = (params?: ListUsersApiAuthUserGetParams,) => {
    return [
    `/api/auth/user`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListUsersApiAuthUserGetQueryOptions = <TData = Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError = HTTPValidationError>(params?: ListUsersApiAuthUserGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersApiAuthUserGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>> = ({ signal }) => listUsersApiAuthUserGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersApiAuthUserGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>>
export type ListUsersApiAuthUserGetQueryError = HTTPValidationError


export function useListUsersApiAuthUserGet<TData = Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError = HTTPValidationError>(
 params: undefined |  ListUsersApiAuthUserGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersApiAuthUserGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersApiAuthUserGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersApiAuthUserGet<TData = Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError = HTTPValidationError>(
 params?: ListUsersApiAuthUserGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersApiAuthUserGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersApiAuthUserGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersApiAuthUserGet<TData = Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError = HTTPValidationError>(
 params?: ListUsersApiAuthUserGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users
 */

export function useListUsersApiAuthUserGet<TData = Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError = HTTPValidationError>(
 params?: ListUsersApiAuthUserGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersApiAuthUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUsersApiAuthUserGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new user.

Args:
    request: CreateUserRequest with user details
    created_by: Authenticated user making the request

Returns:
    Created User object
 * @summary Create User
 */
export type createUserApiAuthUserPostResponse200 = {
  data: User
  status: 200
}

export type createUserApiAuthUserPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createUserApiAuthUserPostResponseSuccess = (createUserApiAuthUserPostResponse200) & {
  headers: Headers;
};
export type createUserApiAuthUserPostResponseError = (createUserApiAuthUserPostResponse422) & {
  headers: Headers;
};

export type createUserApiAuthUserPostResponse = (createUserApiAuthUserPostResponseSuccess | createUserApiAuthUserPostResponseError)

export const getCreateUserApiAuthUserPostUrl = () => {


  

  return `/api/auth/user`
}

export const createUserApiAuthUserPost = async (createUserRequest: CreateUserRequest, options?: RequestInit): Promise<createUserApiAuthUserPostResponse> => {
  
  return customFetch<createUserApiAuthUserPostResponse>(getCreateUserApiAuthUserPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserRequest,)
  }
);}
  



export const getCreateUserApiAuthUserPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiAuthUserPost>>, TError,{data: CreateUserRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createUserApiAuthUserPost>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createUserApiAuthUserPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserApiAuthUserPost>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUserApiAuthUserPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserApiAuthUserPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserApiAuthUserPost>>>
    export type CreateUserApiAuthUserPostMutationBody = CreateUserRequest
    export type CreateUserApiAuthUserPostMutationError = HTTPValidationError

    /**
 * @summary Create User
 */
export const useCreateUserApiAuthUserPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiAuthUserPost>>, TError,{data: CreateUserRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUserApiAuthUserPost>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {
      return useMutation(getCreateUserApiAuthUserPostMutationOptions(options), queryClient);
    }
    
/**
 * Get a specific user's details including their roles.

Args:
    user_id: The user ID to fetch

Returns:
    UserWithRoles object
 * @summary Get User
 */
export type getUserApiAuthUserUserIdGetResponse200 = {
  data: UserWithRoles
  status: 200
}

export type getUserApiAuthUserUserIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getUserApiAuthUserUserIdGetResponseSuccess = (getUserApiAuthUserUserIdGetResponse200) & {
  headers: Headers;
};
export type getUserApiAuthUserUserIdGetResponseError = (getUserApiAuthUserUserIdGetResponse422) & {
  headers: Headers;
};

export type getUserApiAuthUserUserIdGetResponse = (getUserApiAuthUserUserIdGetResponseSuccess | getUserApiAuthUserUserIdGetResponseError)

export const getGetUserApiAuthUserUserIdGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}`
}

export const getUserApiAuthUserUserIdGet = async (userId: string, options?: RequestInit): Promise<getUserApiAuthUserUserIdGetResponse> => {
  
  return customFetch<getUserApiAuthUserUserIdGetResponse>(getGetUserApiAuthUserUserIdGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetUserApiAuthUserUserIdGetQueryKey = (userId: string,) => {
    return [
    `/api/auth/user/${userId}`
    ] as const;
    }

    
export const getGetUserApiAuthUserUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserApiAuthUserUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>> = ({ signal }) => getUserApiAuthUserUserIdGet(userId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserApiAuthUserUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>>
export type GetUserApiAuthUserUserIdGetQueryError = HTTPValidationError


export function useGetUserApiAuthUserUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiAuthUserUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiAuthUserUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetUserApiAuthUserUserIdGet<TData = Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiAuthUserUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserApiAuthUserUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete a user and all associated role assignments and PATs.

Args:
    user_id: The user ID to delete
 * @summary Delete User
 */
export type deleteUserApiAuthUserUserIdDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteUserApiAuthUserUserIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteUserApiAuthUserUserIdDeleteResponseSuccess = (deleteUserApiAuthUserUserIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteUserApiAuthUserUserIdDeleteResponseError = (deleteUserApiAuthUserUserIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteUserApiAuthUserUserIdDeleteResponse = (deleteUserApiAuthUserUserIdDeleteResponseSuccess | deleteUserApiAuthUserUserIdDeleteResponseError)

export const getDeleteUserApiAuthUserUserIdDeleteUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}`
}

export const deleteUserApiAuthUserUserIdDelete = async (userId: string, options?: RequestInit): Promise<deleteUserApiAuthUserUserIdDeleteResponse> => {
  
  return customFetch<deleteUserApiAuthUserUserIdDeleteResponse>(getDeleteUserApiAuthUserUserIdDeleteUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteUserApiAuthUserUserIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUserApiAuthUserUserIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUserApiAuthUserUserIdDelete(userId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserApiAuthUserUserIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>>
    
    export type DeleteUserApiAuthUserUserIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete User
 */
export const useDeleteUserApiAuthUserUserIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserApiAuthUserUserIdDelete>>,
        TError,
        {userId: string},
        TContext
      > => {
      return useMutation(getDeleteUserApiAuthUserUserIdDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all roles assigned to a user.

Args:
    user_id: The user ID

Returns:
    UserRolesResponse with list of role assignments
 * @summary List User Roles
 */
export type listUserRolesApiAuthUserUserIdRolesGetResponse200 = {
  data: UserRolesResponse
  status: 200
}

export type listUserRolesApiAuthUserUserIdRolesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUserRolesApiAuthUserUserIdRolesGetResponseSuccess = (listUserRolesApiAuthUserUserIdRolesGetResponse200) & {
  headers: Headers;
};
export type listUserRolesApiAuthUserUserIdRolesGetResponseError = (listUserRolesApiAuthUserUserIdRolesGetResponse422) & {
  headers: Headers;
};

export type listUserRolesApiAuthUserUserIdRolesGetResponse = (listUserRolesApiAuthUserUserIdRolesGetResponseSuccess | listUserRolesApiAuthUserUserIdRolesGetResponseError)

export const getListUserRolesApiAuthUserUserIdRolesGetUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/roles`
}

export const listUserRolesApiAuthUserUserIdRolesGet = async (userId: string, options?: RequestInit): Promise<listUserRolesApiAuthUserUserIdRolesGetResponse> => {
  
  return customFetch<listUserRolesApiAuthUserUserIdRolesGetResponse>(getListUserRolesApiAuthUserUserIdRolesGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListUserRolesApiAuthUserUserIdRolesGetQueryKey = (userId: string,) => {
    return [
    `/api/auth/user/${userId}/roles`
    ] as const;
    }

    
export const getListUserRolesApiAuthUserUserIdRolesGetQueryOptions = <TData = Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUserRolesApiAuthUserUserIdRolesGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>> = ({ signal }) => listUserRolesApiAuthUserUserIdRolesGet(userId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUserRolesApiAuthUserUserIdRolesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>>
export type ListUserRolesApiAuthUserUserIdRolesGetQueryError = HTTPValidationError


export function useListUserRolesApiAuthUserUserIdRolesGet<TData = Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>,
          TError,
          Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUserRolesApiAuthUserUserIdRolesGet<TData = Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>,
          TError,
          Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUserRolesApiAuthUserUserIdRolesGet<TData = Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List User Roles
 */

export function useListUserRolesApiAuthUserUserIdRolesGet<TData = Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUserRolesApiAuthUserUserIdRolesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUserRolesApiAuthUserUserIdRolesGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Assign a role to a user.

Args:
    user_id: The user ID
    request: AssignRoleRequest with role_name
    assigned_by: Authenticated user making the request

Returns:
    UserRoleAssignment with assignment details
 * @summary Assign Role To User
 */
export type assignRoleToUserApiAuthUserUserIdRolesPostResponse200 = {
  data: UserRoleAssignment
  status: 200
}

export type assignRoleToUserApiAuthUserUserIdRolesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type assignRoleToUserApiAuthUserUserIdRolesPostResponseSuccess = (assignRoleToUserApiAuthUserUserIdRolesPostResponse200) & {
  headers: Headers;
};
export type assignRoleToUserApiAuthUserUserIdRolesPostResponseError = (assignRoleToUserApiAuthUserUserIdRolesPostResponse422) & {
  headers: Headers;
};

export type assignRoleToUserApiAuthUserUserIdRolesPostResponse = (assignRoleToUserApiAuthUserUserIdRolesPostResponseSuccess | assignRoleToUserApiAuthUserUserIdRolesPostResponseError)

export const getAssignRoleToUserApiAuthUserUserIdRolesPostUrl = (userId: string,) => {


  

  return `/api/auth/user/${userId}/roles`
}

export const assignRoleToUserApiAuthUserUserIdRolesPost = async (userId: string,
    assignRoleRequest: AssignRoleRequest, options?: RequestInit): Promise<assignRoleToUserApiAuthUserUserIdRolesPostResponse> => {
  
  return customFetch<assignRoleToUserApiAuthUserUserIdRolesPostResponse>(getAssignRoleToUserApiAuthUserUserIdRolesPostUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignRoleRequest,)
  }
);}
  



export const getAssignRoleToUserApiAuthUserUserIdRolesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>, TError,{userId: string;data: AssignRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>, TError,{userId: string;data: AssignRoleRequest}, TContext> => {

const mutationKey = ['assignRoleToUserApiAuthUserUserIdRolesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>, {userId: string;data: AssignRoleRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  assignRoleToUserApiAuthUserUserIdRolesPost(userId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AssignRoleToUserApiAuthUserUserIdRolesPostMutationResult = NonNullable<Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>>
    export type AssignRoleToUserApiAuthUserUserIdRolesPostMutationBody = AssignRoleRequest
    export type AssignRoleToUserApiAuthUserUserIdRolesPostMutationError = HTTPValidationError

    /**
 * @summary Assign Role To User
 */
export const useAssignRoleToUserApiAuthUserUserIdRolesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>, TError,{userId: string;data: AssignRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignRoleToUserApiAuthUserUserIdRolesPost>>,
        TError,
        {userId: string;data: AssignRoleRequest},
        TContext
      > => {
      return useMutation(getAssignRoleToUserApiAuthUserUserIdRolesPostMutationOptions(options), queryClient);
    }
    
/**
 * Remove a role from a user and all their PATs.

When a role is removed from a user, it is automatically removed from all PATs
owned by that user via the FK cascade from access_token_roles to user_roles.

Args:
    user_id: The user ID
    role_name: The role to remove
 * @summary Remove Role From User
 */
export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseSuccess = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse200) & {
  headers: Headers;
};
export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseError = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse422) & {
  headers: Headers;
};

export type removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse = (removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseSuccess | removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponseError)

export const getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteUrl = (userId: string,
    roleName: string,) => {


  

  return `/api/auth/user/${userId}/roles/${roleName}`
}

export const removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete = async (userId: string,
    roleName: string, options?: RequestInit): Promise<removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse> => {
  
  return customFetch<removeRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteResponse>(getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteUrl(userId,roleName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>, TError,{userId: string;roleName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>, TError,{userId: string;roleName: string}, TContext> => {

const mutationKey = ['removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>, {userId: string;roleName: string}> = (props) => {
          const {userId,roleName} = props ?? {};

          return  removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete(userId,roleName,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>>
    
    export type RemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Remove Role From User
 */
export const useRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>, TError,{userId: string;roleName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeRoleFromUserApiAuthUserUserIdRolesRoleNameDelete>>,
        TError,
        {userId: string;roleName: string},
        TContext
      > => {
      return useMutation(getRemoveRoleFromUserApiAuthUserUserIdRolesRoleNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * List all users who have a specific role.

Args:
    role_name: The role name

Returns:
    RoleUsersResponse with list of users
 * @summary List Users With Role
 */
export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse200 = {
  data: RoleUsersResponse
  status: 200
}

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseSuccess = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse200) & {
  headers: Headers;
};
export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseError = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse422) & {
  headers: Headers;
};

export type listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse = (listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseSuccess | listUsersWithRoleApiAuthRolesRoleNameUsersGetResponseError)

export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetUrl = (roleName: string,) => {


  

  return `/api/auth/roles/${roleName}/users`
}

export const listUsersWithRoleApiAuthRolesRoleNameUsersGet = async (roleName: string, options?: RequestInit): Promise<listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse> => {
  
  return customFetch<listUsersWithRoleApiAuthRolesRoleNameUsersGetResponse>(getListUsersWithRoleApiAuthRolesRoleNameUsersGetUrl(roleName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryKey = (roleName: string,) => {
    return [
    `/api/auth/roles/${roleName}/users`
    ] as const;
    }

    
export const getListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError = HTTPValidationError>(roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryKey(roleName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>> = ({ signal }) => listUsersWithRoleApiAuthRolesRoleNameUsersGet(roleName, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(roleName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>>
export type ListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryError = HTTPValidationError


export function useListUsersWithRoleApiAuthRolesRoleNameUsersGet<TData = Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError = HTTPValidationError>(
 roleName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersWithRoleApiAuthRolesRoleNameUsersGet<TData = Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError = HTTPValidationError>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>,
          TError,
          Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsersWithRoleApiAuthRolesRoleNameUsersGet<TData = Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError = HTTPValidationError>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users With Role
 */

export function useListUsersWithRoleApiAuthRolesRoleNameUsersGet<TData = Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError = HTTPValidationError>(
 roleName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsersWithRoleApiAuthRolesRoleNameUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUsersWithRoleApiAuthRolesRoleNameUsersGetQueryOptions(roleName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Bulk assign a role to multiple users.

Args:
    role_name: The role to assign
    request: BulkAssignRequest with list of user_ids
    assigned_by: Authenticated user making the request

Returns:
    BulkAssignResponse with results
 * @summary Bulk Assign Role
 */
export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse200 = {
  data: BulkAssignResponse
  status: 200
}

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseSuccess = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse200) & {
  headers: Headers;
};
export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseError = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse422) & {
  headers: Headers;
};

export type bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse = (bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseSuccess | bulkAssignRoleApiAuthRolesRoleNameUsersPostResponseError)

export const getBulkAssignRoleApiAuthRolesRoleNameUsersPostUrl = (roleName: string,) => {


  

  return `/api/auth/roles/${roleName}/users`
}

export const bulkAssignRoleApiAuthRolesRoleNameUsersPost = async (roleName: string,
    bulkAssignRequest: BulkAssignRequest, options?: RequestInit): Promise<bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse> => {
  
  return customFetch<bulkAssignRoleApiAuthRolesRoleNameUsersPostResponse>(getBulkAssignRoleApiAuthRolesRoleNameUsersPostUrl(roleName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkAssignRequest,)
  }
);}
  



export const getBulkAssignRoleApiAuthRolesRoleNameUsersPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>, TError,{roleName: string;data: BulkAssignRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>, TError,{roleName: string;data: BulkAssignRequest}, TContext> => {

const mutationKey = ['bulkAssignRoleApiAuthRolesRoleNameUsersPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>, {roleName: string;data: BulkAssignRequest}> = (props) => {
          const {roleName,data} = props ?? {};

          return  bulkAssignRoleApiAuthRolesRoleNameUsersPost(roleName,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BulkAssignRoleApiAuthRolesRoleNameUsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>>
    export type BulkAssignRoleApiAuthRolesRoleNameUsersPostMutationBody = BulkAssignRequest
    export type BulkAssignRoleApiAuthRolesRoleNameUsersPostMutationError = HTTPValidationError

    /**
 * @summary Bulk Assign Role
 */
export const useBulkAssignRoleApiAuthRolesRoleNameUsersPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>, TError,{roleName: string;data: BulkAssignRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bulkAssignRoleApiAuthRolesRoleNameUsersPost>>,
        TError,
        {roleName: string;data: BulkAssignRequest},
        TContext
      > => {
      return useMutation(getBulkAssignRoleApiAuthRolesRoleNameUsersPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary List Apps
 */
export type listAppsApiAppGetResponse200 = {
  data: string
  status: 200
}

export type listAppsApiAppGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listAppsApiAppGetResponseSuccess = (listAppsApiAppGetResponse200) & {
  headers: Headers;
};
export type listAppsApiAppGetResponseError = (listAppsApiAppGetResponse422) & {
  headers: Headers;
};

export type listAppsApiAppGetResponse = (listAppsApiAppGetResponseSuccess | listAppsApiAppGetResponseError)

export const getListAppsApiAppGetUrl = (params?: ListAppsApiAppGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app?${stringifiedParams}` : `/api/app`
}

export const listAppsApiAppGet = async (params?: ListAppsApiAppGetParams, options?: RequestInit): Promise<listAppsApiAppGetResponse> => {
  
  return customFetch<listAppsApiAppGetResponse>(getListAppsApiAppGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListAppsApiAppGetQueryKey = (params?: ListAppsApiAppGetParams,) => {
    return [
    `/api/app`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListAppsApiAppGetQueryOptions = <TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppsApiAppGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppsApiAppGet>>> = ({ signal }) => listAppsApiAppGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAppsApiAppGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAppsApiAppGet>>>
export type ListAppsApiAppGetQueryError = HTTPValidationError


export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params: undefined |  ListAppsApiAppGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppsApiAppGet>>,
          TError,
          Awaited<ReturnType<typeof listAppsApiAppGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppsApiAppGet>>,
          TError,
          Awaited<ReturnType<typeof listAppsApiAppGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Apps
 */

export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAppsApiAppGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get App
 */
export type getAppApiAppUserNameGetResponse200 = {
  data: string
  status: 200
}

export type getAppApiAppUserNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAppApiAppUserNameGetResponseSuccess = (getAppApiAppUserNameGetResponse200) & {
  headers: Headers;
};
export type getAppApiAppUserNameGetResponseError = (getAppApiAppUserNameGetResponse422) & {
  headers: Headers;
};

export type getAppApiAppUserNameGetResponse = (getAppApiAppUserNameGetResponseSuccess | getAppApiAppUserNameGetResponseError)

export const getGetAppApiAppUserNameGetUrl = (name: string,
    params?: GetAppApiAppUserNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const getAppApiAppUserNameGet = async (name: string,
    params?: GetAppApiAppUserNameGetParams, options?: RequestInit): Promise<getAppApiAppUserNameGetResponse> => {
  
  return customFetch<getAppApiAppUserNameGetResponse>(getGetAppApiAppUserNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetAppApiAppUserNameGetQueryKey = (name: string,
    params?: GetAppApiAppUserNameGetParams,) => {
    return [
    `/api/app/user/${name}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetAppApiAppUserNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppApiAppUserNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>> = ({ signal }) => getAppApiAppUserNameGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppApiAppUserNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>>
export type GetAppApiAppUserNameGetQueryError = HTTPValidationError


export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetAppApiAppUserNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>,
          TError,
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>,
          TError,
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get App
 */

export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAppApiAppUserNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create App
 */
export type createAppApiAppUserNamePostResponse200 = {
  data: unknown
  status: 200
}

export type createAppApiAppUserNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createAppApiAppUserNamePostResponseSuccess = (createAppApiAppUserNamePostResponse200) & {
  headers: Headers;
};
export type createAppApiAppUserNamePostResponseError = (createAppApiAppUserNamePostResponse422) & {
  headers: Headers;
};

export type createAppApiAppUserNamePostResponse = (createAppApiAppUserNamePostResponseSuccess | createAppApiAppUserNamePostResponseError)

export const getCreateAppApiAppUserNamePostUrl = (name: string,
    params: CreateAppApiAppUserNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const createAppApiAppUserNamePost = async (name: string,
    createAppApiAppUserNamePostBody: string,
    params: CreateAppApiAppUserNamePostParams, options?: RequestInit): Promise<createAppApiAppUserNamePostResponse> => {
  
  return customFetch<createAppApiAppUserNamePostResponse>(getCreateAppApiAppUserNamePostUrl(name,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createAppApiAppUserNamePostBody,)
  }
);}
  



export const getCreateAppApiAppUserNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext> => {

const mutationKey = ['createAppApiAppUserNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, {name: string;data: string;params: CreateAppApiAppUserNamePostParams}> = (props) => {
          const {name,data,params} = props ?? {};

          return  createAppApiAppUserNamePost(name,data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppApiAppUserNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>>
    export type CreateAppApiAppUserNamePostMutationBody = string
    export type CreateAppApiAppUserNamePostMutationError = HTTPValidationError

    /**
 * @summary Create App
 */
export const useCreateAppApiAppUserNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppApiAppUserNamePost>>,
        TError,
        {name: string;data: string;params: CreateAppApiAppUserNamePostParams},
        TContext
      > => {
      return useMutation(getCreateAppApiAppUserNamePostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete App
 */
export type deleteAppApiAppUserNameDeleteResponse200 = {
  data: DeleteAppApiAppUserNameDelete200
  status: 200
}

export type deleteAppApiAppUserNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteAppApiAppUserNameDeleteResponseSuccess = (deleteAppApiAppUserNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteAppApiAppUserNameDeleteResponseError = (deleteAppApiAppUserNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteAppApiAppUserNameDeleteResponse = (deleteAppApiAppUserNameDeleteResponseSuccess | deleteAppApiAppUserNameDeleteResponseError)

export const getDeleteAppApiAppUserNameDeleteUrl = (name: string,
    params?: DeleteAppApiAppUserNameDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}?${stringifiedParams}` : `/api/app/user/${name}`
}

export const deleteAppApiAppUserNameDelete = async (name: string,
    params?: DeleteAppApiAppUserNameDeleteParams, options?: RequestInit): Promise<deleteAppApiAppUserNameDeleteResponse> => {
  
  return customFetch<deleteAppApiAppUserNameDeleteResponse>(getDeleteAppApiAppUserNameDeleteUrl(name,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteAppApiAppUserNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext> => {

const mutationKey = ['deleteAppApiAppUserNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, {name: string;params?: DeleteAppApiAppUserNameDeleteParams}> = (props) => {
          const {name,params} = props ?? {};

          return  deleteAppApiAppUserNameDelete(name,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAppApiAppUserNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>>
    
    export type DeleteAppApiAppUserNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete App
 */
export const useDeleteAppApiAppUserNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>,
        TError,
        {name: string;params?: DeleteAppApiAppUserNameDeleteParams},
        TContext
      > => {
      return useMutation(getDeleteAppApiAppUserNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * @summary Update App
 */
export type updateAppApiAppUserNamePatchResponse200 = {
  data: EditResponse
  status: 200
}

export type updateAppApiAppUserNamePatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateAppApiAppUserNamePatchResponseSuccess = (updateAppApiAppUserNamePatchResponse200) & {
  headers: Headers;
};
export type updateAppApiAppUserNamePatchResponseError = (updateAppApiAppUserNamePatchResponse422) & {
  headers: Headers;
};

export type updateAppApiAppUserNamePatchResponse = (updateAppApiAppUserNamePatchResponseSuccess | updateAppApiAppUserNamePatchResponseError)

export const getUpdateAppApiAppUserNamePatchUrl = (name: string,) => {


  

  return `/api/app/user/${name}`
}

export const updateAppApiAppUserNamePatch = async (name: string,
    updateAppApiAppUserNamePatchBody: string, options?: RequestInit): Promise<updateAppApiAppUserNamePatchResponse> => {
  
  return customFetch<updateAppApiAppUserNamePatchResponse>(getUpdateAppApiAppUserNamePatchUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateAppApiAppUserNamePatchBody,)
  }
);}
  



export const getUpdateAppApiAppUserNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext> => {

const mutationKey = ['updateAppApiAppUserNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, {name: string;data: string}> = (props) => {
          const {name,data} = props ?? {};

          return  updateAppApiAppUserNamePatch(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAppApiAppUserNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>>
    export type UpdateAppApiAppUserNamePatchMutationBody = string
    export type UpdateAppApiAppUserNamePatchMutationError = HTTPValidationError

    /**
 * @summary Update App
 */
export const useUpdateAppApiAppUserNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>,
        TError,
        {name: string;data: string},
        TContext
      > => {
      return useMutation(getUpdateAppApiAppUserNamePatchMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get App Content
 */
export type getAppContentApiAppUserNameSpecGetResponse200 = {
  data: string
  status: 200
}

export type getAppContentApiAppUserNameSpecGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAppContentApiAppUserNameSpecGetResponseSuccess = (getAppContentApiAppUserNameSpecGetResponse200) & {
  headers: Headers;
};
export type getAppContentApiAppUserNameSpecGetResponseError = (getAppContentApiAppUserNameSpecGetResponse422) & {
  headers: Headers;
};

export type getAppContentApiAppUserNameSpecGetResponse = (getAppContentApiAppUserNameSpecGetResponseSuccess | getAppContentApiAppUserNameSpecGetResponseError)

export const getGetAppContentApiAppUserNameSpecGetUrl = (name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/app/user/${name}/spec?${stringifiedParams}` : `/api/app/user/${name}/spec`
}

export const getAppContentApiAppUserNameSpecGet = async (name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: RequestInit): Promise<getAppContentApiAppUserNameSpecGetResponse> => {
  
  return customFetch<getAppContentApiAppUserNameSpecGetResponse>(getGetAppContentApiAppUserNameSpecGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetAppContentApiAppUserNameSpecGetQueryKey = (name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams,) => {
    return [
    `/api/app/user/${name}/spec`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetAppContentApiAppUserNameSpecGetQueryOptions = <TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppContentApiAppUserNameSpecGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>> = ({ signal }) => getAppContentApiAppUserNameSpecGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppContentApiAppUserNameSpecGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>>
export type GetAppContentApiAppUserNameSpecGetQueryError = HTTPValidationError


export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetAppContentApiAppUserNameSpecGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get App Content
 */

export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAppContentApiAppUserNameSpecGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Rename App
 */
export type renameAppApiAppUserNameRenamePostResponse200 = {
  data: string
  status: 200
}

export type renameAppApiAppUserNameRenamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type renameAppApiAppUserNameRenamePostResponseSuccess = (renameAppApiAppUserNameRenamePostResponse200) & {
  headers: Headers;
};
export type renameAppApiAppUserNameRenamePostResponseError = (renameAppApiAppUserNameRenamePostResponse422) & {
  headers: Headers;
};

export type renameAppApiAppUserNameRenamePostResponse = (renameAppApiAppUserNameRenamePostResponseSuccess | renameAppApiAppUserNameRenamePostResponseError)

export const getRenameAppApiAppUserNameRenamePostUrl = (name: string,) => {


  

  return `/api/app/user/${name}/rename`
}

export const renameAppApiAppUserNameRenamePost = async (name: string,
    renameAppApiAppUserNameRenamePostBody: string, options?: RequestInit): Promise<renameAppApiAppUserNameRenamePostResponse> => {
  
  return customFetch<renameAppApiAppUserNameRenamePostResponse>(getRenameAppApiAppUserNameRenamePostUrl(name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      renameAppApiAppUserNameRenamePostBody,)
  }
);}
  



export const getRenameAppApiAppUserNameRenamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext> => {

const mutationKey = ['renameAppApiAppUserNameRenamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, {name: string;data: string}> = (props) => {
          const {name,data} = props ?? {};

          return  renameAppApiAppUserNameRenamePost(name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RenameAppApiAppUserNameRenamePostMutationResult = NonNullable<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>>
    export type RenameAppApiAppUserNameRenamePostMutationBody = string
    export type RenameAppApiAppUserNameRenamePostMutationError = HTTPValidationError

    /**
 * @summary Rename App
 */
export const useRenameAppApiAppUserNameRenamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>,
        TError,
        {name: string;data: string},
        TContext
      > => {
      return useMutation(getRenameAppApiAppUserNameRenamePostMutationOptions(options), queryClient);
    }
    
/**
 * Cancels the workflow.
 * @summary Cancel Workflow
 */
export type cancelWorkflowApiWorkflowNameCancelPostResponse200 = {
  data: CancelResponse
  status: 200
}

export type cancelWorkflowApiWorkflowNameCancelPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type cancelWorkflowApiWorkflowNameCancelPostResponseSuccess = (cancelWorkflowApiWorkflowNameCancelPostResponse200) & {
  headers: Headers;
};
export type cancelWorkflowApiWorkflowNameCancelPostResponseError = (cancelWorkflowApiWorkflowNameCancelPostResponse422) & {
  headers: Headers;
};

export type cancelWorkflowApiWorkflowNameCancelPostResponse = (cancelWorkflowApiWorkflowNameCancelPostResponseSuccess | cancelWorkflowApiWorkflowNameCancelPostResponseError)

export const getCancelWorkflowApiWorkflowNameCancelPostUrl = (name: string,
    params?: CancelWorkflowApiWorkflowNameCancelPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/cancel?${stringifiedParams}` : `/api/workflow/${name}/cancel`
}

export const cancelWorkflowApiWorkflowNameCancelPost = async (name: string,
    params?: CancelWorkflowApiWorkflowNameCancelPostParams, options?: RequestInit): Promise<cancelWorkflowApiWorkflowNameCancelPostResponse> => {
  
  return customFetch<cancelWorkflowApiWorkflowNameCancelPostResponse>(getCancelWorkflowApiWorkflowNameCancelPostUrl(name,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getCancelWorkflowApiWorkflowNameCancelPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext> => {

const mutationKey = ['cancelWorkflowApiWorkflowNameCancelPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, {name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}> = (props) => {
          const {name,params} = props ?? {};

          return  cancelWorkflowApiWorkflowNameCancelPost(name,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CancelWorkflowApiWorkflowNameCancelPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>>
    
    export type CancelWorkflowApiWorkflowNameCancelPostMutationError = HTTPValidationError

    /**
 * @summary Cancel Workflow
 */
export const useCancelWorkflowApiWorkflowNameCancelPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>,
        TError,
        {name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams},
        TContext
      > => {
      return useMutation(getCancelWorkflowApiWorkflowNameCancelPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary List Workflow
 */
export type listWorkflowApiWorkflowGetResponse200 = {
  data: string
  status: 200
}

export type listWorkflowApiWorkflowGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listWorkflowApiWorkflowGetResponseSuccess = (listWorkflowApiWorkflowGetResponse200) & {
  headers: Headers;
};
export type listWorkflowApiWorkflowGetResponseError = (listWorkflowApiWorkflowGetResponse422) & {
  headers: Headers;
};

export type listWorkflowApiWorkflowGetResponse = (listWorkflowApiWorkflowGetResponseSuccess | listWorkflowApiWorkflowGetResponseError)

export const getListWorkflowApiWorkflowGetUrl = (params?: ListWorkflowApiWorkflowGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow?${stringifiedParams}` : `/api/workflow`
}

export const listWorkflowApiWorkflowGet = async (params?: ListWorkflowApiWorkflowGetParams, options?: RequestInit): Promise<listWorkflowApiWorkflowGetResponse> => {
  
  return customFetch<listWorkflowApiWorkflowGetResponse>(getListWorkflowApiWorkflowGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListWorkflowApiWorkflowGetQueryKey = (params?: ListWorkflowApiWorkflowGetParams,) => {
    return [
    `/api/workflow`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListWorkflowApiWorkflowGetQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowApiWorkflowGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>> = ({ signal }) => listWorkflowApiWorkflowGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListWorkflowApiWorkflowGetQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>>
export type ListWorkflowApiWorkflowGetQueryError = HTTPValidationError


export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params: undefined |  ListWorkflowApiWorkflowGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Workflow
 */

export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListWorkflowApiWorkflowGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the task (with the latest retry_id) with the given name in the workflow.
 * @summary Get Workflow Task
 */
export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseSuccess = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse200) & {
  headers: Headers;
};
export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseError = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse422) & {
  headers: Headers;
};

export type getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse = (getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseSuccess | getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponseError)

export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetUrl = (name: string,
    taskName: string,) => {


  

  return `/api/workflow/${name}/task/${taskName}`
}

export const getWorkflowTaskApiWorkflowNameTaskTaskNameGet = async (name: string,
    taskName: string, options?: RequestInit): Promise<getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse> => {
  
  return customFetch<getWorkflowTaskApiWorkflowNameTaskTaskNameGetResponse>(getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetUrl(name,taskName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryKey = (name: string,
    taskName: string,) => {
    return [
    `/api/workflow/${name}/task/${taskName}`
    ] as const;
    }

    
export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryKey(name,taskName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>> = ({ signal }) => getWorkflowTaskApiWorkflowNameTaskTaskNameGet(name,taskName, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name && taskName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>>
export type GetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryError = HTTPValidationError


export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Task
 */

export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryOptions(name,taskName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary List Task
 */
export type listTaskApiTaskGetResponse200 = {
  data: string
  status: 200
}

export type listTaskApiTaskGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listTaskApiTaskGetResponseSuccess = (listTaskApiTaskGetResponse200) & {
  headers: Headers;
};
export type listTaskApiTaskGetResponseError = (listTaskApiTaskGetResponse422) & {
  headers: Headers;
};

export type listTaskApiTaskGetResponse = (listTaskApiTaskGetResponseSuccess | listTaskApiTaskGetResponseError)

export const getListTaskApiTaskGetUrl = (params?: ListTaskApiTaskGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/task?${stringifiedParams}` : `/api/task`
}

export const listTaskApiTaskGet = async (params?: ListTaskApiTaskGetParams, options?: RequestInit): Promise<listTaskApiTaskGetResponse> => {
  
  return customFetch<listTaskApiTaskGetResponse>(getListTaskApiTaskGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListTaskApiTaskGetQueryKey = (params?: ListTaskApiTaskGetParams,) => {
    return [
    `/api/task`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListTaskApiTaskGetQueryOptions = <TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTaskApiTaskGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTaskApiTaskGet>>> = ({ signal }) => listTaskApiTaskGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTaskApiTaskGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTaskApiTaskGet>>>
export type ListTaskApiTaskGetQueryError = HTTPValidationError


export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params: undefined |  ListTaskApiTaskGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTaskApiTaskGet>>,
          TError,
          Awaited<ReturnType<typeof listTaskApiTaskGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTaskApiTaskGet>>,
          TError,
          Awaited<ReturnType<typeof listTaskApiTaskGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Task
 */

export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTaskApiTaskGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow with the given name in the database.
 * @summary Get Workflow
 */
export type getWorkflowApiWorkflowNameGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowApiWorkflowNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowApiWorkflowNameGetResponseSuccess = (getWorkflowApiWorkflowNameGetResponse200) & {
  headers: Headers;
};
export type getWorkflowApiWorkflowNameGetResponseError = (getWorkflowApiWorkflowNameGetResponse422) & {
  headers: Headers;
};

export type getWorkflowApiWorkflowNameGetResponse = (getWorkflowApiWorkflowNameGetResponseSuccess | getWorkflowApiWorkflowNameGetResponseError)

export const getGetWorkflowApiWorkflowNameGetUrl = (name: string,
    params?: GetWorkflowApiWorkflowNameGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}?${stringifiedParams}` : `/api/workflow/${name}`
}

export const getWorkflowApiWorkflowNameGet = async (name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: RequestInit): Promise<getWorkflowApiWorkflowNameGetResponse> => {
  
  return customFetch<getWorkflowApiWorkflowNameGetResponse>(getGetWorkflowApiWorkflowNameGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowApiWorkflowNameGetQueryKey = (name: string,
    params?: GetWorkflowApiWorkflowNameGetParams,) => {
    return [
    `/api/workflow/${name}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWorkflowApiWorkflowNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowApiWorkflowNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>> = ({ signal }) => getWorkflowApiWorkflowNameGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowApiWorkflowNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>>
export type GetWorkflowApiWorkflowNameGetQueryError = HTTPValidationError


export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowApiWorkflowNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow
 */

export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowApiWorkflowNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow logs.
 * @summary Get Workflow Logs
 */
export type getWorkflowLogsApiWorkflowNameLogsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowLogsApiWorkflowNameLogsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowLogsApiWorkflowNameLogsGetResponseSuccess = (getWorkflowLogsApiWorkflowNameLogsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowLogsApiWorkflowNameLogsGetResponseError = (getWorkflowLogsApiWorkflowNameLogsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowLogsApiWorkflowNameLogsGetResponse = (getWorkflowLogsApiWorkflowNameLogsGetResponseSuccess | getWorkflowLogsApiWorkflowNameLogsGetResponseError)

export const getGetWorkflowLogsApiWorkflowNameLogsGetUrl = (name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/logs?${stringifiedParams}` : `/api/workflow/${name}/logs`
}

export const getWorkflowLogsApiWorkflowNameLogsGet = async (name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: RequestInit): Promise<getWorkflowLogsApiWorkflowNameLogsGetResponse> => {
  
  return customFetch<getWorkflowLogsApiWorkflowNameLogsGetResponse>(getGetWorkflowLogsApiWorkflowNameLogsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowLogsApiWorkflowNameLogsGetQueryKey = (name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams,) => {
    return [
    `/api/workflow/${name}/logs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWorkflowLogsApiWorkflowNameLogsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowLogsApiWorkflowNameLogsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>> = ({ signal }) => getWorkflowLogsApiWorkflowNameLogsGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowLogsApiWorkflowNameLogsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>>
export type GetWorkflowLogsApiWorkflowNameLogsGetQueryError = HTTPValidationError


export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowLogsApiWorkflowNameLogsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Logs
 */

export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowLogsApiWorkflowNameLogsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow pod conditions.
 * @summary Get Workflow Pod Conditions
 */
export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponseSuccess = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponseError = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowPodConditionsApiWorkflowNameEventsGetResponse = (getWorkflowPodConditionsApiWorkflowNameEventsGetResponseSuccess | getWorkflowPodConditionsApiWorkflowNameEventsGetResponseError)

export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetUrl = (name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/events?${stringifiedParams}` : `/api/workflow/${name}/events`
}

export const getWorkflowPodConditionsApiWorkflowNameEventsGet = async (name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: RequestInit): Promise<getWorkflowPodConditionsApiWorkflowNameEventsGetResponse> => {
  
  return customFetch<getWorkflowPodConditionsApiWorkflowNameEventsGetResponse>(getGetWorkflowPodConditionsApiWorkflowNameEventsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryKey = (name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams,) => {
    return [
    `/api/workflow/${name}/events`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>> = ({ signal }) => getWorkflowPodConditionsApiWorkflowNameEventsGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowPodConditionsApiWorkflowNameEventsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>>
export type GetWorkflowPodConditionsApiWorkflowNameEventsGetQueryError = HTTPValidationError


export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Pod Conditions
 */

export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow error logs.
 * @summary Get Workflow Error Logs
 */
export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseSuccess = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse200) & {
  headers: Headers;
};
export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseError = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse422) & {
  headers: Headers;
};

export type getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse = (getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseSuccess | getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponseError)

export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetUrl = (name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/error_logs?${stringifiedParams}` : `/api/workflow/${name}/error_logs`
}

export const getWorkflowErrorLogsApiWorkflowNameErrorLogsGet = async (name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: RequestInit): Promise<getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse> => {
  
  return customFetch<getWorkflowErrorLogsApiWorkflowNameErrorLogsGetResponse>(getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryKey = (name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams,) => {
    return [
    `/api/workflow/${name}/error_logs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>> = ({ signal }) => getWorkflowErrorLogsApiWorkflowNameErrorLogsGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>>
export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryError = HTTPValidationError


export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Error Logs
 */

export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow spec.
 * @summary Get Workflow Spec
 */
export type getWorkflowSpecApiWorkflowNameSpecGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowSpecApiWorkflowNameSpecGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getWorkflowSpecApiWorkflowNameSpecGetResponseSuccess = (getWorkflowSpecApiWorkflowNameSpecGetResponse200) & {
  headers: Headers;
};
export type getWorkflowSpecApiWorkflowNameSpecGetResponseError = (getWorkflowSpecApiWorkflowNameSpecGetResponse422) & {
  headers: Headers;
};

export type getWorkflowSpecApiWorkflowNameSpecGetResponse = (getWorkflowSpecApiWorkflowNameSpecGetResponseSuccess | getWorkflowSpecApiWorkflowNameSpecGetResponseError)

export const getGetWorkflowSpecApiWorkflowNameSpecGetUrl = (name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/spec?${stringifiedParams}` : `/api/workflow/${name}/spec`
}

export const getWorkflowSpecApiWorkflowNameSpecGet = async (name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: RequestInit): Promise<getWorkflowSpecApiWorkflowNameSpecGetResponse> => {
  
  return customFetch<getWorkflowSpecApiWorkflowNameSpecGetResponse>(getGetWorkflowSpecApiWorkflowNameSpecGetUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowSpecApiWorkflowNameSpecGetQueryKey = (name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams,) => {
    return [
    `/api/workflow/${name}/spec`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetWorkflowSpecApiWorkflowNameSpecGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowSpecApiWorkflowNameSpecGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>> = ({ signal }) => getWorkflowSpecApiWorkflowNameSpecGet(name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowSpecApiWorkflowNameSpecGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>>
export type GetWorkflowSpecApiWorkflowNameSpecGetQueryError = HTTPValidationError


export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowSpecApiWorkflowNameSpecGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Spec
 */

export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowSpecApiWorkflowNameSpecGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the workflow spec.
 * @summary Tag Workflow
 */
export type tagWorkflowApiWorkflowNameTagPostResponse200 = {
  data: unknown
  status: 200
}

export type tagWorkflowApiWorkflowNameTagPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type tagWorkflowApiWorkflowNameTagPostResponseSuccess = (tagWorkflowApiWorkflowNameTagPostResponse200) & {
  headers: Headers;
};
export type tagWorkflowApiWorkflowNameTagPostResponseError = (tagWorkflowApiWorkflowNameTagPostResponse422) & {
  headers: Headers;
};

export type tagWorkflowApiWorkflowNameTagPostResponse = (tagWorkflowApiWorkflowNameTagPostResponseSuccess | tagWorkflowApiWorkflowNameTagPostResponseError)

export const getTagWorkflowApiWorkflowNameTagPostUrl = (name: string,
    params?: TagWorkflowApiWorkflowNameTagPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/tag?${stringifiedParams}` : `/api/workflow/${name}/tag`
}

export const tagWorkflowApiWorkflowNameTagPost = async (name: string,
    params?: TagWorkflowApiWorkflowNameTagPostParams, options?: RequestInit): Promise<tagWorkflowApiWorkflowNameTagPostResponse> => {
  
  return customFetch<tagWorkflowApiWorkflowNameTagPostResponse>(getTagWorkflowApiWorkflowNameTagPostUrl(name,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getTagWorkflowApiWorkflowNameTagPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext> => {

const mutationKey = ['tagWorkflowApiWorkflowNameTagPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, {name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}> = (props) => {
          const {name,params} = props ?? {};

          return  tagWorkflowApiWorkflowNameTagPost(name,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TagWorkflowApiWorkflowNameTagPostMutationResult = NonNullable<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>>
    
    export type TagWorkflowApiWorkflowNameTagPostMutationError = HTTPValidationError

    /**
 * @summary Tag Workflow
 */
export const useTagWorkflowApiWorkflowNameTagPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>,
        TError,
        {name: string;params?: TagWorkflowApiWorkflowNameTagPostParams},
        TContext
      > => {
      return useMutation(getTagWorkflowApiWorkflowNameTagPostMutationOptions(options), queryClient);
    }
    
/**
 * Send command to all tasks in a group.
 * @summary Exec Into Group
 */
export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse200 = {
  data: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200
  status: 200
}

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseSuccess = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse200) & {
  headers: Headers;
};
export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseError = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse422) & {
  headers: Headers;
};

export type execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse = (execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseSuccess | execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponseError)

export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostUrl = (name: string,
    groupName: string,
    params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/exec/group/${groupName}?${stringifiedParams}` : `/api/workflow/${name}/exec/group/${groupName}`
}

export const execIntoGroupApiWorkflowNameExecGroupGroupNamePost = async (name: string,
    groupName: string,
    params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams, options?: RequestInit): Promise<execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse> => {
  
  return customFetch<execIntoGroupApiWorkflowNameExecGroupGroupNamePostResponse>(getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostUrl(name,groupName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext> => {

const mutationKey = ['execIntoGroupApiWorkflowNameExecGroupGroupNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, {name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}> = (props) => {
          const {name,groupName,params} = props ?? {};

          return  execIntoGroupApiWorkflowNameExecGroupGroupNamePost(name,groupName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>>
    
    export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationError = HTTPValidationError

    /**
 * @summary Exec Into Group
 */
export const useExecIntoGroupApiWorkflowNameExecGroupGroupNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>,
        TError,
        {name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams},
        TContext
      > => {
      return useMutation(getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Exec into a task container.
 * @summary Exec Into Task
 */
export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseSuccess = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse200) & {
  headers: Headers;
};
export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseError = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse422) & {
  headers: Headers;
};

export type execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse = (execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseSuccess | execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponseError)

export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostUrl = (name: string,
    taskName: string,
    params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/exec/task/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/exec/task/${taskName}`
}

export const execIntoTaskApiWorkflowNameExecTaskTaskNamePost = async (name: string,
    taskName: string,
    params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams, options?: RequestInit): Promise<execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse> => {
  
  return customFetch<execIntoTaskApiWorkflowNameExecTaskTaskNamePostResponse>(getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext> => {

const mutationKey = ['execIntoTaskApiWorkflowNameExecTaskTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, {name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  execIntoTaskApiWorkflowNameExecTaskTaskNamePost(name,taskName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>>
    
    export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Exec Into Task
 */
export const useExecIntoTaskApiWorkflowNameExecTaskTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>,
        TError,
        {name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams},
        TContext
      > => {
      return useMutation(getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Portforward into a task container.
 * @summary Port Forward Task
 */
export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse200 = {
  data: RouterResponse[] | RouterResponse
  status: 200
}

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseSuccess = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse200) & {
  headers: Headers;
};
export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseError = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse422) & {
  headers: Headers;
};

export type portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse = (portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseSuccess | portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponseError)

export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostUrl = (name: string,
    taskName: string,
    params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/portforward/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/portforward/${taskName}`
}

export const portForwardTaskApiWorkflowNamePortforwardTaskNamePost = async (name: string,
    taskName: string,
    params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams, options?: RequestInit): Promise<portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse> => {
  
  return customFetch<portForwardTaskApiWorkflowNamePortforwardTaskNamePostResponse>(getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext> => {

const mutationKey = ['portForwardTaskApiWorkflowNamePortforwardTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, {name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  portForwardTaskApiWorkflowNamePortforwardTaskNamePost(name,taskName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>>
    
    export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Port Forward Task
 */
export const usePortForwardTaskApiWorkflowNamePortforwardTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>,
        TError,
        {name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams},
        TContext
      > => {
      return useMutation(getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Hold a webserver connection to a task container.
 * @summary Port Forward Webserver
 */
export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseSuccess = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse200) & {
  headers: Headers;
};
export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseError = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse422) & {
  headers: Headers;
};

export type portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse = (portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseSuccess | portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponseError)

export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostUrl = (name: string,
    taskName: string,
    params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/workflow/${name}/webserver/${taskName}?${stringifiedParams}` : `/api/workflow/${name}/webserver/${taskName}`
}

export const portForwardWebserverApiWorkflowNameWebserverTaskNamePost = async (name: string,
    taskName: string,
    params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams, options?: RequestInit): Promise<portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse> => {
  
  return customFetch<portForwardWebserverApiWorkflowNameWebserverTaskNamePostResponse>(getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostUrl(name,taskName,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext> => {

const mutationKey = ['portForwardWebserverApiWorkflowNameWebserverTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, {name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  portForwardWebserverApiWorkflowNameWebserverTaskNamePost(name,taskName,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>>
    
    export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Port Forward Webserver
 */
export const usePortForwardWebserverApiWorkflowNameWebserverTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>,
        TError,
        {name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams},
        TContext
      > => {
      return useMutation(getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Rsync into a task container.
 * @summary Rsync Task
 */
export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse200 = {
  data: RouterResponse
  status: 200
}

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseSuccess = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse200) & {
  headers: Headers;
};
export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseError = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse422) & {
  headers: Headers;
};

export type rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse = (rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseSuccess | rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponseError)

export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostUrl = (name: string,
    taskName: string,) => {


  

  return `/api/workflow/${name}/rsync/task/${taskName}`
}

export const rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost = async (name: string,
    taskName: string, options?: RequestInit): Promise<rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse> => {
  
  return customFetch<rsyncTaskApiWorkflowNameRsyncTaskTaskNamePostResponse>(getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostUrl(name,taskName),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext> => {

const mutationKey = ['rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, {name: string;taskName: string}> = (props) => {
          const {name,taskName} = props ?? {};

          return  rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost(name,taskName,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>>
    
    export type RsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Rsync Task
 */
export const useRsyncTaskApiWorkflowNameRsyncTaskTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>,
        TError,
        {name: string;taskName: string},
        TContext
      > => {
      return useMutation(getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Get default/all user credentials
 * @summary Get User Credential
 */
export type getUserCredentialApiCredentialsGetResponse200 = {
  data: string
  status: 200
}

export type getUserCredentialApiCredentialsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getUserCredentialApiCredentialsGetResponseSuccess = (getUserCredentialApiCredentialsGetResponse200) & {
  headers: Headers;
};
export type getUserCredentialApiCredentialsGetResponseError = (getUserCredentialApiCredentialsGetResponse422) & {
  headers: Headers;
};

export type getUserCredentialApiCredentialsGetResponse = (getUserCredentialApiCredentialsGetResponseSuccess | getUserCredentialApiCredentialsGetResponseError)

export const getGetUserCredentialApiCredentialsGetUrl = () => {


  

  return `/api/credentials`
}

export const getUserCredentialApiCredentialsGet = async ( options?: RequestInit): Promise<getUserCredentialApiCredentialsGetResponse> => {
  
  return customFetch<getUserCredentialApiCredentialsGetResponse>(getGetUserCredentialApiCredentialsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetUserCredentialApiCredentialsGetQueryKey = () => {
    return [
    `/api/credentials`
    ] as const;
    }

    
export const getGetUserCredentialApiCredentialsGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserCredentialApiCredentialsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>> = ({ signal }) => getUserCredentialApiCredentialsGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserCredentialApiCredentialsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>>
export type GetUserCredentialApiCredentialsGetQueryError = HTTPValidationError


export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Credential
 */

export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserCredentialApiCredentialsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Post/Update user credentials
 * @summary Set User Credential
 */
export type setUserCredentialApiCredentialsCredNamePostResponse200 = {
  data: unknown
  status: 200
}

export type setUserCredentialApiCredentialsCredNamePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type setUserCredentialApiCredentialsCredNamePostResponseSuccess = (setUserCredentialApiCredentialsCredNamePostResponse200) & {
  headers: Headers;
};
export type setUserCredentialApiCredentialsCredNamePostResponseError = (setUserCredentialApiCredentialsCredNamePostResponse422) & {
  headers: Headers;
};

export type setUserCredentialApiCredentialsCredNamePostResponse = (setUserCredentialApiCredentialsCredNamePostResponseSuccess | setUserCredentialApiCredentialsCredNamePostResponseError)

export const getSetUserCredentialApiCredentialsCredNamePostUrl = (credName: string,) => {


  

  return `/api/credentials/${credName}`
}

export const setUserCredentialApiCredentialsCredNamePost = async (credName: string,
    credentialOptions: CredentialOptions, options?: RequestInit): Promise<setUserCredentialApiCredentialsCredNamePostResponse> => {
  
  return customFetch<setUserCredentialApiCredentialsCredNamePostResponse>(getSetUserCredentialApiCredentialsCredNamePostUrl(credName),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      credentialOptions,)
  }
);}
  



export const getSetUserCredentialApiCredentialsCredNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext> => {

const mutationKey = ['setUserCredentialApiCredentialsCredNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, {credName: string;data: CredentialOptions}> = (props) => {
          const {credName,data} = props ?? {};

          return  setUserCredentialApiCredentialsCredNamePost(credName,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SetUserCredentialApiCredentialsCredNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>>
    export type SetUserCredentialApiCredentialsCredNamePostMutationBody = CredentialOptions
    export type SetUserCredentialApiCredentialsCredNamePostMutationError = HTTPValidationError

    /**
 * @summary Set User Credential
 */
export const useSetUserCredentialApiCredentialsCredNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>,
        TError,
        {credName: string;data: CredentialOptions},
        TContext
      > => {
      return useMutation(getSetUserCredentialApiCredentialsCredNamePostMutationOptions(options), queryClient);
    }
    
/**
 * Delete user credentials given the secret_id
 * @summary Delete Users Credential
 */
export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse200 = {
  data: CredentialGetResponse
  status: 200
}

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponseSuccess = (deleteUsersCredentialApiCredentialsCredNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteUsersCredentialApiCredentialsCredNameDeleteResponseError = (deleteUsersCredentialApiCredentialsCredNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteUsersCredentialApiCredentialsCredNameDeleteResponse = (deleteUsersCredentialApiCredentialsCredNameDeleteResponseSuccess | deleteUsersCredentialApiCredentialsCredNameDeleteResponseError)

export const getDeleteUsersCredentialApiCredentialsCredNameDeleteUrl = (credName: string,) => {


  

  return `/api/credentials/${credName}`
}

export const deleteUsersCredentialApiCredentialsCredNameDelete = async (credName: string, options?: RequestInit): Promise<deleteUsersCredentialApiCredentialsCredNameDeleteResponse> => {
  
  return customFetch<deleteUsersCredentialApiCredentialsCredNameDeleteResponse>(getDeleteUsersCredentialApiCredentialsCredNameDeleteUrl(credName),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteUsersCredentialApiCredentialsCredNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext> => {

const mutationKey = ['deleteUsersCredentialApiCredentialsCredNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, {credName: string}> = (props) => {
          const {credName} = props ?? {};

          return  deleteUsersCredentialApiCredentialsCredNameDelete(credName,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersCredentialApiCredentialsCredNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>>
    
    export type DeleteUsersCredentialApiCredentialsCredNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Users Credential
 */
export const useDeleteUsersCredentialApiCredentialsCredNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>,
        TError,
        {credName: string},
        TContext
      > => {
      return useMutation(getDeleteUsersCredentialApiCredentialsCredNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * Returns the information of resources available in different pools.
 * @summary Get Resources
 */
export type getResourcesApiResourcesGetResponse200 = {
  data: string
  status: 200
}

export type getResourcesApiResourcesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getResourcesApiResourcesGetResponseSuccess = (getResourcesApiResourcesGetResponse200) & {
  headers: Headers;
};
export type getResourcesApiResourcesGetResponseError = (getResourcesApiResourcesGetResponse422) & {
  headers: Headers;
};

export type getResourcesApiResourcesGetResponse = (getResourcesApiResourcesGetResponseSuccess | getResourcesApiResourcesGetResponseError)

export const getGetResourcesApiResourcesGetUrl = (params?: GetResourcesApiResourcesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/resources?${stringifiedParams}` : `/api/resources`
}

export const getResourcesApiResourcesGet = async (params?: GetResourcesApiResourcesGetParams, options?: RequestInit): Promise<getResourcesApiResourcesGetResponse> => {
  
  return customFetch<getResourcesApiResourcesGetResponse>(getGetResourcesApiResourcesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetResourcesApiResourcesGetQueryKey = (params?: GetResourcesApiResourcesGetParams,) => {
    return [
    `/api/resources`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetResourcesApiResourcesGetQueryOptions = <TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResourcesApiResourcesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>> = ({ signal }) => getResourcesApiResourcesGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResourcesApiResourcesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>>
export type GetResourcesApiResourcesGetQueryError = HTTPValidationError


export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params: undefined |  GetResourcesApiResourcesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>,
          TError,
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>,
          TError,
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Resources
 */

export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResourcesApiResourcesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the request resource's information.
 * @summary Get One Resource
 */
export type getOneResourceApiResourcesNameGetResponse200 = {
  data: string
  status: 200
}

export type getOneResourceApiResourcesNameGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getOneResourceApiResourcesNameGetResponseSuccess = (getOneResourceApiResourcesNameGetResponse200) & {
  headers: Headers;
};
export type getOneResourceApiResourcesNameGetResponseError = (getOneResourceApiResourcesNameGetResponse422) & {
  headers: Headers;
};

export type getOneResourceApiResourcesNameGetResponse = (getOneResourceApiResourcesNameGetResponseSuccess | getOneResourceApiResourcesNameGetResponseError)

export const getGetOneResourceApiResourcesNameGetUrl = (name: string,) => {


  

  return `/api/resources/${name}`
}

export const getOneResourceApiResourcesNameGet = async (name: string, options?: RequestInit): Promise<getOneResourceApiResourcesNameGetResponse> => {
  
  return customFetch<getOneResourceApiResourcesNameGetResponse>(getGetOneResourceApiResourcesNameGetUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetOneResourceApiResourcesNameGetQueryKey = (name: string,) => {
    return [
    `/api/resources/${name}`
    ] as const;
    }

    
export const getGetOneResourceApiResourcesNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOneResourceApiResourcesNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>> = ({ signal }) => getOneResourceApiResourcesNameGet(name, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneResourceApiResourcesNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>>
export type GetOneResourceApiResourcesNameGetQueryError = HTTPValidationError


export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>,
          TError,
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>,
          TError,
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get One Resource
 */

export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOneResourceApiResourcesNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns information regarding pools to users.

If all_pools is set to true, all pools' information will be returned in API response.
Otherwise, only information from pools that the user has access to will be returned
in the response.
 * @summary Get Pools
 */
export type getPoolsApiPoolGetResponse200 = {
  data: string
  status: 200
}

export type getPoolsApiPoolGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getPoolsApiPoolGetResponseSuccess = (getPoolsApiPoolGetResponse200) & {
  headers: Headers;
};
export type getPoolsApiPoolGetResponseError = (getPoolsApiPoolGetResponse422) & {
  headers: Headers;
};

export type getPoolsApiPoolGetResponse = (getPoolsApiPoolGetResponseSuccess | getPoolsApiPoolGetResponseError)

export const getGetPoolsApiPoolGetUrl = (params?: GetPoolsApiPoolGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool?${stringifiedParams}` : `/api/pool`
}

export const getPoolsApiPoolGet = async (params?: GetPoolsApiPoolGetParams, options?: RequestInit): Promise<getPoolsApiPoolGetResponse> => {
  
  return customFetch<getPoolsApiPoolGetResponse>(getGetPoolsApiPoolGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetPoolsApiPoolGetQueryKey = (params?: GetPoolsApiPoolGetParams,) => {
    return [
    `/api/pool`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPoolsApiPoolGetQueryOptions = <TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPoolsApiPoolGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPoolsApiPoolGet>>> = ({ signal }) => getPoolsApiPoolGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPoolsApiPoolGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPoolsApiPoolGet>>>
export type GetPoolsApiPoolGetQueryError = HTTPValidationError


export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPoolsApiPoolGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pools
 */

export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPoolsApiPoolGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get Pool Quotas
 */
export type getPoolQuotasApiPoolQuotaGetResponse200 = {
  data: string
  status: 200
}

export type getPoolQuotasApiPoolQuotaGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getPoolQuotasApiPoolQuotaGetResponseSuccess = (getPoolQuotasApiPoolQuotaGetResponse200) & {
  headers: Headers;
};
export type getPoolQuotasApiPoolQuotaGetResponseError = (getPoolQuotasApiPoolQuotaGetResponse422) & {
  headers: Headers;
};

export type getPoolQuotasApiPoolQuotaGetResponse = (getPoolQuotasApiPoolQuotaGetResponseSuccess | getPoolQuotasApiPoolQuotaGetResponseError)

export const getGetPoolQuotasApiPoolQuotaGetUrl = (params?: GetPoolQuotasApiPoolQuotaGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool_quota?${stringifiedParams}` : `/api/pool_quota`
}

export const getPoolQuotasApiPoolQuotaGet = async (params?: GetPoolQuotasApiPoolQuotaGetParams, options?: RequestInit): Promise<getPoolQuotasApiPoolQuotaGetResponse> => {
  
  return customFetch<getPoolQuotasApiPoolQuotaGetResponse>(getGetPoolQuotasApiPoolQuotaGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetPoolQuotasApiPoolQuotaGetQueryKey = (params?: GetPoolQuotasApiPoolQuotaGetParams,) => {
    return [
    `/api/pool_quota`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetPoolQuotasApiPoolQuotaGetQueryOptions = <TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPoolQuotasApiPoolQuotaGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>> = ({ signal }) => getPoolQuotasApiPoolQuotaGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPoolQuotasApiPoolQuotaGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>>
export type GetPoolQuotasApiPoolQuotaGetQueryError = HTTPValidationError


export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPoolQuotasApiPoolQuotaGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pool Quotas
 */

export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPoolQuotasApiPoolQuotaGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * This api validates that a workflow is well formed and valid and then submits it.
 * @summary Submit Workflow
 */
export type submitWorkflowApiPoolPoolNameWorkflowPostResponse200 = {
  data: SubmitResponse
  status: 200
}

export type submitWorkflowApiPoolPoolNameWorkflowPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type submitWorkflowApiPoolPoolNameWorkflowPostResponseSuccess = (submitWorkflowApiPoolPoolNameWorkflowPostResponse200) & {
  headers: Headers;
};
export type submitWorkflowApiPoolPoolNameWorkflowPostResponseError = (submitWorkflowApiPoolPoolNameWorkflowPostResponse422) & {
  headers: Headers;
};

export type submitWorkflowApiPoolPoolNameWorkflowPostResponse = (submitWorkflowApiPoolPoolNameWorkflowPostResponseSuccess | submitWorkflowApiPoolPoolNameWorkflowPostResponseError)

export const getSubmitWorkflowApiPoolPoolNameWorkflowPostUrl = (poolName: string,
    params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/pool/${poolName}/workflow?${stringifiedParams}` : `/api/pool/${poolName}/workflow`
}

export const submitWorkflowApiPoolPoolNameWorkflowPost = async (poolName: string,
    templateSpec: TemplateSpec,
    params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams, options?: RequestInit): Promise<submitWorkflowApiPoolPoolNameWorkflowPostResponse> => {
  
  return customFetch<submitWorkflowApiPoolPoolNameWorkflowPostResponse>(getSubmitWorkflowApiPoolPoolNameWorkflowPostUrl(poolName,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      templateSpec,)
  }
);}
  



export const getSubmitWorkflowApiPoolPoolNameWorkflowPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext> => {

const mutationKey = ['submitWorkflowApiPoolPoolNameWorkflowPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, {poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}> = (props) => {
          const {poolName,data,params} = props ?? {};

          return  submitWorkflowApiPoolPoolNameWorkflowPost(poolName,data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationResult = NonNullable<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>>
    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationBody = TemplateSpec
    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationError = HTTPValidationError

    /**
 * @summary Submit Workflow
 */
export const useSubmitWorkflowApiPoolPoolNameWorkflowPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>,
        TError,
        {poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams},
        TContext
      > => {
      return useMutation(getSubmitWorkflowApiPoolPoolNameWorkflowPostMutationOptions(options), queryClient);
    }
    
/**
 * This api restarts a failed workflow and then submits it.
 * @summary Restart Workflow
 */
export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse200 = {
  data: SubmitResponse
  status: 200
}

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseSuccess = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse200) & {
  headers: Headers;
};
export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseError = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse422) & {
  headers: Headers;
};

export type restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse = (restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseSuccess | restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponseError)

export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostUrl = (poolName: string,
    workflowId: string,) => {


  

  return `/api/pool/${poolName}/workflow/${workflowId}/restart`
}

export const restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost = async (poolName: string,
    workflowId: string, options?: RequestInit): Promise<restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse> => {
  
  return customFetch<restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostResponse>(getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostUrl(poolName,workflowId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}
  



export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext> => {

const mutationKey = ['restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, {poolName: string;workflowId: string}> = (props) => {
          const {poolName,workflowId} = props ?? {};

          return  restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost(poolName,workflowId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationResult = NonNullable<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>>
    
    export type RestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationError = HTTPValidationError

    /**
 * @summary Restart Workflow
 */
export const useRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>,
        TError,
        {poolName: string;workflowId: string},
        TContext
      > => {
      return useMutation(getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationOptions(options), queryClient);
    }
    
/**
 * This api allows users to fetch the default bucket and the list of available buckets.
 * @summary Get Bucket Info
 */
export type getBucketInfoApiBucketGetResponse200 = {
  data: BucketInfoResponse
  status: 200
}

export type getBucketInfoApiBucketGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getBucketInfoApiBucketGetResponseSuccess = (getBucketInfoApiBucketGetResponse200) & {
  headers: Headers;
};
export type getBucketInfoApiBucketGetResponseError = (getBucketInfoApiBucketGetResponse422) & {
  headers: Headers;
};

export type getBucketInfoApiBucketGetResponse = (getBucketInfoApiBucketGetResponseSuccess | getBucketInfoApiBucketGetResponseError)

export const getGetBucketInfoApiBucketGetUrl = (params?: GetBucketInfoApiBucketGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket?${stringifiedParams}` : `/api/bucket`
}

export const getBucketInfoApiBucketGet = async (params?: GetBucketInfoApiBucketGetParams, options?: RequestInit): Promise<getBucketInfoApiBucketGetResponse> => {
  
  return customFetch<getBucketInfoApiBucketGetResponse>(getGetBucketInfoApiBucketGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetBucketInfoApiBucketGetQueryKey = (params?: GetBucketInfoApiBucketGetParams,) => {
    return [
    `/api/bucket`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetBucketInfoApiBucketGetQueryOptions = <TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBucketInfoApiBucketGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>> = ({ signal }) => getBucketInfoApiBucketGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBucketInfoApiBucketGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>>
export type GetBucketInfoApiBucketGetQueryError = HTTPValidationError


export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params: undefined |  GetBucketInfoApiBucketGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bucket Info
 */

export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBucketInfoApiBucketGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * This api deletes a Dataset.
 * @summary Delete Dataset
 */
export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponseSuccess = (deleteDatasetApiBucketBucketDatasetNameDeleteResponse200) & {
  headers: Headers;
};
export type deleteDatasetApiBucketBucketDatasetNameDeleteResponseError = (deleteDatasetApiBucketBucketDatasetNameDeleteResponse422) & {
  headers: Headers;
};

export type deleteDatasetApiBucketBucketDatasetNameDeleteResponse = (deleteDatasetApiBucketBucketDatasetNameDeleteResponseSuccess | deleteDatasetApiBucketBucketDatasetNameDeleteResponseError)

export const getDeleteDatasetApiBucketBucketDatasetNameDeleteUrl = (bucket: string,
    name: string,
    params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}`
}

export const deleteDatasetApiBucketBucketDatasetNameDelete = async (bucket: string,
    name: string,
    params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams, options?: RequestInit): Promise<deleteDatasetApiBucketBucketDatasetNameDeleteResponse> => {
  
  return customFetch<deleteDatasetApiBucketBucketDatasetNameDeleteResponse>(getDeleteDatasetApiBucketBucketDatasetNameDeleteUrl(bucket,name,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  



export const getDeleteDatasetApiBucketBucketDatasetNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext> => {

const mutationKey = ['deleteDatasetApiBucketBucketDatasetNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, {bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}> = (props) => {
          const {bucket,name,params} = props ?? {};

          return  deleteDatasetApiBucketBucketDatasetNameDelete(bucket,name,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetApiBucketBucketDatasetNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>>
    
    export type DeleteDatasetApiBucketBucketDatasetNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDatasetApiBucketBucketDatasetNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>,
        TError,
        {bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams},
        TContext
      > => {
      return useMutation(getDeleteDatasetApiBucketBucketDatasetNameDeleteMutationOptions(options), queryClient);
    }
    
/**
 * This api can rename a dataset/collection or set/remove tags/labels/metadata.
If tag is not given, latest tag is selected
 * @summary Change Name Tag Label Metadata
 */
export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse200 = {
  data: DataAttributeResponse
  status: 200
}

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseSuccess = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse200) & {
  headers: Headers;
};
export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseError = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse422) & {
  headers: Headers;
};

export type changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse = (changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseSuccess | changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponseError)

export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostUrl = (bucket: string,
    name: string,
    params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}/attribute?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}/attribute`
}

export const changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost = async (bucket: string,
    name: string,
    bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,
    params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams, options?: RequestInit): Promise<changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse> => {
  
  return customFetch<changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostResponse>(getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostUrl(bucket,name,params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,)
  }
);}
  



export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext> => {

const mutationKey = ['changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, {bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}> = (props) => {
          const {bucket,name,data,params} = props ?? {};

          return  changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost(bucket,name,data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationResult = NonNullable<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>>
    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationBody = BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost
    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationError = HTTPValidationError

    /**
 * @summary Change Name Tag Label Metadata
 */
export const useChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>,
        TError,
        {bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams},
        TContext
      > => {
      return useMutation(getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationOptions(options), queryClient);
    }
    
/**
 * This api gives info about the Dataset or Dataset Version.
 * @summary Get Info
 */
export type getInfoApiBucketBucketDatasetNameInfoGetResponse200 = {
  data: DataInfoResponse
  status: 200
}

export type getInfoApiBucketBucketDatasetNameInfoGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getInfoApiBucketBucketDatasetNameInfoGetResponseSuccess = (getInfoApiBucketBucketDatasetNameInfoGetResponse200) & {
  headers: Headers;
};
export type getInfoApiBucketBucketDatasetNameInfoGetResponseError = (getInfoApiBucketBucketDatasetNameInfoGetResponse422) & {
  headers: Headers;
};

export type getInfoApiBucketBucketDatasetNameInfoGetResponse = (getInfoApiBucketBucketDatasetNameInfoGetResponseSuccess | getInfoApiBucketBucketDatasetNameInfoGetResponseError)

export const getGetInfoApiBucketBucketDatasetNameInfoGetUrl = (bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/dataset/${name}/info?${stringifiedParams}` : `/api/bucket/${bucket}/dataset/${name}/info`
}

export const getInfoApiBucketBucketDatasetNameInfoGet = async (bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: RequestInit): Promise<getInfoApiBucketBucketDatasetNameInfoGetResponse> => {
  
  return customFetch<getInfoApiBucketBucketDatasetNameInfoGetResponse>(getGetInfoApiBucketBucketDatasetNameInfoGetUrl(bucket,name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetInfoApiBucketBucketDatasetNameInfoGetQueryKey = (bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams,) => {
    return [
    `/api/bucket/${bucket}/dataset/${name}/info`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetInfoApiBucketBucketDatasetNameInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInfoApiBucketBucketDatasetNameInfoGetQueryKey(bucket,name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>> = ({ signal }) => getInfoApiBucketBucketDatasetNameInfoGet(bucket,name,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(bucket && name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInfoApiBucketBucketDatasetNameInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>>
export type GetInfoApiBucketBucketDatasetNameInfoGetQueryError = HTTPValidationError


export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params: undefined |  GetInfoApiBucketBucketDatasetNameInfoGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Info
 */

export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInfoApiBucketBucketDatasetNameInfoGetQueryOptions(bucket,name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * This api returns the list of datasets/colections.
 * @summary List Dataset From Bucket
 */
export type listDatasetFromBucketApiBucketListDatasetGetResponse200 = {
  data: DataListResponse
  status: 200
}

export type listDatasetFromBucketApiBucketListDatasetGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listDatasetFromBucketApiBucketListDatasetGetResponseSuccess = (listDatasetFromBucketApiBucketListDatasetGetResponse200) & {
  headers: Headers;
};
export type listDatasetFromBucketApiBucketListDatasetGetResponseError = (listDatasetFromBucketApiBucketListDatasetGetResponse422) & {
  headers: Headers;
};

export type listDatasetFromBucketApiBucketListDatasetGetResponse = (listDatasetFromBucketApiBucketListDatasetGetResponseSuccess | listDatasetFromBucketApiBucketListDatasetGetResponseError)

export const getListDatasetFromBucketApiBucketListDatasetGetUrl = (params?: ListDatasetFromBucketApiBucketListDatasetGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/list_dataset?${stringifiedParams}` : `/api/bucket/list_dataset`
}

export const listDatasetFromBucketApiBucketListDatasetGet = async (params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: RequestInit): Promise<listDatasetFromBucketApiBucketListDatasetGetResponse> => {
  
  return customFetch<listDatasetFromBucketApiBucketListDatasetGetResponse>(getListDatasetFromBucketApiBucketListDatasetGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getListDatasetFromBucketApiBucketListDatasetGetQueryKey = (params?: ListDatasetFromBucketApiBucketListDatasetGetParams,) => {
    return [
    `/api/bucket/list_dataset`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListDatasetFromBucketApiBucketListDatasetGetQueryOptions = <TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDatasetFromBucketApiBucketListDatasetGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>> = ({ signal }) => listDatasetFromBucketApiBucketListDatasetGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDatasetFromBucketApiBucketListDatasetGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>>
export type ListDatasetFromBucketApiBucketListDatasetGetQueryError = HTTPValidationError


export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params: undefined |  ListDatasetFromBucketApiBucketListDatasetGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Dataset From Bucket
 */

export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDatasetFromBucketApiBucketListDatasetGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * This api creates a collection from datasets.
 * @summary Create Collection
 */
export type createCollectionApiBucketBucketDatasetNameCollectPostResponse200 = {
  data: unknown
  status: 200
}

export type createCollectionApiBucketBucketDatasetNameCollectPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createCollectionApiBucketBucketDatasetNameCollectPostResponseSuccess = (createCollectionApiBucketBucketDatasetNameCollectPostResponse200) & {
  headers: Headers;
};
export type createCollectionApiBucketBucketDatasetNameCollectPostResponseError = (createCollectionApiBucketBucketDatasetNameCollectPostResponse422) & {
  headers: Headers;
};

export type createCollectionApiBucketBucketDatasetNameCollectPostResponse = (createCollectionApiBucketBucketDatasetNameCollectPostResponseSuccess | createCollectionApiBucketBucketDatasetNameCollectPostResponseError)

export const getCreateCollectionApiBucketBucketDatasetNameCollectPostUrl = (bucket: string,
    name: string,) => {


  

  return `/api/bucket/${bucket}/dataset/${name}/collect`
}

export const createCollectionApiBucketBucketDatasetNameCollectPost = async (bucket: string,
    name: string,
    bodyCreateCollectionApiBucketBucketDatasetNameCollectPost: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost, options?: RequestInit): Promise<createCollectionApiBucketBucketDatasetNameCollectPostResponse> => {
  
  return customFetch<createCollectionApiBucketBucketDatasetNameCollectPostResponse>(getCreateCollectionApiBucketBucketDatasetNameCollectPostUrl(bucket,name),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bodyCreateCollectionApiBucketBucketDatasetNameCollectPost,)
  }
);}
  



export const getCreateCollectionApiBucketBucketDatasetNameCollectPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext> => {

const mutationKey = ['createCollectionApiBucketBucketDatasetNameCollectPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, {bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}> = (props) => {
          const {bucket,name,data} = props ?? {};

          return  createCollectionApiBucketBucketDatasetNameCollectPost(bucket,name,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>>
    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationBody = BodyCreateCollectionApiBucketBucketDatasetNameCollectPost
    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationError = HTTPValidationError

    /**
 * @summary Create Collection
 */
export const useCreateCollectionApiBucketBucketDatasetNameCollectPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>,
        TError,
        {bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost},
        TContext
      > => {
      return useMutation(getCreateCollectionApiBucketBucketDatasetNameCollectPostMutationOptions(options), queryClient);
    }
    
/**
 * This api queries dataset.
 * @summary Query Dataset
 */
export type queryDatasetApiBucketBucketQueryGetResponse200 = {
  data: DataQueryResponse
  status: 200
}

export type queryDatasetApiBucketBucketQueryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type queryDatasetApiBucketBucketQueryGetResponseSuccess = (queryDatasetApiBucketBucketQueryGetResponse200) & {
  headers: Headers;
};
export type queryDatasetApiBucketBucketQueryGetResponseError = (queryDatasetApiBucketBucketQueryGetResponse422) & {
  headers: Headers;
};

export type queryDatasetApiBucketBucketQueryGetResponse = (queryDatasetApiBucketBucketQueryGetResponseSuccess | queryDatasetApiBucketBucketQueryGetResponseError)

export const getQueryDatasetApiBucketBucketQueryGetUrl = (bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bucket/${bucket}/query?${stringifiedParams}` : `/api/bucket/${bucket}/query`
}

export const queryDatasetApiBucketBucketQueryGet = async (bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: RequestInit): Promise<queryDatasetApiBucketBucketQueryGetResponse> => {
  
  return customFetch<queryDatasetApiBucketBucketQueryGetResponse>(getQueryDatasetApiBucketBucketQueryGetUrl(bucket,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getQueryDatasetApiBucketBucketQueryGetQueryKey = (bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams,) => {
    return [
    `/api/bucket/${bucket}/query`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getQueryDatasetApiBucketBucketQueryGetQueryOptions = <TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getQueryDatasetApiBucketBucketQueryGetQueryKey(bucket,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>> = ({ signal }) => queryDatasetApiBucketBucketQueryGet(bucket,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(bucket), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type QueryDatasetApiBucketBucketQueryGetQueryResult = NonNullable<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>>
export type QueryDatasetApiBucketBucketQueryGetQueryError = HTTPValidationError


export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params: undefined |  QueryDatasetApiBucketBucketQueryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>,
          TError,
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>,
          TError,
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Query Dataset
 */

export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getQueryDatasetApiBucketBucketQueryGetQueryOptions(bucket,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get Notification Settings
 */
export type getNotificationSettingsApiProfileSettingsGetResponse200 = {
  data: ProfileResponse
  status: 200
}

export type getNotificationSettingsApiProfileSettingsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getNotificationSettingsApiProfileSettingsGetResponseSuccess = (getNotificationSettingsApiProfileSettingsGetResponse200) & {
  headers: Headers;
};
export type getNotificationSettingsApiProfileSettingsGetResponseError = (getNotificationSettingsApiProfileSettingsGetResponse422) & {
  headers: Headers;
};

export type getNotificationSettingsApiProfileSettingsGetResponse = (getNotificationSettingsApiProfileSettingsGetResponseSuccess | getNotificationSettingsApiProfileSettingsGetResponseError)

export const getGetNotificationSettingsApiProfileSettingsGetUrl = () => {


  

  return `/api/profile/settings`
}

export const getNotificationSettingsApiProfileSettingsGet = async ( options?: RequestInit): Promise<getNotificationSettingsApiProfileSettingsGetResponse> => {
  
  return customFetch<getNotificationSettingsApiProfileSettingsGetResponse>(getGetNotificationSettingsApiProfileSettingsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetNotificationSettingsApiProfileSettingsGetQueryKey = () => {
    return [
    `/api/profile/settings`
    ] as const;
    }

    
export const getGetNotificationSettingsApiProfileSettingsGetQueryOptions = <TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotificationSettingsApiProfileSettingsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>> = ({ signal }) => getNotificationSettingsApiProfileSettingsGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNotificationSettingsApiProfileSettingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>>
export type GetNotificationSettingsApiProfileSettingsGetQueryError = HTTPValidationError


export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Notification Settings
 */

export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNotificationSettingsApiProfileSettingsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Set Notification Settings
 */
export type setNotificationSettingsApiProfileSettingsPostResponse200 = {
  data: unknown
  status: 200
}

export type setNotificationSettingsApiProfileSettingsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type setNotificationSettingsApiProfileSettingsPostResponseSuccess = (setNotificationSettingsApiProfileSettingsPostResponse200) & {
  headers: Headers;
};
export type setNotificationSettingsApiProfileSettingsPostResponseError = (setNotificationSettingsApiProfileSettingsPostResponse422) & {
  headers: Headers;
};

export type setNotificationSettingsApiProfileSettingsPostResponse = (setNotificationSettingsApiProfileSettingsPostResponseSuccess | setNotificationSettingsApiProfileSettingsPostResponseError)

export const getSetNotificationSettingsApiProfileSettingsPostUrl = (params?: SetNotificationSettingsApiProfileSettingsPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/profile/settings?${stringifiedParams}` : `/api/profile/settings`
}

export const setNotificationSettingsApiProfileSettingsPost = async (userProfile: UserProfile,
    params?: SetNotificationSettingsApiProfileSettingsPostParams, options?: RequestInit): Promise<setNotificationSettingsApiProfileSettingsPostResponse> => {
  
  return customFetch<setNotificationSettingsApiProfileSettingsPostResponse>(getSetNotificationSettingsApiProfileSettingsPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userProfile,)
  }
);}
  



export const getSetNotificationSettingsApiProfileSettingsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext> => {

const mutationKey = ['setNotificationSettingsApiProfileSettingsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, {data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  setNotificationSettingsApiProfileSettingsPost(data,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SetNotificationSettingsApiProfileSettingsPostMutationResult = NonNullable<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>>
    export type SetNotificationSettingsApiProfileSettingsPostMutationBody = UserProfile
    export type SetNotificationSettingsApiProfileSettingsPostMutationError = HTTPValidationError

    /**
 * @summary Set Notification Settings
 */
export const useSetNotificationSettingsApiProfileSettingsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>,
        TError,
        {data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams},
        TContext
      > => {
      return useMutation(getSetNotificationSettingsApiProfileSettingsPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get Osmo Client Version
 */
export type getOsmoClientVersionClientVersionGetResponse200 = {
  data: unknown
  status: 200
}

export type getOsmoClientVersionClientVersionGetResponseSuccess = (getOsmoClientVersionClientVersionGetResponse200) & {
  headers: Headers;
};
;

export type getOsmoClientVersionClientVersionGetResponse = (getOsmoClientVersionClientVersionGetResponseSuccess)

export const getGetOsmoClientVersionClientVersionGetUrl = () => {


  

  return `/client/version`
}

export const getOsmoClientVersionClientVersionGet = async ( options?: RequestInit): Promise<getOsmoClientVersionClientVersionGetResponse> => {
  
  return customFetch<getOsmoClientVersionClientVersionGetResponse>(getGetOsmoClientVersionClientVersionGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetOsmoClientVersionClientVersionGetQueryKey = () => {
    return [
    `/client/version`
    ] as const;
    }

    
export const getGetOsmoClientVersionClientVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOsmoClientVersionClientVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>> = ({ signal }) => getOsmoClientVersionClientVersionGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOsmoClientVersionClientVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>>
export type GetOsmoClientVersionClientVersionGetQueryError = unknown


export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Osmo Client Version
 */

export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOsmoClientVersionClientVersionGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * To be used for the readiness probe, but not liveness probe. That way, if this method is
slow, no new traffic gets routed, instead of killing the service.
 * @summary Health
 */
export type healthHealthGetResponse200 = {
  data: unknown
  status: 200
}

export type healthHealthGetResponseSuccess = (healthHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthHealthGetResponse = (healthHealthGetResponseSuccess)

export const getHealthHealthGetUrl = () => {


  

  return `/health`
}

export const healthHealthGet = async ( options?: RequestInit): Promise<healthHealthGetResponse> => {
  
  return customFetch<healthHealthGetResponse>(getHealthHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getHealthHealthGetQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthHealthGet>>> = ({ signal }) => healthHealthGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthHealthGet>>>
export type HealthHealthGetQueryError = unknown


export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health
 */

export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get Version
 */
export type getVersionApiVersionGetResponse200 = {
  data: unknown
  status: 200
}

export type getVersionApiVersionGetResponseSuccess = (getVersionApiVersionGetResponse200) & {
  headers: Headers;
};
;

export type getVersionApiVersionGetResponse = (getVersionApiVersionGetResponseSuccess)

export const getGetVersionApiVersionGetUrl = () => {


  

  return `/api/version`
}

export const getVersionApiVersionGet = async ( options?: RequestInit): Promise<getVersionApiVersionGetResponse> => {
  
  return customFetch<getVersionApiVersionGetResponse>(getGetVersionApiVersionGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetVersionApiVersionGetQueryKey = () => {
    return [
    `/api/version`
    ] as const;
    }

    
export const getGetVersionApiVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionApiVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionApiVersionGet>>> = ({ signal }) => getVersionApiVersionGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVersionApiVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionApiVersionGet>>>
export type GetVersionApiVersionGetQueryError = unknown


export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionApiVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getVersionApiVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionApiVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getVersionApiVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Version
 */

export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVersionApiVersionGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the values of all users who have submitted a workflow.
 * @summary Get Users
 */
export type getUsersApiUsersGetResponse200 = {
  data: string
  status: 200
}

export type getUsersApiUsersGetResponseSuccess = (getUsersApiUsersGetResponse200) & {
  headers: Headers;
};
;

export type getUsersApiUsersGetResponse = (getUsersApiUsersGetResponseSuccess)

export const getGetUsersApiUsersGetUrl = () => {


  

  return `/api/users`
}

export const getUsersApiUsersGet = async ( options?: RequestInit): Promise<getUsersApiUsersGetResponse> => {
  
  return customFetch<getUsersApiUsersGetResponse>(getGetUsersApiUsersGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetUsersApiUsersGetQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getGetUsersApiUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersApiUsersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersApiUsersGet>>> = ({ signal }) => getUsersApiUsersGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersApiUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersApiUsersGet>>>
export type GetUsersApiUsersGetQueryError = unknown


export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Users
 */

export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersApiUsersGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns all workflow tags.
 * @summary Get Available Workflow Tags
 */
export type getAvailableWorkflowTagsApiTagGetResponse200 = {
  data: unknown
  status: 200
}

export type getAvailableWorkflowTagsApiTagGetResponseSuccess = (getAvailableWorkflowTagsApiTagGetResponse200) & {
  headers: Headers;
};
;

export type getAvailableWorkflowTagsApiTagGetResponse = (getAvailableWorkflowTagsApiTagGetResponseSuccess)

export const getGetAvailableWorkflowTagsApiTagGetUrl = () => {


  

  return `/api/tag`
}

export const getAvailableWorkflowTagsApiTagGet = async ( options?: RequestInit): Promise<getAvailableWorkflowTagsApiTagGetResponse> => {
  
  return customFetch<getAvailableWorkflowTagsApiTagGetResponse>(getGetAvailableWorkflowTagsApiTagGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetAvailableWorkflowTagsApiTagGetQueryKey = () => {
    return [
    `/api/tag`
    ] as const;
    }

    
export const getGetAvailableWorkflowTagsApiTagGetQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableWorkflowTagsApiTagGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>> = ({ signal }) => getAvailableWorkflowTagsApiTagGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableWorkflowTagsApiTagGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>>
export type GetAvailableWorkflowTagsApiTagGetQueryError = unknown


export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Available Workflow Tags
 */

export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableWorkflowTagsApiTagGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Get all the workflow plugins configurations
 * @summary Get Workflow Plugins Configs
 */
export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponse200 = {
  data: string
  status: 200
}

export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponseSuccess = (getWorkflowPluginsConfigsApiPluginsConfigsGetResponse200) & {
  headers: Headers;
};
;

export type getWorkflowPluginsConfigsApiPluginsConfigsGetResponse = (getWorkflowPluginsConfigsApiPluginsConfigsGetResponseSuccess)

export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetUrl = () => {


  

  return `/api/plugins/configs`
}

export const getWorkflowPluginsConfigsApiPluginsConfigsGet = async ( options?: RequestInit): Promise<getWorkflowPluginsConfigsApiPluginsConfigsGetResponse> => {
  
  return customFetch<getWorkflowPluginsConfigsApiPluginsConfigsGetResponse>(getGetWorkflowPluginsConfigsApiPluginsConfigsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  




export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryKey = () => {
    return [
    `/api/plugins/configs`
    ] as const;
    }

    
export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>> = ({ signal }) => getWorkflowPluginsConfigsApiPluginsConfigsGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowPluginsConfigsApiPluginsConfigsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>>
export type GetWorkflowPluginsConfigsApiPluginsConfigsGetQueryError = unknown


export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Plugins Configs
 */

export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
