"""
SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SPDX-License-Identifier: Apache-2.0
"""
import hashlib
import json
from typing import Any, Dict, List
import uuid
import time

import pydantic
from jwcrypto import jwk  # type: ignore
import jwt  # type: ignore

from src.lib.utils import common, osmo_errors


# The default length of time a token should be valid for. Defaults to 20 days
DEFAULT_LENGTH = 20 * 24 * 60 * 60
# The jinja template to use for adding additional claims to generated tokens
DEFAULT_TEMPLATE = '''
{
    "unique_name": "{{username}}",
    "osmo_workflow_push": "{{workflow_id}}",
    "roles": [
        "osmo-user"
    ]
}
'''


class AsymmetricKeyPair(pydantic.BaseModel):
    ''' Store a public/private key pair '''
    public_key: str
    private_key: pydantic.SecretStr

    @classmethod
    def generate(cls) -> 'AsymmetricKeyPair':
        return AsymmetricKeyPair()  # type: ignore

    @pydantic.root_validator()
    @classmethod
    def validate_valid_key(cls, values):

        public = values['public_key']
        # Make sure the keys are valid
        jwk.JWK.from_json(public)
        # TODO: Properly validate the private/public key match
        return values

    def create_jwt(self, claims: Dict[str, Any]) -> str:
        pem_key = jwk.JWK.from_json(self.private_key.get_secret_value()).export_to_pem(
            private_key=True, password=None)
        return jwt.encode(claims, key=pem_key, algorithm='RS256')


class LoginInfo(pydantic.BaseModel):
    ''' Store info needed to login '''
    device_endpoint: str | None = None
    device_client_id: str | None = None
    browser_endpoint: str | None = None
    browser_client_id: str | None = None
    token_endpoint: str | None = None
    logout_endpoint: str | None = None


class AuthenticationConfig(pydantic.BaseModel):
    ''' Store info needed to generate and validate idtokens '''
    # Public/Private key pairs by name
    keys: Dict[str, AsymmetricKeyPair]
    # The name of the keypair that should be used for signing
    active_key: str
    # The 'iss' claim to put in tokens generated by this class
    issuer: str
    # The 'aud' claim to put in tokens generated by this class
    audience: str
    # The roles that can be used in the idtoken
    # TODO: Add validation to ensure the roles are valid
    user_roles: List[str] = ['osmo-user']
    # TODO: Add validation to ensure the roles are valid
    ctrl_roles: List[str] = ['osmo-user', 'osmo-ctrl']

    login_info: LoginInfo = LoginInfo()

    # The maximum duration of a token
    max_token_duration: str = '365d'

    @pydantic.validator('max_token_duration')
    @classmethod
    def validate_max_token_duration(cls, value: str) -> str:
        try:
            common.to_timedelta(value)
        except ValueError as e:
            raise osmo_errors.OSMOUserError(f'Invalid max_token_duration format: {str(e)}')
        return value

    @classmethod
    def generate_default(cls) -> 'AuthenticationConfig':
        active_key = str(uuid.uuid4())
        issuer = 'osmo'
        key = jwk.JWK.generate(kty='RSA', kid=active_key, size=4096)
        key_pair = AsymmetricKeyPair(
            public_key=key.export_public(),
            private_key=key.export_private())
        return AuthenticationConfig(
            active_key=active_key,
            keys={active_key: key_pair},
            issuer=issuer,
            audience=issuer)

    @pydantic.root_validator()
    @classmethod
    def validate_active_key(cls, values):
        active_key = values.get('active_key')
        keys = values.get('keys', [])
        if active_key not in keys:
            raise ValueError(f'active_key "{active_key}" not in keys')
        return values

    def get_keyset(self) -> Dict:
        return {'keys': [
            json.loads(key.public_key) for key in self.keys.values()
        ]}

    def get_current_key(self) -> AsymmetricKeyPair:
        return self.keys[self.active_key]

    def create_idtoken_jwt(self, expire_timestamp: int, username: str,
                           roles: List[str],
                           workflow_id: str | None = None) -> str:
        '''
        aud: Audience
        iss: Issuer
        iat: Issued at
        nbf: Not before
        exp: Expires
        '''
        current_time = int(time.time())
        payload = {
            'iss': self.issuer,
            'aud': self.audience,
            'iat': current_time,
            'nbf': current_time,
            'exp': expire_timestamp
        }

        template_payload = {
            'unique_name': username,
            'roles': roles
        }
        # TODO: Remove this and create a new role per workflow_id
        if workflow_id:
            template_payload['osmo_workflow_push'] = workflow_id

        # Substitute the template
        payload.update(template_payload)
        key = self.get_current_key()
        return key.create_jwt(payload)


def hash_access_token(access_token: str) -> bytes:
    """ Hash the access token """
    return hashlib.sha256(access_token.encode()).digest()

