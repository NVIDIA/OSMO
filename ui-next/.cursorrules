# OSMO UI Development Rules

## Core Principles

1. **Minimize indirection** - Avoid unnecessary abstraction layers
2. **Use generated code directly** - Import enums/types from `generated.ts`, don't re-export
3. **Reduce complexity** - Collapse nesting and unnecessary wrappers
4. **Transparency over magic** - Explicit imports over hidden re-exports
5. **DRY but not over-abstracted** - Reuse code, but don't create layers for one use case
6. **Performance first** - Minimize reflow, use GPU acceleration, optimize renders

## Architecture

### Layer Pattern (Top to Bottom)
```
Page → Headless Hook → Adapter Hook → Generated API
            ↓
     Themed Components
```

- **Pages** (`src/app/`): Compose hooks + components, minimal logic
- **Headless hooks** (`src/headless/`): Business logic, filtering, state - NO UI
- **Adapter hooks** (`src/lib/api/adapter/`): Transform backend quirks to clean types
- **Generated API** (`src/lib/api/generated.ts`): Auto-generated, don't edit
- **Themed components** (`src/components/features/`): Presentation only

### What Goes Where

| Need | Where |
|------|-------|
| Enums (PoolStatus, BackendResourceType) | Import from `@/lib/api/generated` |
| Transformed types (Pool, Resource) | Import from `@/lib/api/adapter` |
| Hooks for fetching | Import from `@/lib/api/adapter` |
| UI display config (colors, labels) | `@/lib/constants/ui.ts` |

### Component Organization
- `src/components/ui/` - shadcn/ui primitives (Button, Input, Dialog)
- `src/components/shell/` - Layout (Header, Sidebar)
- `src/components/features/` - Feature-specific themed components
- `src/headless/` - Business logic hooks (no UI)

## API & Types

**Import enums directly from generated:**
```typescript
import { PoolStatus, BackendResourceType } from "@/lib/api/generated";
```

**Import types and hooks from adapter:**
```typescript
import { usePools, type Pool, type Resource } from "@/lib/api/adapter";
```

**DON'T re-export generated types** - it creates indirection and hides the source.

**DON'T import raw generated hooks** - use adapter hooks that handle transforms:
```typescript
// BAD
import { useGetPoolQuotasApiPoolQuotaGet } from "@/lib/api/generated";

// GOOD
import { usePools } from "@/lib/api/adapter";
```

### Backend Adapter

The adapter layer (`src/lib/api/adapter/`) transforms backend responses that UI cannot use directly. **If backend does something correctly, use it directly from generated.ts.**

**Transform only what needs transforming:**
- Strings that should be numbers → parse
- Missing fields → provide defaults
- Untyped dictionaries → extract typed values
- Unit conversions (KiB→GiB) → convert

**Use directly from generated.ts:**
- Enums (PoolStatus, BackendResourceType) - values are correct
- Error types - shape is correct

The adapter should NOT:
- Hide things that are already correct
- Add business logic (that belongs in headless hooks)
- Create unnecessary type aliases or re-exports

## Tech Stack
- Next.js 16+ (App Router, Turbopack)
- React 19, TypeScript strict
- Tailwind CSS 4 with CSS variables
- shadcn/ui + Radix for components
- TanStack Query 5 for server state
- TanStack Virtual for virtualization
- orval for API codegen

## Performance Optimization

### CSS Performance (No Layout Thrashing)

**Use GPU-accelerated properties only:**
```css
/* ✅ Good: GPU-accelerated, no reflow */
transform: translateY(100px);
opacity: 0.5;

/* ❌ Bad: Triggers layout/reflow */
top: 100px;
height: 200px;
margin-top: 20px;
```

**Use CSS containment for isolation:**
```tsx
// Isolate layout calculations from rest of page
<div style={{ contain: "strict" }}>
  <ExpensiveComponent />
</div>
```

**Available utility classes (from globals.css):**
- `.gpu-layer` - Force GPU compositing
- `.contain-strict` - Full CSS containment
- `.contain-layout` / `.contain-paint` - Partial containment
- `.content-auto` - Lazy render off-screen content
- `.scroll-optimized` - Optimized scrolling container
- `.virtual-item` - For virtualized list items
- `.skeleton-shimmer` - GPU-accelerated loading skeleton
- `.focus-optimized` - Focus ring only for keyboard nav

### React Performance

**Use `useDeferredValue` for expensive filters:**
```typescript
const [search, setSearch] = useState("");
const deferredSearch = useDeferredValue(search);

// Filter uses deferred value - keeps input responsive
const filtered = useMemo(() => 
  items.filter(i => i.name.includes(deferredSearch)),
  [items, deferredSearch]
);
```

**Use `startTransition` for non-blocking updates:**
```typescript
const handleSort = useCallback((column: SortColumn) => {
  startTransition(() => {
    setSort({ column, direction: "asc" });
  });
}, []);
```

**Memoize components that receive object/array props:**
```typescript
// ✅ Good: Memoized to prevent re-renders
const TableRow = memo(function TableRow({ data }: Props) {
  return <div>{data.name}</div>;
});
```

**Use `useCallback` for stable function refs:**
```typescript
// ✅ Good: Stable reference for child components
const handleClick = useCallback((id: string) => {
  setSelected(id);
}, []);
```

### Virtualization

**All large lists MUST be virtualized:**
```typescript
import { useVirtualizer } from "@tanstack/react-virtual";

// Use transform for positioning (GPU-accelerated)
style={{
  transform: `translate3d(0, ${virtualRow.start}px, 0)`,
}}
```

### Loading States

**Match skeleton dimensions to actual content:**
```tsx
// ✅ Good: Same dimensions as real content (prevents CLS)
<div className="h-8 w-48 skeleton-shimmer rounded" />

// ❌ Bad: Generic spinner (causes layout shift)
<Spinner />
```

### Performance Utilities

Use hooks from `@/lib/performance.ts`:
- `useDebounce(value, delay)` - Debounce values
- `useDebouncedCallback(fn, delay)` - Debounce functions
- `useInView(options)` - Lazy load when visible
- `useScrollPosition(ref)` - RAF-throttled scroll tracking
- `usePrefersReducedMotion()` - Respect a11y preferences

## Styling

- Use Tailwind classes only (no CSS modules)
- Shared patterns in `src/lib/styles.ts`
- CSS variables in `globals.css` for theming
- Mobile-first responsive design

## Constants

Organize magic strings/numbers in `src/lib/constants/`:
- `roles.ts` - User roles and role checking
- `storage.ts` - localStorage/cookie keys
- `headers.ts` - Custom HTTP headers
- `ui.ts` - Display configs (colors, labels, icons)
- `config.ts` - Runtime config, timing constants

**Use generated enum values, not magic strings:**
```typescript
// BAD
if (resource.resourceType === "SHARED") ...

// GOOD
import { BackendResourceType } from "@/lib/api/generated";
if (resource.resourceType === BackendResourceType.SHARED) ...
```

## Patterns

- React Server Components by default
- `'use client'` only when needed (interactivity, hooks)
- Composition over inheritance
- All components must be accessible (ARIA)
- Props down, events up - explicit props, no prop drilling through context
- **Explicit props over inferred behavior** - UI components should receive `showX` props rather than inferring from data absence
- **Memoize expensive components** - Use `React.memo()` for components that receive object/array props
- **Virtualize long lists** - Always use `@tanstack/react-virtual` for lists > 50 items
- **GPU-accelerated animations** - Only animate `transform` and `opacity`
- **CSS containment** - Use `contain: strict` on containers with complex children

## Adding Features

1. Create page in `src/app/(dashboard)/feature/page.tsx`
2. Create headless hook in `src/headless/use-feature.ts`
3. Create themed components in `src/components/features/feature/`
4. Export from index.ts files
5. Use adapter hooks for API data
6. Import enums from generated.ts

## Auth

- Auth logic in `src/lib/auth/`
- Use `useAuth()` for auth state
- Use `useUser()` for user info
- Token refresh is automatic and lazy
