/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customFetch } from '@/lib/api/fetcher'
/**
 * Single Pool Entry 
 */
export interface AccessToken {
  user_name: string;
  token_name: string;
  expires_at: string;
  description: string;
  access_type: AccessTokenType;
  roles: string[];
}

/**
 * Type of access token 
 */
export type AccessTokenType = typeof AccessTokenType[keyof typeof AccessTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccessTokenType = {
  USER: 'USER',
  SERVICE: 'SERVICE',
} as const;

/**
 * Defines permissions for certain actionsfor a pool 
 */
export interface ActionPermissions {
  execute?: PermissionLevel;
  portforward?: PermissionLevel;
  cancel?: PermissionLevel;
  rsync?: PermissionLevel;
}

/**
 * Store a public/private key pair 
 */
export interface AsymmetricKeyPair {
  public_key: string;
  private_key: string;
}

export type AuthenticationConfigKeys = {[key: string]: AsymmetricKeyPair};

/**
 * Store info needed to generate and validate idtokens 
 */
export interface AuthenticationConfig {
  keys: AuthenticationConfigKeys;
  active_key: string;
  issuer: string;
  audience: string;
  user_roles?: string[];
  ctrl_roles?: string[];
  login_info?: LoginInfo;
  max_token_duration?: string;
}

/**
 * Object storing backend info. 
 */
export interface Backend {
  name: string;
  description: string;
  version: string;
  k8s_uid: string;
  k8s_namespace: string;
  dashboard_url: string;
  grafana_url: string;
  tests: string[];
  scheduler_settings: BackendSchedulerSettings;
  node_conditions: BackendNodeConditions;
  last_heartbeat: string;
  created_date: string;
  router_address: string;
  online: boolean;
}

/**
 * Similar to connectors.Backend, but with optional fields.
 */
export interface BackendConfig {
  description?: string;
  k8s_uid?: string;
  dashboard_url?: string;
  grafana_url?: string;
  tests?: string[];
  scheduler_settings?: BackendSchedulerSettings;
  node_conditions?: BackendNodeConditions;
  router_address?: string;
}

export type BackendNodeConditionsRules = {[key: string]: string};

/**
 * Settings for backend node conditions. 
 */
export interface BackendNodeConditions {
  rules?: BackendNodeConditionsRules;
  prefix?: string;
}

/**
 * Resource type for BackendResource. 
 */
export type BackendResourceType = typeof BackendResourceType[keyof typeof BackendResourceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendResourceType = {
  RESERVED: 'RESERVED',
  SHARED: 'SHARED',
  UNUSED: 'UNUSED',
} as const;

/**
 * Settings that control the how pods are scheduled in a backend
 */
export interface BackendSchedulerSettings {
  scheduler_type?: BackendSchedulerType;
  scheduler_name?: string;
  scheduler_timeout?: number;
}

/**
 * Defines the type of scheduler used by the backend 
 */
export type BackendSchedulerType = typeof BackendSchedulerType[keyof typeof BackendSchedulerType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendSchedulerType = {
  kai: 'kai',
} as const;

export type BackendTestsParsedPodTemplate = { [key: string]: unknown };

/**
 * Represents a test config. 
 */
export interface BackendTests {
  /** @minLength 1 */
  name: string;
  description: string;
  /** @minLength 1 */
  cron_schedule: string;
  test_timeout?: string;
  /** @minItems 1 */
  node_conditions: string[];
  /** @minItems 1 */
  common_pod_template: string[];
  parsed_pod_template?: BackendTestsParsedPodTemplate;
}

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel = { [key: string]: unknown };

export type BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata = { [key: string]: unknown };

export interface BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost {
  set_label?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetLabel;
  set_metadata?: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostSetMetadata;
}

export interface BodyCreateCollectionApiBucketBucketDatasetNameCollectPost {
  datasets: DatasetStructure[];
}

/**
 * Class to store the name of the bucket and the dataset path
 */
export interface BucketConfig {
  /** @pattern (^swift://[^/,;*]+(/[^/,;*]+){2,}/*$|^s3://[^/,;*]+(/[^/,;*]+)*\/*$|^gs://[^/,;*]+(/[^/,;*]+)*\/*$|^tos://[^/,;*]+(/[^/,;*]+)+/*$|^azure://[^/,;*]+(/[^/,;*]+)+/*$) */
  dataset_path: string;
  region?: string;
  check_key?: boolean;
  description?: string;
  mode?: string;
  default_credential?: StaticDataCredential;
}

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoEntry {
  path: string;
  description: string;
  mode: string;
  default_cred: boolean;
}

export type BucketInfoResponseBuckets = {[key: string]: BucketInfoEntry};

/**
 * Object storing Upload Response. 
 */
export interface BucketInfoResponse {
  default?: string;
  buckets: BucketInfoResponseBuckets;
}

/**
 * Object storing workflow name. 
 */
export interface CancelResponse {
  name: string;
}

/**
 * Config for storing information regarding CLI storage. 
 */
export interface CliConfig {
  latest_version?: string;
  min_supported_version?: string;
}

/**
 * Response body for config diff endpoint.
 */
export interface ConfigDiffResponse {
  first_data?: unknown;
  second_data?: unknown;
}

/**
 * Object storing config history.
 */
export interface ConfigHistory {
  config_type: SrcLibUtilsConfigHistoryConfigHistoryType;
  name: string;
  revision: number;
  username: string;
  created_at: string;
  description: string;
  tags?: string[];
  data?: unknown;
}

/**
 * Request body for updating configurations with history tracking metadata.
 */
export interface ConfigsRequest {
  description?: string;
  tags?: string[];
}

/**
 * Stores registries/data which do not do validation 
 */
export interface CredentialConfig {
  disable_registry_validation?: string[];
  disable_data_validation?: string[];
}

export type CredentialGetResponseCredentialsItem = {[key: string]: string};

/**
 * Credential Response. 
 */
export interface CredentialGetResponse {
  credentials: CredentialGetResponseCredentialsItem[];
}

/**
 * Credential options 
 */
export interface CredentialOptions {
  /** Authentication information for a Docker registry */
  registry_credential?: UserRegistryCredential;
  /** Authentication information for a data service */
  data_credential?: UserDataCredential;
  /** Generic authentication information */
  generic_credential?: UserCredential;
}

/**
 * Object storing Tag/Label/Metadata Response. 
 */
export interface DataAttributeResponse {
  tag_response?: DataTagResponse;
  label_response?: DataMetadataResponse;
  metadata_response?: DataMetadataResponse;
}

/**
 * Config for storing information about data. 
 */
export interface DataConfig {
  credential?: StaticDataCredential;
  base_url?: string;
  websocket_timeout?: number;
  data_timeout?: number;
  download_type?: DownloadType;
}

/**
 * Object storing Info Element. 
 */
export interface DataInfoCollectionEntry {
  name: string;
  version: string;
  location: string;
  uri: string;
  hash_location?: string;
  size: number;
}

export type DataInfoDatasetEntryMetadata = { [key: string]: unknown };

/**
 * Object storing Info Element. 
 */
export interface DataInfoDatasetEntry {
  name: string;
  version: string;
  status: DatasetStatus;
  created_by: string;
  created_date: string;
  last_used: string;
  retention_policy: number;
  size: number;
  checksum: string;
  location: string;
  uri: string;
  metadata: DataInfoDatasetEntryMetadata;
  tags: string[];
  collections: string[];
}

export type DataInfoResponseLabels = { [key: string]: unknown };

export type DataInfoResponseVersionsItem = DataInfoDatasetEntry | DataInfoCollectionEntry;

/**
 * Object storing Data Info Elements. 
 */
export interface DataInfoResponse {
  name: string;
  id: string;
  bucket: string;
  created_by?: string;
  created_date?: string;
  hash_location?: string;
  hash_location_size?: number;
  labels: DataInfoResponseLabels;
  type: DatasetType;
  versions: DataInfoResponseVersionsItem[];
}

/**
 * Object storing Data List Element. 
 */
export interface DataListEntry {
  name: string;
  id: string;
  bucket: string;
  create_time: string;
  last_created?: string;
  hash_location?: string;
  hash_location_size?: number;
  version_id?: string;
  type: DatasetType;
}

/**
 * Object storing Data List Elements. 
 */
export interface DataListResponse {
  datasets: DataListEntry[];
}

export type DataMetadataResponseMetadata = { [key: string]: unknown };

/**
 * Object storing Label/Metadata Response. 
 */
export interface DataMetadataResponse {
  metadata: DataMetadataResponseMetadata;
}

/**
 * Object storing Tag Response. 
 */
export interface DataTagResponse {
  version_id: string;
  tags: string[];
}

export type DatasetConfigBuckets = {[key: string]: BucketConfig};

/**
 * Stores any dataset configs External Admins control 
 */
export interface DatasetConfig {
  buckets?: DatasetConfigBuckets;
  default_bucket?: string;
}

/**
 * The status of a dataset / dataset version.
 */
export type DatasetStatus = typeof DatasetStatus[keyof typeof DatasetStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DatasetStatus = {
  PENDING: 'PENDING',
  READY: 'READY',
  PENDING_DELETE: 'PENDING_DELETE',
  DELETED: 'DELETED',
} as const;

/**
 * Object storing execution cluster node resource information. 
 */
export interface DatasetStructure {
  /** @pattern ^[a-zA-Z0-9_-]+$ */
  name: string;
  /** @pattern ^([a-zA-Z0-9_-]*)$ */
  tag: string;
}

/**
 * An enumeration.
 */
export type DatasetType = typeof DatasetType[keyof typeof DatasetType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DatasetType = {
  COLLECTION: 'COLLECTION',
  DATASET: 'DATASET',
} as const;

/**
 * Request body for deleting a backend with history tracking metadata.
 */
export interface DeleteBackendRequest {
  description?: string;
  tags?: string[];
  force?: boolean;
}

/**
 * Type of Config to fetch or set 
 */
export type DownloadType = typeof DownloadType[keyof typeof DownloadType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DownloadType = {
  download: 'download',
} as const;

export interface EditResponse {
  uuid: string;
  version: number;
  name: string;
  created_by: string;
  created_date: string;
}

export type EditablePoolConfigPools = {[key: string]: PoolEditable};

/**
 * Stores editable pool configs.
 */
export interface EditablePoolConfig {
  pools?: EditablePoolConfigPools;
}

/**
 * Response body for config history endpoint.
 */
export interface GetConfigsHistoryResponse {
  configs: ConfigHistory[];
}

/**
 * Represents the queryed task information. 
 */
export interface GroupQueryResponse {
  name: string;
  status: TaskGroupStatus;
  start_time?: string;
  end_time?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  remaining_upstream_groups?: string[];
  downstream_groups?: string[];
  failure_message?: string;
  tasks?: TaskQueryResponse[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Object storing info for all backends. 
 */
export interface ListBackendsResponse {
  backends: Backend[];
}

/**
 * Represents the list order for the database. 
 */
export type ListOrder = typeof ListOrder[keyof typeof ListOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const;

/**
 * Entry for task list API results, aggregated by workflow. 
 */
export interface ListTaskAggregatedEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
  workflow_id: string;
}

export interface ListTaskAggregatedResponse {
  summaries: ListTaskAggregatedEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskEntry {
  user: string;
  workflow_id: string;
  workflow_uuid: string;
  task_name: string;
  retry_id: number;
  pool?: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  duration?: number;
  status: TaskGroupStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskResponse {
  tasks: ListTaskEntry[];
}

/**
 * Entry for task list API results. 
 */
export interface ListTaskSummaryEntry {
  user: string;
  pool?: string;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
  priority: string;
}

export interface ListTaskSummaryResponse {
  summaries: ListTaskSummaryEntry[];
}

/**
 * Config for storing information about data. 
 */
export interface LogConfig {
  credential?: StaticDataCredential;
}

/**
 * Store info needed to login 
 */
export interface LoginInfo {
  device_endpoint?: string;
  device_client_id?: string;
  browser_endpoint?: string;
  browser_client_id?: string;
  token_endpoint?: string;
  logout_endpoint?: string;
}

export type MinimalPoolConfigPools = {[key: string]: PoolMinimal};

/**
 * Stores minimal pool configs.
 */
export interface MinimalPoolConfig {
  pools?: MinimalPoolConfigPools;
}

export interface NotificationConfig {
  slack_token?: string;
  smtp_settings?: SMTPConfig;
}

/**
 * An enumeration.
 */
export type OperatorType = typeof OperatorType[keyof typeof OperatorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorType = {
  GT: 'GT',
  GE: 'GE',
  LT: 'LT',
  LE: 'LE',
  EQ: 'EQ',
} as const;

/**
 * Dynamic Config for storing the image URLs for service images and the credentials needed
to pull them.
 */
export interface OsmoImageConfig {
  init?: string;
  client?: string;
  credential?: RegistryCredential;
}

export type PatchBackendTestRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a test with history tracking metadata.
 */
export interface PatchBackendTestRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchBackendTestRequestConfigsDict;
}

export type PatchConfigRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching configurations with history tracking metadata.
 */
export interface PatchConfigRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchConfigRequestConfigsDict;
}

export type PatchDatasetRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a dataset bucket configuration with history tracking metadata.
 */
export interface PatchDatasetRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchDatasetRequestConfigsDict;
}

export type PatchPoolRequestConfigsDict = { [key: string]: unknown };

/**
 * Request body for patching a pool with history tracking metadata.
 */
export interface PatchPoolRequest {
  description?: string;
  tags?: string[];
  configs_dict: PatchPoolRequestConfigsDict;
}

/**
 * Permission Level 
 */
export type PermissionLevel = typeof PermissionLevel[keyof typeof PermissionLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PermissionLevel = {
  PUBLIC: 'PUBLIC',
  POOL: 'POOL',
  PRIVATE: 'PRIVATE',
} as const;

export type PlatformLabels = {[key: string]: string};

export type PlatformDefaultVariables = { [key: string]: unknown };

export type PlatformParsedPodTemplate = { [key: string]: unknown };

/**
 * Single Platform Entry 
 */
export interface Platform {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
  tolerations?: Toleration[];
  labels?: PlatformLabels;
  default_variables?: PlatformDefaultVariables;
  resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  override_pod_template?: string[];
  parsed_pod_template?: PlatformParsedPodTemplate;
}

export type PlatformEditableDefaultVariables = { [key: string]: unknown };

/**
 * Single Platform Entry 
 */
export interface PlatformEditable {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_variables?: PlatformEditableDefaultVariables;
  resource_validations?: string[];
  override_pod_template?: string[];
}

/**
 * Single Platform Entry 
 */
export interface PlatformMinimal {
  description?: string;
  host_network_allowed?: boolean;
  privileged_allowed?: boolean;
  allowed_mounts?: string[];
  default_mounts?: string[];
}

/**
 * Stores any plugins configs 
 */
export interface PluginsConfig {
  rsync?: RsyncConfig;
}

export type PoolDefaultExitActions = {[key: string]: string};

export type PoolCommonDefaultVariables = { [key: string]: unknown };

export type PoolParsedPodTemplate = { [key: string]: unknown };

export type PoolPlatforms = {[key: string]: Platform};

/**
 * Single Pool Entry 
 */
export interface Pool {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolDefaultExitActions;
  action_permissions?: ActionPermissions;
  resources?: PoolResources;
  common_default_variables?: PoolCommonDefaultVariables;
  common_resource_validations?: string[];
  parsed_resource_validations?: ResourceAssertion[];
  common_pod_template?: string[];
  parsed_pod_template?: PoolParsedPodTemplate;
  platforms?: PoolPlatforms;
  last_heartbeat?: string;
}

export type PoolEditableDefaultExitActions = {[key: string]: string};

export type PoolEditableCommonDefaultVariables = { [key: string]: unknown };

export type PoolEditablePlatforms = {[key: string]: PlatformEditable};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolEditable {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolEditableDefaultExitActions;
  action_permissions?: ActionPermissions;
  resources?: PoolResources;
  common_default_variables?: PoolEditableCommonDefaultVariables;
  common_resource_validations?: string[];
  common_pod_template?: string[];
  platforms?: PoolEditablePlatforms;
}

export type PoolMinimalDefaultExitActions = {[key: string]: string};

export type PoolMinimalPlatforms = {[key: string]: PlatformMinimal};

/**
 * Pool schema to expose through API endpoint. 
 */
export interface PoolMinimal {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolMinimalDefaultExitActions;
  action_permissions?: ActionPermissions;
  resources?: PoolResources;
  platforms?: PoolMinimalPlatforms;
}

/**
 * Object storing pool node set information. 
 */
export interface PoolNodeSetResourceUsage {
  pools: PoolResourceUsage[];
}

/**
 * Resources like GPU or CPU that have a discrete number. For guarantee and maximum, a value of -1
indicates that there is no limit.
 */
export interface PoolResourceCountable {
  guarantee?: number;
  maximum?: number;
  weight?: number;
}

export type PoolResourceUsageDefaultExitActions = {[key: string]: string};

export type PoolResourceUsagePlatforms = {[key: string]: PlatformMinimal};

/**
 * Object storing pool information. 
 */
export interface PoolResourceUsage {
  name?: string;
  description?: string;
  status?: PoolStatus;
  download_type?: DownloadType;
  enable_maintenance?: boolean;
  backend: string;
  default_platform?: string;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  default_exit_actions?: PoolResourceUsageDefaultExitActions;
  action_permissions?: ActionPermissions;
  resources?: PoolResources;
  platforms?: PoolResourceUsagePlatforms;
  resource_usage: ResourceUsage;
}

/**
 * Resources allocated to the pool, for schedulers that support this feature 
 */
export interface PoolResources {
  gpu?: PoolResourceCountable;
}

export type PoolResourcesEntryUsageFields = { [key: string]: unknown };

export type PoolResourcesEntryAllocatableFields = { [key: string]: unknown };

/**
 * Entry for resources API results. 
 */
export interface PoolResourcesEntry {
  pool: string;
  platform: string;
  status: PoolStatus;
  usage_fields: PoolResourcesEntryUsageFields;
  allocatable_fields: PoolResourcesEntryAllocatableFields;
  backend: string;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface PoolResourcesResponse {
  pools: PoolResourcesEntry[];
}

/**
 * Object storing pool information. 
 */
export interface PoolResponse {
  node_sets: PoolNodeSetResourceUsage[];
  resource_sum: ResourceUsage;
}

/**
 * Represents the types of statuses a pool can have. 
 */
export type PoolStatus = typeof PoolStatus[keyof typeof PoolStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PoolStatus = {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MAINTENANCE: 'MAINTENANCE',
} as const;

/**
 * Request body for creating a new backend with history tracking metadata.
 */
export interface PostBackendRequest {
  description?: string;
  tags?: string[];
  configs: BackendConfig;
}

/**
 * Object storing workflow name. 
 */
export interface ProfileResponse {
  profile: UserProfile;
  pools: string[];
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestRequest {
  description?: string;
  tags?: string[];
  configs: BackendTests;
}

export type PutBackendTestsRequestConfigs = {[key: string]: BackendTests};

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutBackendTestsRequest {
  description?: string;
  tags?: string[];
  configs: PutBackendTestsRequestConfigs;
}

/**
 * Request body for updating dataset configurations with history tracking metadata.
 */
export interface PutDatasetRequest {
  description?: string;
  tags?: string[];
  configs: DatasetConfig;
}

export type PutPodTemplateRequestConfigs = { [key: string]: unknown };

/**
 * Request body for updating a pod template with history tracking metadata.
 */
export interface PutPodTemplateRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplateRequestConfigs;
}

export type PutPodTemplatesRequestConfigs = {[key: string]: { [key: string]: unknown }};

/**
 * Request body for updating pod templates with history tracking metadata.
 */
export interface PutPodTemplatesRequest {
  description?: string;
  tags?: string[];
  configs: PutPodTemplatesRequestConfigs;
}

/**
 * Request body for updating a platform in a pool with history tracking metadata.
 */
export interface PutPoolPlatformRequest {
  description?: string;
  tags?: string[];
  configs: Platform;
}

/**
 * Request body for updating a pool with history tracking metadata.
 */
export interface PutPoolRequest {
  description?: string;
  tags?: string[];
  configs: Pool;
}

export type PutPoolsRequestConfigs = {[key: string]: Pool};

/**
 * Request body for updating pools with history tracking metadata.
 */
export interface PutPoolsRequest {
  description?: string;
  tags?: string[];
  configs: PutPoolsRequestConfigs;
}

export type PutResourceValidationRequestConfigsItem = { [key: string]: unknown };

/**
 * Request body for updating a resource validation with history tracking metadata.
 */
export interface PutResourceValidationRequest {
  description?: string;
  tags?: string[];
  configs: PutResourceValidationRequestConfigsItem[];
}

export type PutResourceValidationsRequestConfigsDictItem = { [key: string]: unknown };

export type PutResourceValidationsRequestConfigsDict = {[key: string]: PutResourceValidationsRequestConfigsDictItem[]};

/**
 * Request body for updating resource validations with history tracking metadata.
 */
export interface PutResourceValidationsRequest {
  description?: string;
  tags?: string[];
  configs_dict: PutResourceValidationsRequestConfigsDict;
}

/**
 * Request body for updating a role with history tracking metadata.
 */
export interface PutRoleRequest {
  description?: string;
  tags?: string[];
  configs: Role;
}

/**
 * Request body for updating a test with history tracking metadata.
 */
export interface PutRolesRequest {
  description?: string;
  tags?: string[];
  configs: Role[];
}

/**
 * Request body for updating service configurations with history tracking metadata.
 */
export interface PutServiceRequest {
  description?: string;
  tags?: string[];
  configs: ServiceConfig;
}

/**
 * Request body for updating workflow configurations with history tracking metadata.
 */
export interface PutWorkflowRequest {
  description?: string;
  tags?: string[];
  configs: WorkflowConfig;
}

/**
 * Authentication information for a Docker registry. 
 */
export interface RegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth?: string;
}

/**
 * Request body for renaming a platform in a pool with history tracking metadata.
 */
export interface RenamePoolPlatformRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

/**
 * Request body for renaming a pool with history tracking metadata.
 */
export interface RenamePoolRequest {
  description?: string;
  tags?: string[];
  new_name: string;
}

/**
 * Class for defining resource restrictions.
 */
export interface ResourceAssertion {
  operator: OperatorType;
  left_operand: string;
  right_operand: string;
  assert_message: string;
}

/**
 * Object storing resource usage information. 
 */
export interface ResourceUsage {
  quota_used: string;
  quota_free: string;
  quota_limit: string;
  total_usage: string;
  total_capacity: string;
  total_free: string;
}

export type ResourcesEntryExposedFields = { [key: string]: unknown };

export type ResourcesEntryTaintsItem = { [key: string]: unknown };

export type ResourcesEntryUsageFields = { [key: string]: unknown };

export type ResourcesEntryNonWorkflowUsageFields = { [key: string]: unknown };

export type ResourcesEntryAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformAvailableFields = { [key: string]: unknown };

export type ResourcesEntryPlatformWorkflowAllocatableFields = { [key: string]: unknown };

export type ResourcesEntryConfigFields = { [key: string]: unknown };

export type ResourcesEntryLabelFields = { [key: string]: unknown };

export type ResourcesEntryPoolPlatformLabels = {[key: string]: string[]};

/**
 * Entry for resources API results. 
 */
export interface ResourcesEntry {
  hostname: string;
  exposed_fields: ResourcesEntryExposedFields;
  taints: ResourcesEntryTaintsItem[];
  usage_fields: ResourcesEntryUsageFields;
  conditions?: string[];
  non_workflow_usage_fields: ResourcesEntryNonWorkflowUsageFields;
  allocatable_fields: ResourcesEntryAllocatableFields;
  platform_allocatable_fields?: ResourcesEntryPlatformAllocatableFields;
  platform_available_fields?: ResourcesEntryPlatformAvailableFields;
  platform_workflow_allocatable_fields?: ResourcesEntryPlatformWorkflowAllocatableFields;
  config_fields?: ResourcesEntryConfigFields;
  backend: string;
  label_fields?: ResourcesEntryLabelFields;
  pool_platform_labels: ResourcesEntryPoolPlatformLabels;
  resource_type: BackendResourceType;
}

/**
 * Object storing execution cluster node resource information. 
 */
export interface ResourcesResponse {
  resources: ResourcesEntry[];
}

/**
 * Single Role Entry 
 */
export interface Role {
  name: string;
  description: string;
  policies: RolePolicy[];
  immutable?: boolean;
}

/**
 * Single Role Action Entry 
 */
export interface RoleAction {
  /** @pattern ^(?P<base>http)$ */
  base: string;
  /** @pattern ^(?P<path>(\*|(!?)/([^:]+)))$ */
  path: string;
  /** @pattern ^(?P<method>(\*|([a-zA-Z]+)))$ */
  method: string;
}

/**
 * Single Role Policy Entry 
 */
export interface RolePolicy {
  actions: RoleAction[];
}

/**
 * Request body for config rollback endpoint.
 */
export interface RollbackConfigRequest {
  description?: string;
  tags?: string[];
  config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
  /**
   * Revision to roll back to
   */
  revision: number;
}

/**
 * Router Information Response. 
 */
export interface RouterResponse {
  router_address: string;
  key: string;
  cookie: string;
}

/**
 * Stores a single allowed path for rsync 
 */
export interface RsyncAllowedPath {
  path: string;
  writable?: boolean;
}

export type RsyncConfigAllowedPaths = {[key: string]: RsyncAllowedPath};

/**
 * Stores all configs for rsync 
 */
export interface RsyncConfig {
  enabled?: boolean;
  enable_telemetry?: boolean;
  /**
   * User pod's rsync read bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  read_bandwidth_limit?: number;
  /**
   * User pod's rsync write bandwidth limit in bytes per second, zero means no limit
   * @minimum 0
   */
  write_bandwidth_limit?: number;
  allowed_paths?: RsyncConfigAllowedPaths;
  /**
   * Daemon debounce delay for rsync in seconds
   */
  daemon_debounce_delay?: number;
  /**
   * Daemon poll interval for rsync in seconds
   */
  daemon_poll_interval?: number;
  /**
   * Daemon reconcile interval for rsync in seconds
   */
  daemon_reconcile_interval?: number;
  /**
   * Client upload rate limit for rsync in bytes per second, zero means no limit
   * @minimum 0
   */
  client_upload_rate_limit?: number;
}

export interface SMTPConfig {
  host?: string;
  sender?: string;
  password?: string;
}

/**
 * Stores any configs OSMO Admins control 
 */
export interface ServiceConfig {
  service_base_url?: string;
  service_auth?: AuthenticationConfig;
  cli_config?: CliConfig;
  max_pod_restart_limit?: string;
  agent_queue_size?: number;
}

/**
 * Static data credentials (i.e. credentials with access_key_id and access_key) for a data backend.
 */
export interface StaticDataCredential {
  /** The endpoint URL for the data service */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The encrypted authentication secret for a data backend */
  access_key: string;
}

/**
 * Object storing workflow name, logs, and spec after submission. 
 */
export interface SubmitResponse {
  name: string;
  overview?: string;
  logs?: string;
  spec?: string;
  dashboard_url?: string;
}

/**
 * Entry for task GET API result. 
 */
export interface TaskEntry {
  workflow_id: string;
  task_name: string;
  node?: string;
  start_time?: string;
  end_time?: string;
  status: TaskGroupStatus;
  storage: number;
  cpu: number;
  memory: number;
  gpu: number;
}

/**
 * Represents the status of a task group 
 */
export type TaskGroupStatus = typeof TaskGroupStatus[keyof typeof TaskGroupStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskGroupStatus = {
  SUBMITTING: 'SUBMITTING',
  WAITING: 'WAITING',
  PROCESSING: 'PROCESSING',
  SCHEDULING: 'SCHEDULING',
  INITIALIZING: 'INITIALIZING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  RESCHEDULED: 'RESCHEDULED',
  FAILED: 'FAILED',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_UPSTREAM: 'FAILED_UPSTREAM',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Represents the queryed group information. 
 */
export interface TaskQueryResponse {
  name: string;
  retry_id: number;
  status: TaskGroupStatus;
  failure_message?: string;
  exit_code?: number;
  logs: string;
  error_logs?: string;
  processing_start_time?: string;
  scheduling_start_time?: string;
  initializing_start_time?: string;
  events: string;
  start_time?: string;
  end_time?: string;
  input_download_start_time?: string;
  input_download_end_time?: string;
  output_upload_start_time?: string;
  dashboard_url?: string;
  pod_name: string;
  pod_ip?: string;
  task_uuid: string;
  node_name?: string;
  lead?: boolean;
}

/**
 * Template Spec. 
 */
export interface TemplateSpec {
  file: string;
  set_variables?: string[];
  set_string_variables?: string[];
  uploaded_templated_spec?: string;
}

/**
 * Single Toleration Entry 
 */
export interface Toleration {
  key: string;
  operator?: string;
  value?: string;
  effect?: string;
}

/**
 * Request body for updating config tags endpoint.
 */
export interface UpdateConfigTagsRequest {
  /** Tags to add to the config */
  set_tags?: string[];
  /** Tags to remove from the config */
  delete_tags?: string[];
}

/**
 * The credential dictionary that contains authentication information
 */
export type UserCredentialCredential = {[key: string]: string};

/**
 * Generic authentication information. 
 */
export interface UserCredential {
  /** The credential dictionary that contains authentication information */
  credential: UserCredentialCredential;
}

/**
 * Authentication information for a data service. 
 */
export interface UserDataCredential {
  /** The endpoint URL for the data service */
  endpoint: string;
  /** The region for the data service */
  region?: string;
  /** The authentication key for a data backend */
  access_key_id: string;
  /** The authentication secret for a data backend */
  access_key: string;
}

/**
 * Provides all User Profile Information 
 */
export interface UserProfile {
  username?: string;
  email_notification?: boolean;
  slack_notification?: boolean;
  bucket?: string;
  pool?: string;
}

/**
 * Authentication information for a Docker registry. 
 */
export interface UserRegistryCredential {
  /** The Docker registry URL */
  registry?: string;
  /** The username for the Docker registry */
  username?: string;
  /** The authentication token for the Docker registry */
  auth: string;
}

/**
 * Stores workflow limits per user. Default is None, which means no limit.
If a limit is set, it must be greater than 0.
 */
export interface UserWorkflowLimitConfig {
  /** */
  max_num_workflows?: number;
  /** */
  max_num_tasks?: number;
  jinja_sandbox_workers?: number;
  jinja_sandbox_max_time?: number;
  jinja_sandbox_memory_limit?: number;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type VerbosePoolConfigPools = {[key: string]: Pool};

/**
 * Stores verbose pool configs.
 */
export interface VerbosePoolConfig {
  pools?: VerbosePoolConfigPools;
}

/**
 * Stores any workflow configs External Admins control 
 */
export interface WorkflowConfig {
  workflow_data?: DataConfig;
  workflow_log?: LogConfig;
  workflow_app?: LogConfig;
  workflow_info?: WorkflowInfo;
  backend_images?: OsmoImageConfig;
  workflow_alerts?: NotificationConfig;
  credential_config?: CredentialConfig;
  user_workflow_limits?: UserWorkflowLimitConfig;
  plugins_config?: PluginsConfig;
  max_num_tasks?: number;
  max_num_ports_per_task?: number;
  max_retry_per_task?: number;
  max_retry_per_job?: number;
  default_schedule_timeout?: number;
  default_exec_timeout?: string;
  default_queue_timeout?: string;
  max_exec_timeout?: string;
  max_queue_timeout?: string;
  force_cleanup_delay?: string;
  max_log_lines?: number;
  max_task_log_lines?: number;
  max_error_log_lines?: number;
  max_event_log_lines?: number;
  task_heartbeat_frequency?: string;
}

/**
 * Config for workflow storage info. 
 */
export interface WorkflowInfo {
  tags?: string[];
  max_name_length?: number;
}

/**
 * Represents the state of plugins in a workflow upon submission. 
 */
export interface WorkflowPlugins {
  rsync?: boolean;
}

/**
 * Scheduling priority for workflows
 */
export type WorkflowPriority = typeof WorkflowPriority[keyof typeof WorkflowPriority];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowPriority = {
  HIGH: 'HIGH',
  NORMAL: 'NORMAL',
  LOW: 'LOW',
} as const;

/**
 * Represents the queryed workflow information. 
 */
export interface WorkflowQueryResponse {
  name: string;
  uuid: string;
  submitted_by: string;
  cancelled_by?: string;
  spec: string;
  template_spec: string;
  logs: string;
  events: string;
  overview: string;
  parent_name?: string;
  parent_job_id?: number;
  dashboard_url?: string;
  grafana_url?: string;
  tags?: string[];
  submit_time: string;
  start_time?: string;
  end_time?: string;
  exec_timeout?: number;
  queue_timeout?: number;
  duration?: number;
  queued_time: number;
  status: WorkflowStatus;
  outputs?: string;
  groups: GroupQueryResponse[];
  pool?: string;
  backend?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  plugins: WorkflowPlugins;
  priority: string;
}

/**
 * Represents the status of a workflow. 
 */
export type WorkflowStatus = typeof WorkflowStatus[keyof typeof WorkflowStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  WAITING: 'WAITING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  FAILED_SUBMISSION: 'FAILED_SUBMISSION',
  FAILED_SERVER_ERROR: 'FAILED_SERVER_ERROR',
  FAILED_EXEC_TIMEOUT: 'FAILED_EXEC_TIMEOUT',
  FAILED_QUEUE_TIMEOUT: 'FAILED_QUEUE_TIMEOUT',
  FAILED_CANCELED: 'FAILED_CANCELED',
  FAILED_BACKEND_ERROR: 'FAILED_BACKEND_ERROR',
  FAILED_IMAGE_PULL: 'FAILED_IMAGE_PULL',
  FAILED_EVICTED: 'FAILED_EVICTED',
  FAILED_START_ERROR: 'FAILED_START_ERROR',
  FAILED_START_TIMEOUT: 'FAILED_START_TIMEOUT',
  FAILED_PREEMPTED: 'FAILED_PREEMPTED',
} as const;

/**
 * Type of configs supported by config history 
 */
export type SrcLibUtilsConfigHistoryConfigHistoryType = typeof SrcLibUtilsConfigHistoryConfigHistoryType[keyof typeof SrcLibUtilsConfigHistoryConfigHistoryType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SrcLibUtilsConfigHistoryConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

export interface SrcServiceCoreAppObjectsListEntry {
  uuid: string;
  name: string;
  description: string;
  created_date: string;
  owner: string;
  latest_version: string;
}

export interface SrcServiceCoreAppObjectsListResponse {
  apps: SrcServiceCoreAppObjectsListEntry[];
  more_entries: boolean;
}

/**
 * Entry for list API results. 
 */
export interface SrcServiceCoreWorkflowObjectsListEntry {
  user: string;
  name: string;
  workflow_uuid: string;
  submit_time: string;
  start_time?: string;
  end_time?: string;
  queued_time: number;
  duration?: number;
  status: WorkflowStatus;
  overview: string;
  logs: string;
  error_logs?: string;
  grafana_url?: string;
  dashboard_url?: string;
  pool?: string;
  app_owner?: string;
  app_name?: string;
  app_version?: number;
  priority: string;
}

export interface SrcServiceCoreWorkflowObjectsListResponse {
  workflows: SrcServiceCoreWorkflowObjectsListEntry[];
  more_entries: boolean;
}

/**
 * Type of configs supported by config history 
 */
export type SrcUtilsConnectorsPostgresConfigHistoryType = typeof SrcUtilsConnectorsPostgresConfigHistoryType[keyof typeof SrcUtilsConnectorsPostgresConfigHistoryType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SrcUtilsConnectorsPostgresConfigHistoryType = {
  SERVICE: 'SERVICE',
  WORKFLOW: 'WORKFLOW',
  DATASET: 'DATASET',
  BACKEND: 'BACKEND',
  POOL: 'POOL',
  POD_TEMPLATE: 'POD_TEMPLATE',
  RESOURCE_VALIDATION: 'RESOURCE_VALIDATION',
  BACKEND_TEST: 'BACKEND_TEST',
  ROLE: 'ROLE',
} as const;

export type PutServiceConfigsApiConfigsServicePut200 = { [key: string]: unknown };

export type PatchServiceConfigsApiConfigsServicePatch200 = { [key: string]: unknown };

export type PutWorkflowConfigsApiConfigsWorkflowPut200 = { [key: string]: unknown };

export type PatchWorkflowConfigsApiConfigsWorkflowPatch200 = { [key: string]: unknown };

export type PutDatasetConfigsApiConfigsDatasetPut200 = { [key: string]: unknown };

export type PatchDatasetConfigsApiConfigsDatasetPatch200 = { [key: string]: unknown };

export type PatchDatasetApiConfigsDatasetNamePatch200 = { [key: string]: unknown };

export type ListPoolsApiConfigsPoolGetParams = {
verbose?: boolean;
backend?: string;
};

export type ReadPoolApiConfigsPoolNameGetParams = {
verbose?: boolean;
};

export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams = {
verbose?: boolean;
};

export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams = {
verbose?: boolean;
};

export type GetConfigsHistoryApiConfigsHistoryGetParams = {
/**
 * Number of records to skip
 * @minimum 0
 */
offset?: number;
/**
 * Maximum number of records to return
 * @maximum 1000
 */
limit?: number;
/**
 * Sort order by creation time
 */
order?: ListOrder;
/**
 * Filter by config types
 */
config_types?: SrcLibUtilsConfigHistoryConfigHistoryType[];
/**
 * Filter by config name
 */
name?: string;
/**
 * Filter by revision
 */
revision?: number;
/**
 * Filter by tags
 */
tags?: string[];
/**
 * Filter by creation time before
 */
created_before?: string;
/**
 * Filter by creation time after
 */
created_after?: string;
/**
 * Get config state at specific timestamp
 */
at_timestamp?: string;
/**
 * Whether to omit data from the response
 */
omit_data?: boolean;
};

export type GetConfigDiffApiConfigsDiffGetParams = {
config_type: SrcUtilsConnectorsPostgresConfigHistoryType;
/**
 * First revision to compare
 */
first_revision: number;
/**
 * Second revision to compare
 */
second_revision: number;
};

export type GetNewJwtTokenApiAuthJwtRefreshTokenGetParams = {
refresh_token: string;
workflow_id: string;
group_name: string;
task_name: string;
retry_id?: number;
};

export type GetNewJwtTokenApiAuthRefreshTokenGetParams = {
refresh_token: string;
workflow_id: string;
group_name: string;
task_name: string;
retry_id?: number;
};

export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams = {
access_token: string;
};

export type GetAccessTokenInfoApiAuthAccessTokenGetParams = {
access_token: string;
};

export type CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams = {
expires_at: string;
description?: string;
};

export type CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams = {
expires_at: string;
roles?: string[];
description?: string;
};

export type ListAppsApiAppGetParams = {
name?: string;
users?: string[];
all_users?: boolean;
offset?: number;
limit?: number;
order?: ListOrder;
};

export type GetAppApiAppUserNameGetParams = {
version?: number;
limit?: number;
order?: ListOrder;
};

export type CreateAppApiAppUserNamePostParams = {
description: string;
};

export type DeleteAppApiAppUserNameDeleteParams = {
version?: number;
all_versions?: boolean;
};

export type DeleteAppApiAppUserNameDelete200 = {[key: string]: number[]};

export type GetAppContentApiAppUserNameSpecGetParams = {
version?: number;
};

export type CancelWorkflowApiWorkflowNameCancelPostParams = {
message?: string;
force?: boolean;
};

export type ListWorkflowApiWorkflowGetParams = {
users?: string[];
name?: string;
statuses?: WorkflowStatus[];
offset?: number;
limit?: number;
order?: ListOrder;
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
submitted_before?: string;
submitted_after?: string;
tags?: string[];
app?: string;
priority?: WorkflowPriority[];
};

export type ListTaskApiTaskGetParams = {
workflow_id?: string;
statuses?: TaskGroupStatus[];
users?: string[];
all_users?: boolean;
pools?: string[];
all_pools?: boolean;
nodes?: string[];
started_after?: string;
started_before?: string;
offset?: number;
limit?: number;
order?: ListOrder;
summary?: boolean;
aggregate_by_workflow?: boolean;
priority?: WorkflowPriority[];
};

export type GetWorkflowApiWorkflowNameGetParams = {
skip_groups?: boolean;
verbose?: boolean;
};

export type GetWorkflowLogsApiWorkflowNameLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowPodConditionsApiWorkflowNameEventsGetParams = {
task_name?: string;
retry_id?: number;
};

export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams = {
last_n_lines?: number;
task_name?: string;
retry_id?: number;
query?: string;
};

export type GetWorkflowSpecApiWorkflowNameSpecGetParams = {
use_template?: boolean;
};

export type TagWorkflowApiWorkflowNameTagPostParams = {
add?: string[];
remove?: string[];
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams = {
entry_command: string;
};

export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200 = {[key: string]: RouterResponse};

export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams = {
entry_command: string;
};

export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams = {
task_ports?: number[];
use_udp?: boolean;
};

export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePost200 = RouterResponse[] | RouterResponse;

export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams = {
task_port: number;
};

export type GetResourcesApiResourcesGetParams = {
pools?: string[];
platforms?: string[];
all_pools?: boolean;
concise?: boolean;
};

export type GetPoolsApiPoolGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type GetPoolQuotasApiPoolQuotaGetParams = {
all_pools?: boolean;
pools?: string[];
};

export type SubmitWorkflowApiPoolPoolNameWorkflowPostParams = {
workflow_id?: string;
app_uuid?: string;
app_version?: number;
dry_run?: boolean;
validation_only?: boolean;
priority?: WorkflowPriority;
env_vars?: string[];
};

export type GetBucketInfoApiBucketGetParams = {
default_only?: boolean;
};

export type DeleteDatasetApiBucketBucketDatasetNameDeleteParams = {
tag?: string;
all_flag?: boolean;
finish?: boolean;
};

export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams = {
tag?: string;
new_name?: string;
set_tag?: string[];
delete_tag?: string[];
delete_label?: string[];
delete_metadata?: string[];
};

export type GetInfoApiBucketBucketDatasetNameInfoGetParams = {
tag?: string;
all_flag?: boolean;
count?: number;
order?: ListOrder;
};

export type ListDatasetFromBucketApiBucketListDatasetGetParams = {
name?: string;
user?: string[];
buckets?: string[];
dataset_type?: DatasetType;
latest_before?: string;
latest_after?: string;
all_users?: boolean;
order?: ListOrder;
count?: number;
};

export type QueryDatasetApiBucketBucketQueryGetParams = {
command?: string;
};

export type SetNotificationSettingsApiProfileSettingsPostParams = {
set_default_backend?: boolean;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Read all the service configurations
 * @summary Read Service Configs
 */
export const readServiceConfigsApiConfigsServiceGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/service`, method: 'GET', signal
    },
      options);
    }
  



export const getReadServiceConfigsApiConfigsServiceGetQueryKey = () => {
    return [
    `/api/configs/service`
    ] as const;
    }

    
export const getReadServiceConfigsApiConfigsServiceGetQueryOptions = <TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadServiceConfigsApiConfigsServiceGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>> = ({ signal }) => readServiceConfigsApiConfigsServiceGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadServiceConfigsApiConfigsServiceGetQueryResult = NonNullable<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>>
export type ReadServiceConfigsApiConfigsServiceGetQueryError = unknown


export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>,
          TError,
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>,
          TError,
          Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Service Configs
 */

export function useReadServiceConfigsApiConfigsServiceGet<TData = Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readServiceConfigsApiConfigsServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadServiceConfigsApiConfigsServiceGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put service configurations
 * @summary Put Service Configs
 */
export const putServiceConfigsApiConfigsServicePut = (
    putServiceRequest: PutServiceRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PutServiceConfigsApiConfigsServicePut200>(
      {url: `/api/configs/service`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putServiceRequest
    },
      options);
    }
  


export const getPutServiceConfigsApiConfigsServicePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext> => {

const mutationKey = ['putServiceConfigsApiConfigsServicePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, {data: PutServiceRequest}> = (props) => {
          const {data} = props ?? {};

          return  putServiceConfigsApiConfigsServicePut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutServiceConfigsApiConfigsServicePutMutationResult = NonNullable<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>>
    export type PutServiceConfigsApiConfigsServicePutMutationBody = PutServiceRequest
    export type PutServiceConfigsApiConfigsServicePutMutationError = HTTPValidationError

    /**
 * @summary Put Service Configs
 */
export const usePutServiceConfigsApiConfigsServicePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>, TError,{data: PutServiceRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putServiceConfigsApiConfigsServicePut>>,
        TError,
        {data: PutServiceRequest},
        TContext
      > => {

      const mutationOptions = getPutServiceConfigsApiConfigsServicePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch service configurations
 * @summary Patch Service Configs
 */
export const patchServiceConfigsApiConfigsServicePatch = (
    patchConfigRequest: PatchConfigRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PatchServiceConfigsApiConfigsServicePatch200>(
      {url: `/api/configs/service`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchConfigRequest
    },
      options);
    }
  


export const getPatchServiceConfigsApiConfigsServicePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchServiceConfigsApiConfigsServicePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchServiceConfigsApiConfigsServicePatch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchServiceConfigsApiConfigsServicePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>>
    export type PatchServiceConfigsApiConfigsServicePatchMutationBody = PatchConfigRequest
    export type PatchServiceConfigsApiConfigsServicePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Service Configs
 */
export const usePatchServiceConfigsApiConfigsServicePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchServiceConfigsApiConfigsServicePatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {

      const mutationOptions = getPatchServiceConfigsApiConfigsServicePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read all the workflow configurations
 * @summary Read Workflow Configs
 */
export const readWorkflowConfigsApiConfigsWorkflowGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/workflow`, method: 'GET', signal
    },
      options);
    }
  



export const getReadWorkflowConfigsApiConfigsWorkflowGetQueryKey = () => {
    return [
    `/api/configs/workflow`
    ] as const;
    }

    
export const getReadWorkflowConfigsApiConfigsWorkflowGetQueryOptions = <TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadWorkflowConfigsApiConfigsWorkflowGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>> = ({ signal }) => readWorkflowConfigsApiConfigsWorkflowGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadWorkflowConfigsApiConfigsWorkflowGetQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>>
export type ReadWorkflowConfigsApiConfigsWorkflowGetQueryError = unknown


export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Workflow Configs
 */

export function useReadWorkflowConfigsApiConfigsWorkflowGet<TData = Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readWorkflowConfigsApiConfigsWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadWorkflowConfigsApiConfigsWorkflowGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put workflow configurations
 * @summary Put Workflow Configs
 */
export const putWorkflowConfigsApiConfigsWorkflowPut = (
    putWorkflowRequest: PutWorkflowRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PutWorkflowConfigsApiConfigsWorkflowPut200>(
      {url: `/api/configs/workflow`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putWorkflowRequest
    },
      options);
    }
  


export const getPutWorkflowConfigsApiConfigsWorkflowPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext> => {

const mutationKey = ['putWorkflowConfigsApiConfigsWorkflowPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, {data: PutWorkflowRequest}> = (props) => {
          const {data} = props ?? {};

          return  putWorkflowConfigsApiConfigsWorkflowPut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationResult = NonNullable<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>>
    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationBody = PutWorkflowRequest
    export type PutWorkflowConfigsApiConfigsWorkflowPutMutationError = HTTPValidationError

    /**
 * @summary Put Workflow Configs
 */
export const usePutWorkflowConfigsApiConfigsWorkflowPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>, TError,{data: PutWorkflowRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putWorkflowConfigsApiConfigsWorkflowPut>>,
        TError,
        {data: PutWorkflowRequest},
        TContext
      > => {

      const mutationOptions = getPutWorkflowConfigsApiConfigsWorkflowPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch workflow configurations
 * @summary Patch Workflow Configs
 */
export const patchWorkflowConfigsApiConfigsWorkflowPatch = (
    patchConfigRequest: PatchConfigRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PatchWorkflowConfigsApiConfigsWorkflowPatch200>(
      {url: `/api/configs/workflow`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchConfigRequest
    },
      options);
    }
  


export const getPatchWorkflowConfigsApiConfigsWorkflowPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchWorkflowConfigsApiConfigsWorkflowPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchWorkflowConfigsApiConfigsWorkflowPatch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>>
    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationBody = PatchConfigRequest
    export type PatchWorkflowConfigsApiConfigsWorkflowPatchMutationError = HTTPValidationError

    /**
 * @summary Patch Workflow Configs
 */
export const usePatchWorkflowConfigsApiConfigsWorkflowPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchWorkflowConfigsApiConfigsWorkflowPatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {

      const mutationOptions = getPatchWorkflowConfigsApiConfigsWorkflowPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read all the dataset configurations
 * @summary Read Dataset Configs
 */
export const readDatasetConfigsApiConfigsDatasetGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/dataset`, method: 'GET', signal
    },
      options);
    }
  



export const getReadDatasetConfigsApiConfigsDatasetGetQueryKey = () => {
    return [
    `/api/configs/dataset`
    ] as const;
    }

    
export const getReadDatasetConfigsApiConfigsDatasetGetQueryOptions = <TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDatasetConfigsApiConfigsDatasetGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>> = ({ signal }) => readDatasetConfigsApiConfigsDatasetGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadDatasetConfigsApiConfigsDatasetGetQueryResult = NonNullable<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>>
export type ReadDatasetConfigsApiConfigsDatasetGetQueryError = unknown


export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Dataset Configs
 */

export function useReadDatasetConfigsApiConfigsDatasetGet<TData = Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readDatasetConfigsApiConfigsDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadDatasetConfigsApiConfigsDatasetGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put dataset configurations
 * @summary Put Dataset Configs
 */
export const putDatasetConfigsApiConfigsDatasetPut = (
    putDatasetRequest: PutDatasetRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PutDatasetConfigsApiConfigsDatasetPut200>(
      {url: `/api/configs/dataset`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putDatasetRequest
    },
      options);
    }
  


export const getPutDatasetConfigsApiConfigsDatasetPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext> => {

const mutationKey = ['putDatasetConfigsApiConfigsDatasetPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, {data: PutDatasetRequest}> = (props) => {
          const {data} = props ?? {};

          return  putDatasetConfigsApiConfigsDatasetPut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutDatasetConfigsApiConfigsDatasetPutMutationResult = NonNullable<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>>
    export type PutDatasetConfigsApiConfigsDatasetPutMutationBody = PutDatasetRequest
    export type PutDatasetConfigsApiConfigsDatasetPutMutationError = HTTPValidationError

    /**
 * @summary Put Dataset Configs
 */
export const usePutDatasetConfigsApiConfigsDatasetPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>, TError,{data: PutDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putDatasetConfigsApiConfigsDatasetPut>>,
        TError,
        {data: PutDatasetRequest},
        TContext
      > => {

      const mutationOptions = getPutDatasetConfigsApiConfigsDatasetPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch dataset configurations
 * @summary Patch Dataset Configs
 */
export const patchDatasetConfigsApiConfigsDatasetPatch = (
    patchConfigRequest: PatchConfigRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PatchDatasetConfigsApiConfigsDatasetPatch200>(
      {url: `/api/configs/dataset`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchConfigRequest
    },
      options);
    }
  


export const getPatchDatasetConfigsApiConfigsDatasetPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext> => {

const mutationKey = ['patchDatasetConfigsApiConfigsDatasetPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, {data: PatchConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchDatasetConfigsApiConfigsDatasetPatch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>>
    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationBody = PatchConfigRequest
    export type PatchDatasetConfigsApiConfigsDatasetPatchMutationError = HTTPValidationError

    /**
 * @summary Patch Dataset Configs
 */
export const usePatchDatasetConfigsApiConfigsDatasetPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>, TError,{data: PatchConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchDatasetConfigsApiConfigsDatasetPatch>>,
        TError,
        {data: PatchConfigRequest},
        TContext
      > => {

      const mutationOptions = getPatchDatasetConfigsApiConfigsDatasetPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete dataset configuration for a specific bucket
 * @summary Delete Dataset
 */
export const deleteDatasetApiConfigsDatasetNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/dataset/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeleteDatasetApiConfigsDatasetNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteDatasetApiConfigsDatasetNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteDatasetApiConfigsDatasetNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>>
    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationBody = ConfigsRequest
    export type DeleteDatasetApiConfigsDatasetNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDatasetApiConfigsDatasetNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDatasetApiConfigsDatasetNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeleteDatasetApiConfigsDatasetNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch dataset configuration for a specific bucket
 * @summary Patch Dataset
 */
export const patchDatasetApiConfigsDatasetNamePatch = (
    name: string,
    patchDatasetRequest: PatchDatasetRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PatchDatasetApiConfigsDatasetNamePatch200>(
      {url: `/api/configs/dataset/${name}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchDatasetRequest
    },
      options);
    }
  


export const getPatchDatasetApiConfigsDatasetNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext> => {

const mutationKey = ['patchDatasetApiConfigsDatasetNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, {name: string;data: PatchDatasetRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchDatasetApiConfigsDatasetNamePatch(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchDatasetApiConfigsDatasetNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>>
    export type PatchDatasetApiConfigsDatasetNamePatchMutationBody = PatchDatasetRequest
    export type PatchDatasetApiConfigsDatasetNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Dataset
 */
export const usePatchDatasetApiConfigsDatasetNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>, TError,{name: string;data: PatchDatasetRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchDatasetApiConfigsDatasetNamePatch>>,
        TError,
        {name: string;data: PatchDatasetRequest},
        TContext
      > => {

      const mutationOptions = getPatchDatasetApiConfigsDatasetNamePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all backends.
 * @summary List Backends
 */
export const listBackendsApiConfigsBackendGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/backend`, method: 'GET', signal
    },
      options);
    }
  



export const getListBackendsApiConfigsBackendGetQueryKey = () => {
    return [
    `/api/configs/backend`
    ] as const;
    }

    
export const getListBackendsApiConfigsBackendGetQueryOptions = <TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBackendsApiConfigsBackendGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>> = ({ signal }) => listBackendsApiConfigsBackendGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBackendsApiConfigsBackendGetQueryResult = NonNullable<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>>
export type ListBackendsApiConfigsBackendGetQueryError = unknown


export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Backends
 */

export function useListBackendsApiConfigsBackendGet<TData = Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendsApiConfigsBackendGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBackendsApiConfigsBackendGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get info for a specific backend.
 * @summary Get Backend
 */
export const getBackendApiConfigsBackendNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/backend/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetBackendApiConfigsBackendNameGetQueryKey = (name?: string,) => {
    return [
    `/api/configs/backend/${name}`
    ] as const;
    }

    
export const getGetBackendApiConfigsBackendNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBackendApiConfigsBackendNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>> = ({ signal }) => getBackendApiConfigsBackendNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBackendApiConfigsBackendNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>>
export type GetBackendApiConfigsBackendNameGetQueryError = HTTPValidationError


export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>,
          TError,
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>,
          TError,
          Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Backend
 */

export function useGetBackendApiConfigsBackendNameGet<TData = Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBackendApiConfigsBackendNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBackendApiConfigsBackendNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Override the config for a specific backend.
 * @summary Update Backend
 */
export const updateBackendApiConfigsBackendNamePost = (
    name: string,
    postBackendRequest: PostBackendRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend/${name}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postBackendRequest, signal
    },
      options);
    }
  


export const getUpdateBackendApiConfigsBackendNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext> => {

const mutationKey = ['updateBackendApiConfigsBackendNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, {name: string;data: PostBackendRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  updateBackendApiConfigsBackendNamePost(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBackendApiConfigsBackendNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>>
    export type UpdateBackendApiConfigsBackendNamePostMutationBody = PostBackendRequest
    export type UpdateBackendApiConfigsBackendNamePostMutationError = HTTPValidationError

    /**
 * @summary Update Backend
 */
export const useUpdateBackendApiConfigsBackendNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>, TError,{name: string;data: PostBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBackendApiConfigsBackendNamePost>>,
        TError,
        {name: string;data: PostBackendRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBackendApiConfigsBackendNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a backend.
 * @summary Delete Backend
 */
export const deleteBackendApiConfigsBackendNameDelete = (
    name: string,
    deleteBackendRequest: DeleteBackendRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteBackendRequest
    },
      options);
    }
  


export const getDeleteBackendApiConfigsBackendNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext> => {

const mutationKey = ['deleteBackendApiConfigsBackendNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, {name: string;data: DeleteBackendRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteBackendApiConfigsBackendNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBackendApiConfigsBackendNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>>
    export type DeleteBackendApiConfigsBackendNameDeleteMutationBody = DeleteBackendRequest
    export type DeleteBackendApiConfigsBackendNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Backend
 */
export const useDeleteBackendApiConfigsBackendNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>, TError,{name: string;data: DeleteBackendRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBackendApiConfigsBackendNameDelete>>,
        TError,
        {name: string;data: DeleteBackendRequest},
        TContext
      > => {

      const mutationOptions = getDeleteBackendApiConfigsBackendNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all Pools
 * @summary List Pools
 */
export const listPoolsApiConfigsPoolGet = (
    params?: ListPoolsApiConfigsPoolGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pool`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListPoolsApiConfigsPoolGetQueryKey = (params?: ListPoolsApiConfigsPoolGetParams,) => {
    return [
    `/api/configs/pool`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPoolsApiConfigsPoolGetQueryOptions = <TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPoolsApiConfigsPoolGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>> = ({ signal }) => listPoolsApiConfigsPoolGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPoolsApiConfigsPoolGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>>
export type ListPoolsApiConfigsPoolGetQueryError = HTTPValidationError


export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params: undefined |  ListPoolsApiConfigsPoolGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>,
          TError,
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>,
          TError,
          Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Pools
 */

export function useListPoolsApiConfigsPoolGet<TData = Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError = HTTPValidationError>(
 params?: ListPoolsApiConfigsPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoolsApiConfigsPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPoolsApiConfigsPoolGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Pool configurations
 * @summary Put Pools
 */
export const putPoolsApiConfigsPoolPut = (
    putPoolsRequest: PutPoolsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putPoolsRequest
    },
      options);
    }
  


export const getPutPoolsApiConfigsPoolPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext> => {

const mutationKey = ['putPoolsApiConfigsPoolPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, {data: PutPoolsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putPoolsApiConfigsPoolPut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPoolsApiConfigsPoolPutMutationResult = NonNullable<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>>
    export type PutPoolsApiConfigsPoolPutMutationBody = PutPoolsRequest
    export type PutPoolsApiConfigsPoolPutMutationError = HTTPValidationError

    /**
 * @summary Put Pools
 */
export const usePutPoolsApiConfigsPoolPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>, TError,{data: PutPoolsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPoolsApiConfigsPoolPut>>,
        TError,
        {data: PutPoolsRequest},
        TContext
      > => {

      const mutationOptions = getPutPoolsApiConfigsPoolPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read Pool configuration

Return type Any to prevent unwanted artifacts between Pool and PoolEditable outputs
Should return Pool or PoolEditable objects
 * @summary Read Pool
 */
export const readPoolApiConfigsPoolNameGet = (
    name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pool/${name}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getReadPoolApiConfigsPoolNameGetQueryKey = (name?: string,
    params?: ReadPoolApiConfigsPoolNameGetParams,) => {
    return [
    `/api/configs/pool/${name}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReadPoolApiConfigsPoolNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPoolApiConfigsPoolNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>> = ({ signal }) => readPoolApiConfigsPoolNameGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPoolApiConfigsPoolNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>>
export type ReadPoolApiConfigsPoolNameGetQueryError = HTTPValidationError


export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  ReadPoolApiConfigsPoolNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Pool
 */

export function useReadPoolApiConfigsPoolNameGet<TData = Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ReadPoolApiConfigsPoolNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPoolApiConfigsPoolNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPoolApiConfigsPoolNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Pool configurations
 * @summary Put Pool
 */
export const putPoolApiConfigsPoolNamePut = (
    name: string,
    putPoolRequest: PutPoolRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putPoolRequest
    },
      options);
    }
  


export const getPutPoolApiConfigsPoolNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext> => {

const mutationKey = ['putPoolApiConfigsPoolNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, {name: string;data: PutPoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putPoolApiConfigsPoolNamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPoolApiConfigsPoolNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>>
    export type PutPoolApiConfigsPoolNamePutMutationBody = PutPoolRequest
    export type PutPoolApiConfigsPoolNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Pool
 */
export const usePutPoolApiConfigsPoolNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>, TError,{name: string;data: PutPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPoolApiConfigsPoolNamePut>>,
        TError,
        {name: string;data: PutPoolRequest},
        TContext
      > => {

      const mutationOptions = getPutPoolApiConfigsPoolNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete Pool configurations
 * @summary Delete Pool
 */
export const deletePoolApiConfigsPoolNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeletePoolApiConfigsPoolNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deletePoolApiConfigsPoolNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deletePoolApiConfigsPoolNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePoolApiConfigsPoolNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>>
    export type DeletePoolApiConfigsPoolNameDeleteMutationBody = ConfigsRequest
    export type DeletePoolApiConfigsPoolNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Pool
 */
export const useDeletePoolApiConfigsPoolNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePoolApiConfigsPoolNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeletePoolApiConfigsPoolNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch Pool configurations
 * @summary Patch Pool
 */
export const patchPoolApiConfigsPoolNamePatch = (
    name: string,
    patchPoolRequest: PatchPoolRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchPoolRequest
    },
      options);
    }
  


export const getPatchPoolApiConfigsPoolNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext> => {

const mutationKey = ['patchPoolApiConfigsPoolNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, {name: string;data: PatchPoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchPoolApiConfigsPoolNamePatch(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchPoolApiConfigsPoolNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>>
    export type PatchPoolApiConfigsPoolNamePatchMutationBody = PatchPoolRequest
    export type PatchPoolApiConfigsPoolNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Pool
 */
export const usePatchPoolApiConfigsPoolNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>, TError,{name: string;data: PatchPoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchPoolApiConfigsPoolNamePatch>>,
        TError,
        {name: string;data: PatchPoolRequest},
        TContext
      > => {

      const mutationOptions = getPatchPoolApiConfigsPoolNamePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Rename Pool
 * @summary Rename Pool
 */
export const renamePoolApiConfigsPoolNameRenamePut = (
    name: string,
    renamePoolRequest: RenamePoolRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}/rename`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: renamePoolRequest
    },
      options);
    }
  


export const getRenamePoolApiConfigsPoolNameRenamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext> => {

const mutationKey = ['renamePoolApiConfigsPoolNameRenamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, {name: string;data: RenamePoolRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  renamePoolApiConfigsPoolNameRenamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RenamePoolApiConfigsPoolNameRenamePutMutationResult = NonNullable<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>>
    export type RenamePoolApiConfigsPoolNameRenamePutMutationBody = RenamePoolRequest
    export type RenamePoolApiConfigsPoolNameRenamePutMutationError = HTTPValidationError

    /**
 * @summary Rename Pool
 */
export const useRenamePoolApiConfigsPoolNameRenamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>, TError,{name: string;data: RenamePoolRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renamePoolApiConfigsPoolNameRenamePut>>,
        TError,
        {name: string;data: RenamePoolRequest},
        TContext
      > => {

      const mutationOptions = getRenamePoolApiConfigsPoolNameRenamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all Platforms

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Dict[str, Platform] or Dict[str, PlatformEditable] objects
 * @summary List Platforms In Pool
 */
export const listPlatformsInPoolApiConfigsPoolNamePlatformGet = (
    name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pool/${name}/platform`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryKey = (name?: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams,) => {
    return [
    `/api/configs/pool/${name}/platform`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryOptions = <TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>> = ({ signal }) => listPlatformsInPoolApiConfigsPoolNamePlatformGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>>
export type ListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryError = HTTPValidationError


export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>,
          TError,
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>,
          TError,
          Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Platforms In Pool
 */

export function useListPlatformsInPoolApiConfigsPoolNamePlatformGet<TData = Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError = HTTPValidationError>(
 name: string,
    params?: ListPlatformsInPoolApiConfigsPoolNamePlatformGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlatformsInPoolApiConfigsPoolNamePlatformGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPlatformsInPoolApiConfigsPoolNamePlatformGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Read Platform

Return type Any to prevent unwanted artifacts between verbose and editable outputs
Should return Platform or PlatformEditable objects
 * @summary Read Platform In Pool
 */
export const readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet = (
    name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pool/${name}/platform/${platformName}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryKey = (name?: string,
    platformName?: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams,) => {
    return [
    `/api/configs/pool/${name}/platform/${platformName}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryKey(name,platformName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>> = ({ signal }) => readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet(name,platformName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name && platformName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>>
export type ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryError = HTTPValidationError


export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params: undefined |  ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Platform In Pool
 */

export function useReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet<TData = Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError = HTTPValidationError>(
 name: string,
    platformName: string,
    params?: ReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPlatformInPoolApiConfigsPoolNamePlatformPlatformNameGetQueryOptions(name,platformName,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Platform configurations
 * @summary Put Platform In Pool
 */
export const putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut = (
    name: string,
    platformName: string,
    putPoolPlatformRequest: PutPoolPlatformRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}/platform/${platformName}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putPoolPlatformRequest
    },
      options);
    }
  


export const getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext> => {

const mutationKey = ['putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, {name: string;platformName: string;data: PutPoolPlatformRequest}> = (props) => {
          const {name,platformName,data} = props ?? {};

          return  putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut(name,platformName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>>
    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationBody = PutPoolPlatformRequest
    export type PutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Platform In Pool
 */
export const usePutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>, TError,{name: string;platformName: string;data: PutPoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePut>>,
        TError,
        {name: string;platformName: string;data: PutPoolPlatformRequest},
        TContext
      > => {

      const mutationOptions = getPutPlatformInPoolApiConfigsPoolNamePlatformPlatformNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Rename Platform
 * @summary Rename Platform In Pool
 */
export const renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut = (
    name: string,
    platformName: string,
    renamePoolPlatformRequest: RenamePoolPlatformRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pool/${name}/platform/${platformName}/rename`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: renamePoolPlatformRequest
    },
      options);
    }
  


export const getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext> => {

const mutationKey = ['renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, {name: string;platformName: string;data: RenamePoolPlatformRequest}> = (props) => {
          const {name,platformName,data} = props ?? {};

          return  renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut(name,platformName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationResult = NonNullable<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>>
    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationBody = RenamePoolPlatformRequest
    export type RenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationError = HTTPValidationError

    /**
 * @summary Rename Platform In Pool
 */
export const useRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>, TError,{name: string;platformName: string;data: RenamePoolPlatformRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePut>>,
        TError,
        {name: string;platformName: string;data: RenamePoolPlatformRequest},
        TContext
      > => {

      const mutationOptions = getRenamePlatformInPoolApiConfigsPoolNamePlatformPlatformNameRenamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all Pod Template configurations
 * @summary List Pod Templates
 */
export const listPodTemplatesApiConfigsPodTemplateGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pod_template`, method: 'GET', signal
    },
      options);
    }
  



export const getListPodTemplatesApiConfigsPodTemplateGetQueryKey = () => {
    return [
    `/api/configs/pod_template`
    ] as const;
    }

    
export const getListPodTemplatesApiConfigsPodTemplateGetQueryOptions = <TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPodTemplatesApiConfigsPodTemplateGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>> = ({ signal }) => listPodTemplatesApiConfigsPodTemplateGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPodTemplatesApiConfigsPodTemplateGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>>
export type ListPodTemplatesApiConfigsPodTemplateGetQueryError = unknown


export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>,
          TError,
          Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Pod Templates
 */

export function useListPodTemplatesApiConfigsPodTemplateGet<TData = Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPodTemplatesApiConfigsPodTemplateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPodTemplatesApiConfigsPodTemplateGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Set Dict of Pod Templates configurations
 * @summary Put Pod Templates
 */
export const putPodTemplatesApiConfigsPodTemplatePut = (
    putPodTemplatesRequest: PutPodTemplatesRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pod_template`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putPodTemplatesRequest
    },
      options);
    }
  


export const getPutPodTemplatesApiConfigsPodTemplatePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext> => {

const mutationKey = ['putPodTemplatesApiConfigsPodTemplatePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, {data: PutPodTemplatesRequest}> = (props) => {
          const {data} = props ?? {};

          return  putPodTemplatesApiConfigsPodTemplatePut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPodTemplatesApiConfigsPodTemplatePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>>
    export type PutPodTemplatesApiConfigsPodTemplatePutMutationBody = PutPodTemplatesRequest
    export type PutPodTemplatesApiConfigsPodTemplatePutMutationError = HTTPValidationError

    /**
 * @summary Put Pod Templates
 */
export const usePutPodTemplatesApiConfigsPodTemplatePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>, TError,{data: PutPodTemplatesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPodTemplatesApiConfigsPodTemplatePut>>,
        TError,
        {data: PutPodTemplatesRequest},
        TContext
      > => {

      const mutationOptions = getPutPodTemplatesApiConfigsPodTemplatePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read Pod Template configurations
 * @summary Read Pod Template
 */
export const readPodTemplateApiConfigsPodTemplateNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/pod_template/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getReadPodTemplateApiConfigsPodTemplateNameGetQueryKey = (name?: string,) => {
    return [
    `/api/configs/pod_template/${name}`
    ] as const;
    }

    
export const getReadPodTemplateApiConfigsPodTemplateNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPodTemplateApiConfigsPodTemplateNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>> = ({ signal }) => readPodTemplateApiConfigsPodTemplateNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadPodTemplateApiConfigsPodTemplateNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>>
export type ReadPodTemplateApiConfigsPodTemplateNameGetQueryError = HTTPValidationError


export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>,
          TError,
          Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Pod Template
 */

export function useReadPodTemplateApiConfigsPodTemplateNameGet<TData = Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readPodTemplateApiConfigsPodTemplateNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadPodTemplateApiConfigsPodTemplateNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Pod Template configurations
 * @summary Put Pod Template
 */
export const putPodTemplateApiConfigsPodTemplateNamePut = (
    name: string,
    putPodTemplateRequest: PutPodTemplateRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pod_template/${name}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putPodTemplateRequest
    },
      options);
    }
  


export const getPutPodTemplateApiConfigsPodTemplateNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext> => {

const mutationKey = ['putPodTemplateApiConfigsPodTemplateNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, {name: string;data: PutPodTemplateRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putPodTemplateApiConfigsPodTemplateNamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>>
    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationBody = PutPodTemplateRequest
    export type PutPodTemplateApiConfigsPodTemplateNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Pod Template
 */
export const usePutPodTemplateApiConfigsPodTemplateNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>, TError,{name: string;data: PutPodTemplateRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPodTemplateApiConfigsPodTemplateNamePut>>,
        TError,
        {name: string;data: PutPodTemplateRequest},
        TContext
      > => {

      const mutationOptions = getPutPodTemplateApiConfigsPodTemplateNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete Pod Template configurations
 * @summary Delete Pod Template
 */
export const deletePodTemplateApiConfigsPodTemplateNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/pod_template/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeletePodTemplateApiConfigsPodTemplateNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deletePodTemplateApiConfigsPodTemplateNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deletePodTemplateApiConfigsPodTemplateNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>>
    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationBody = ConfigsRequest
    export type DeletePodTemplateApiConfigsPodTemplateNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Pod Template
 */
export const useDeletePodTemplateApiConfigsPodTemplateNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePodTemplateApiConfigsPodTemplateNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeletePodTemplateApiConfigsPodTemplateNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all Resource Validation configurations
 * @summary List Resource Validations
 */
export const listResourceValidationsApiConfigsResourceValidationGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/resource_validation`, method: 'GET', signal
    },
      options);
    }
  



export const getListResourceValidationsApiConfigsResourceValidationGetQueryKey = () => {
    return [
    `/api/configs/resource_validation`
    ] as const;
    }

    
export const getListResourceValidationsApiConfigsResourceValidationGetQueryOptions = <TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListResourceValidationsApiConfigsResourceValidationGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>> = ({ signal }) => listResourceValidationsApiConfigsResourceValidationGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListResourceValidationsApiConfigsResourceValidationGetQueryResult = NonNullable<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>>
export type ListResourceValidationsApiConfigsResourceValidationGetQueryError = unknown


export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>,
          TError,
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>,
          TError,
          Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Resource Validations
 */

export function useListResourceValidationsApiConfigsResourceValidationGet<TData = Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourceValidationsApiConfigsResourceValidationGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListResourceValidationsApiConfigsResourceValidationGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Resource Validation configurations
 * @summary Put Resource Validations
 */
export const putResourceValidationsApiConfigsResourceValidationPut = (
    putResourceValidationsRequest: PutResourceValidationsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/resource_validation`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putResourceValidationsRequest
    },
      options);
    }
  


export const getPutResourceValidationsApiConfigsResourceValidationPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext> => {

const mutationKey = ['putResourceValidationsApiConfigsResourceValidationPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, {data: PutResourceValidationsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putResourceValidationsApiConfigsResourceValidationPut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutResourceValidationsApiConfigsResourceValidationPutMutationResult = NonNullable<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>>
    export type PutResourceValidationsApiConfigsResourceValidationPutMutationBody = PutResourceValidationsRequest
    export type PutResourceValidationsApiConfigsResourceValidationPutMutationError = HTTPValidationError

    /**
 * @summary Put Resource Validations
 */
export const usePutResourceValidationsApiConfigsResourceValidationPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>, TError,{data: PutResourceValidationsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putResourceValidationsApiConfigsResourceValidationPut>>,
        TError,
        {data: PutResourceValidationsRequest},
        TContext
      > => {

      const mutationOptions = getPutResourceValidationsApiConfigsResourceValidationPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read Resource Validation configurations
 * @summary Read Resource Validation
 */
export const readResourceValidationApiConfigsResourceValidationNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/resource_validation/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getReadResourceValidationApiConfigsResourceValidationNameGetQueryKey = (name?: string,) => {
    return [
    `/api/configs/resource_validation/${name}`
    ] as const;
    }

    
export const getReadResourceValidationApiConfigsResourceValidationNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadResourceValidationApiConfigsResourceValidationNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>> = ({ signal }) => readResourceValidationApiConfigsResourceValidationNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadResourceValidationApiConfigsResourceValidationNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>>
export type ReadResourceValidationApiConfigsResourceValidationNameGetQueryError = HTTPValidationError


export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>,
          TError,
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>,
          TError,
          Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Resource Validation
 */

export function useReadResourceValidationApiConfigsResourceValidationNameGet<TData = Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readResourceValidationApiConfigsResourceValidationNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadResourceValidationApiConfigsResourceValidationNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Resource Validation configurations
 * @summary Put Resource Validation
 */
export const putResourceValidationApiConfigsResourceValidationNamePut = (
    name: string,
    putResourceValidationRequest: PutResourceValidationRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/resource_validation/${name}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putResourceValidationRequest
    },
      options);
    }
  


export const getPutResourceValidationApiConfigsResourceValidationNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext> => {

const mutationKey = ['putResourceValidationApiConfigsResourceValidationNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, {name: string;data: PutResourceValidationRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putResourceValidationApiConfigsResourceValidationNamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>>
    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationBody = PutResourceValidationRequest
    export type PutResourceValidationApiConfigsResourceValidationNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Resource Validation
 */
export const usePutResourceValidationApiConfigsResourceValidationNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>, TError,{name: string;data: PutResourceValidationRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putResourceValidationApiConfigsResourceValidationNamePut>>,
        TError,
        {name: string;data: PutResourceValidationRequest},
        TContext
      > => {

      const mutationOptions = getPutResourceValidationApiConfigsResourceValidationNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete Resource Validation configurations
 * @summary Delete Resource Validation
 */
export const deleteResourceValidationApiConfigsResourceValidationNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/resource_validation/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteResourceValidationApiConfigsResourceValidationNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteResourceValidationApiConfigsResourceValidationNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>>
    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationBody = ConfigsRequest
    export type DeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Resource Validation
 */
export const useDeleteResourceValidationApiConfigsResourceValidationNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteResourceValidationApiConfigsResourceValidationNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeleteResourceValidationApiConfigsResourceValidationNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all Roles
 * @summary List Roles
 */
export const listRolesApiConfigsRoleGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/role`, method: 'GET', signal
    },
      options);
    }
  



export const getListRolesApiConfigsRoleGetQueryKey = () => {
    return [
    `/api/configs/role`
    ] as const;
    }

    
export const getListRolesApiConfigsRoleGetQueryOptions = <TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRolesApiConfigsRoleGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>> = ({ signal }) => listRolesApiConfigsRoleGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListRolesApiConfigsRoleGetQueryResult = NonNullable<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>>
export type ListRolesApiConfigsRoleGetQueryError = unknown


export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>,
          TError,
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>,
          TError,
          Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Roles
 */

export function useListRolesApiConfigsRoleGet<TData = Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesApiConfigsRoleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListRolesApiConfigsRoleGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put Roles
 * @summary Put Roles
 */
export const putRolesApiConfigsRolePut = (
    putRolesRequest: PutRolesRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/role`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putRolesRequest
    },
      options);
    }
  


export const getPutRolesApiConfigsRolePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext> => {

const mutationKey = ['putRolesApiConfigsRolePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, {data: PutRolesRequest}> = (props) => {
          const {data} = props ?? {};

          return  putRolesApiConfigsRolePut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutRolesApiConfigsRolePutMutationResult = NonNullable<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>>
    export type PutRolesApiConfigsRolePutMutationBody = PutRolesRequest
    export type PutRolesApiConfigsRolePutMutationError = HTTPValidationError

    /**
 * @summary Put Roles
 */
export const usePutRolesApiConfigsRolePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>, TError,{data: PutRolesRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putRolesApiConfigsRolePut>>,
        TError,
        {data: PutRolesRequest},
        TContext
      > => {

      const mutationOptions = getPutRolesApiConfigsRolePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read Role
 * @summary Read Role
 */
export const readRoleApiConfigsRoleNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/role/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getReadRoleApiConfigsRoleNameGetQueryKey = (name?: string,) => {
    return [
    `/api/configs/role/${name}`
    ] as const;
    }

    
export const getReadRoleApiConfigsRoleNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRoleApiConfigsRoleNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>> = ({ signal }) => readRoleApiConfigsRoleNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadRoleApiConfigsRoleNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>>
export type ReadRoleApiConfigsRoleNameGetQueryError = HTTPValidationError


export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>,
          TError,
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>,
          TError,
          Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Role
 */

export function useReadRoleApiConfigsRoleNameGet<TData = Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readRoleApiConfigsRoleNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadRoleApiConfigsRoleNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Patch Role configurations
 * @summary Put Role
 */
export const putRoleApiConfigsRoleNamePut = (
    name: string,
    putRoleRequest: PutRoleRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/role/${name}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putRoleRequest
    },
      options);
    }
  


export const getPutRoleApiConfigsRoleNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext> => {

const mutationKey = ['putRoleApiConfigsRoleNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, {name: string;data: PutRoleRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putRoleApiConfigsRoleNamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutRoleApiConfigsRoleNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>>
    export type PutRoleApiConfigsRoleNamePutMutationBody = PutRoleRequest
    export type PutRoleApiConfigsRoleNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Role
 */
export const usePutRoleApiConfigsRoleNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>, TError,{name: string;data: PutRoleRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putRoleApiConfigsRoleNamePut>>,
        TError,
        {name: string;data: PutRoleRequest},
        TContext
      > => {

      const mutationOptions = getPutRoleApiConfigsRoleNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete Role
 * @summary Delete Role
 */
export const deleteRoleApiConfigsRoleNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/role/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeleteRoleApiConfigsRoleNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteRoleApiConfigsRoleNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteRoleApiConfigsRoleNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleApiConfigsRoleNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>>
    export type DeleteRoleApiConfigsRoleNameDeleteMutationBody = ConfigsRequest
    export type DeleteRoleApiConfigsRoleNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Role
 */
export const useDeleteRoleApiConfigsRoleNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoleApiConfigsRoleNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeleteRoleApiConfigsRoleNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all backend test configurations
 * @summary List Backend Tests
 */
export const listBackendTestsApiConfigsBackendTestGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/backend_test`, method: 'GET', signal
    },
      options);
    }
  



export const getListBackendTestsApiConfigsBackendTestGetQueryKey = () => {
    return [
    `/api/configs/backend_test`
    ] as const;
    }

    
export const getListBackendTestsApiConfigsBackendTestGetQueryOptions = <TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBackendTestsApiConfigsBackendTestGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>> = ({ signal }) => listBackendTestsApiConfigsBackendTestGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBackendTestsApiConfigsBackendTestGetQueryResult = NonNullable<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>>
export type ListBackendTestsApiConfigsBackendTestGetQueryError = unknown


export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>,
          TError,
          Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Backend Tests
 */

export function useListBackendTestsApiConfigsBackendTestGet<TData = Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBackendTestsApiConfigsBackendTestGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBackendTestsApiConfigsBackendTestGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put backend test configurations
 * @summary Put Backend Tests
 */
export const putBackendTestsApiConfigsBackendTestPut = (
    putBackendTestsRequest: PutBackendTestsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend_test`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putBackendTestsRequest
    },
      options);
    }
  


export const getPutBackendTestsApiConfigsBackendTestPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext> => {

const mutationKey = ['putBackendTestsApiConfigsBackendTestPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, {data: PutBackendTestsRequest}> = (props) => {
          const {data} = props ?? {};

          return  putBackendTestsApiConfigsBackendTestPut(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutBackendTestsApiConfigsBackendTestPutMutationResult = NonNullable<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>>
    export type PutBackendTestsApiConfigsBackendTestPutMutationBody = PutBackendTestsRequest
    export type PutBackendTestsApiConfigsBackendTestPutMutationError = HTTPValidationError

    /**
 * @summary Put Backend Tests
 */
export const usePutBackendTestsApiConfigsBackendTestPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>, TError,{data: PutBackendTestsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putBackendTestsApiConfigsBackendTestPut>>,
        TError,
        {data: PutBackendTestsRequest},
        TContext
      > => {

      const mutationOptions = getPutBackendTestsApiConfigsBackendTestPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read backend test configuration
 * @summary Read Backend Test
 */
export const readBackendTestApiConfigsBackendTestNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/backend_test/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getReadBackendTestApiConfigsBackendTestNameGetQueryKey = (name?: string,) => {
    return [
    `/api/configs/backend_test/${name}`
    ] as const;
    }

    
export const getReadBackendTestApiConfigsBackendTestNameGetQueryOptions = <TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadBackendTestApiConfigsBackendTestNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>> = ({ signal }) => readBackendTestApiConfigsBackendTestNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadBackendTestApiConfigsBackendTestNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>>
export type ReadBackendTestApiConfigsBackendTestNameGetQueryError = HTTPValidationError


export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>,
          TError,
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>,
          TError,
          Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Backend Test
 */

export function useReadBackendTestApiConfigsBackendTestNameGet<TData = Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readBackendTestApiConfigsBackendTestNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadBackendTestApiConfigsBackendTestNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Put backend test configuration
 * @summary Put Backend Test
 */
export const putBackendTestApiConfigsBackendTestNamePut = (
    name: string,
    putBackendTestRequest: PutBackendTestRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend_test/${name}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putBackendTestRequest
    },
      options);
    }
  


export const getPutBackendTestApiConfigsBackendTestNamePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext> => {

const mutationKey = ['putBackendTestApiConfigsBackendTestNamePut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, {name: string;data: PutBackendTestRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  putBackendTestApiConfigsBackendTestNamePut(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutBackendTestApiConfigsBackendTestNamePutMutationResult = NonNullable<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>>
    export type PutBackendTestApiConfigsBackendTestNamePutMutationBody = PutBackendTestRequest
    export type PutBackendTestApiConfigsBackendTestNamePutMutationError = HTTPValidationError

    /**
 * @summary Put Backend Test
 */
export const usePutBackendTestApiConfigsBackendTestNamePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>, TError,{name: string;data: PutBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putBackendTestApiConfigsBackendTestNamePut>>,
        TError,
        {name: string;data: PutBackendTestRequest},
        TContext
      > => {

      const mutationOptions = getPutBackendTestApiConfigsBackendTestNamePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete test configuration
 * @summary Delete Backend Test
 */
export const deleteBackendTestApiConfigsBackendTestNameDelete = (
    name: string,
    configsRequest: ConfigsRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend_test/${name}`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: configsRequest
    },
      options);
    }
  


export const getDeleteBackendTestApiConfigsBackendTestNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext> => {

const mutationKey = ['deleteBackendTestApiConfigsBackendTestNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, {name: string;data: ConfigsRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  deleteBackendTestApiConfigsBackendTestNameDelete(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>>
    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationBody = ConfigsRequest
    export type DeleteBackendTestApiConfigsBackendTestNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Backend Test
 */
export const useDeleteBackendTestApiConfigsBackendTestNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>, TError,{name: string;data: ConfigsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBackendTestApiConfigsBackendTestNameDelete>>,
        TError,
        {name: string;data: ConfigsRequest},
        TContext
      > => {

      const mutationOptions = getDeleteBackendTestApiConfigsBackendTestNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Patch backend test configuration
 * @summary Patch Backend Test
 */
export const patchBackendTestApiConfigsBackendTestNamePatch = (
    name: string,
    patchBackendTestRequest: PatchBackendTestRequest,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/backend_test/${name}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchBackendTestRequest
    },
      options);
    }
  


export const getPatchBackendTestApiConfigsBackendTestNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext> => {

const mutationKey = ['patchBackendTestApiConfigsBackendTestNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, {name: string;data: PatchBackendTestRequest}> = (props) => {
          const {name,data} = props ?? {};

          return  patchBackendTestApiConfigsBackendTestNamePatch(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>>
    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationBody = PatchBackendTestRequest
    export type PatchBackendTestApiConfigsBackendTestNamePatchMutationError = HTTPValidationError

    /**
 * @summary Patch Backend Test
 */
export const usePatchBackendTestApiConfigsBackendTestNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>, TError,{name: string;data: PatchBackendTestRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchBackendTestApiConfigsBackendTestNamePatch>>,
        TError,
        {name: string;data: PatchBackendTestRequest},
        TContext
      > => {

      const mutationOptions = getPatchBackendTestApiConfigsBackendTestNamePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List history of all configs
 * @summary Get Configs History
 */
export const getConfigsHistoryApiConfigsHistoryGet = (
    params?: GetConfigsHistoryApiConfigsHistoryGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetConfigsHistoryResponse>(
      {url: `/api/configs/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetConfigsHistoryApiConfigsHistoryGetQueryKey = (params?: GetConfigsHistoryApiConfigsHistoryGetParams,) => {
    return [
    `/api/configs/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetConfigsHistoryApiConfigsHistoryGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfigsHistoryApiConfigsHistoryGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>> = ({ signal }) => getConfigsHistoryApiConfigsHistoryGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigsHistoryApiConfigsHistoryGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>>
export type GetConfigsHistoryApiConfigsHistoryGetQueryError = HTTPValidationError


export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params: undefined |  GetConfigsHistoryApiConfigsHistoryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Configs History
 */

export function useGetConfigsHistoryApiConfigsHistoryGet<TData = Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError = HTTPValidationError>(
 params?: GetConfigsHistoryApiConfigsHistoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigsHistoryApiConfigsHistoryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConfigsHistoryApiConfigsHistoryGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Roll back a config to a particular revision.
 * @summary Rollback Config
 */
export const rollbackConfigApiConfigsHistoryRollbackPost = (
    rollbackConfigRequest: RollbackConfigRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/history/rollback`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rollbackConfigRequest, signal
    },
      options);
    }
  


export const getRollbackConfigApiConfigsHistoryRollbackPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext> => {

const mutationKey = ['rollbackConfigApiConfigsHistoryRollbackPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, {data: RollbackConfigRequest}> = (props) => {
          const {data} = props ?? {};

          return  rollbackConfigApiConfigsHistoryRollbackPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RollbackConfigApiConfigsHistoryRollbackPostMutationResult = NonNullable<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>>
    export type RollbackConfigApiConfigsHistoryRollbackPostMutationBody = RollbackConfigRequest
    export type RollbackConfigApiConfigsHistoryRollbackPostMutationError = HTTPValidationError

    /**
 * @summary Rollback Config
 */
export const useRollbackConfigApiConfigsHistoryRollbackPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>, TError,{data: RollbackConfigRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rollbackConfigApiConfigsHistoryRollbackPost>>,
        TError,
        {data: RollbackConfigRequest},
        TContext
      > => {

      const mutationOptions = getRollbackConfigApiConfigsHistoryRollbackPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a specific config history revision. This performs a soft delete of the revision.

Args:
    config_type: Type of config to delete
    revision: Revision number to delete (must be greater than 0)
    username: Username of the person performing the delete

Raises:
    OSMOUserError: If the revision doesn't exist or is the current revision
 * @summary Delete Config History Revision
 */
export const deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete = (
    configType: string,
    revision: number,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/history/${configType}/revision/${revision}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext> => {

const mutationKey = ['deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, {configType: string;revision: number}> = (props) => {
          const {configType,revision} = props ?? {};

          return  deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete(configType,revision,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>>
    
    export type DeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Config History Revision
 */
export const useDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>, TError,{configType: string;revision: number}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDelete>>,
        TError,
        {configType: string;revision: number},
        TContext
      > => {

      const mutationOptions = getDeleteConfigHistoryRevisionApiConfigsHistoryConfigTypeRevisionRevisionDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update tags for a specific config history revision.

Args:
    config_type: Type of config to update
    revision: Revision number to update (must be greater than 0)
    request: Request containing tags to add and delete
    username: Username of the person performing the update

Raises:
    OSMOUserError: If the revision doesn't exist or is invalid
 * @summary Update Config History Tags
 */
export const updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost = (
    configType: string,
    revision: number,
    updateConfigTagsRequest: UpdateConfigTagsRequest,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/configs/history/${configType}/revision/${revision}/tags`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: updateConfigTagsRequest, signal
    },
      options);
    }
  


export const getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext> => {

const mutationKey = ['updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, {configType: string;revision: number;data: UpdateConfigTagsRequest}> = (props) => {
          const {configType,revision,data} = props ?? {};

          return  updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost(configType,revision,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>>
    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationBody = UpdateConfigTagsRequest
    export type UpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationError = HTTPValidationError

    /**
 * @summary Update Config History Tags
 */
export const useUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>, TError,{configType: string;revision: number;data: UpdateConfigTagsRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPost>>,
        TError,
        {configType: string;revision: number;data: UpdateConfigTagsRequest},
        TContext
      > => {

      const mutationOptions = getUpdateConfigHistoryTagsApiConfigsHistoryConfigTypeRevisionRevisionTagsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns two config revisions, similar to
GET /api/configs/history/{config_type}/revision/{revision}, but with obfuscated secret strings
that say if a secret string is changed. Intended for use with the `diff` command.

Args:
    request: Request containing config type and revisions to compare

Returns:
    ConfigDiffResponse containing the two revisions

Raises:
    OSMOUserError: If either revision doesn't exist or is invalid
 * @summary Get Config Diff
 */
export const getConfigDiffApiConfigsDiffGet = (
    params: GetConfigDiffApiConfigsDiffGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/configs/diff`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetConfigDiffApiConfigsDiffGetQueryKey = (params?: GetConfigDiffApiConfigsDiffGetParams,) => {
    return [
    `/api/configs/diff`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetConfigDiffApiConfigsDiffGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfigDiffApiConfigsDiffGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>> = ({ signal }) => getConfigDiffApiConfigsDiffGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigDiffApiConfigsDiffGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>>
export type GetConfigDiffApiConfigsDiffGetQueryError = HTTPValidationError


export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Config Diff
 */

export function useGetConfigDiffApiConfigsDiffGet<TData = Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError = HTTPValidationError>(
 params: GetConfigDiffApiConfigsDiffGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigDiffApiConfigsDiffGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConfigDiffApiConfigsDiffGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to fetch for a new access token using a refresh token.
 * @summary Get New Jwt Token
 */
export const getNewJwtTokenApiAuthJwtRefreshTokenGet = (
    params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/jwt/refresh_token`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryKey = (params?: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams,) => {
    return [
    `/api/auth/jwt/refresh_token`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>> = ({ signal }) => getNewJwtTokenApiAuthJwtRefreshTokenGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewJwtTokenApiAuthJwtRefreshTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>>
export type GetNewJwtTokenApiAuthJwtRefreshTokenGetQueryError = HTTPValidationError


export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get New Jwt Token
 */

export function useGetNewJwtTokenApiAuthJwtRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthJwtRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthJwtRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewJwtTokenApiAuthJwtRefreshTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to fetch for a new access token using a refresh token.
 * @summary Get New Jwt Token
 */
export const getNewJwtTokenApiAuthRefreshTokenGet = (
    params: GetNewJwtTokenApiAuthRefreshTokenGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/refresh_token`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetNewJwtTokenApiAuthRefreshTokenGetQueryKey = (params?: GetNewJwtTokenApiAuthRefreshTokenGetParams,) => {
    return [
    `/api/auth/refresh_token`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetNewJwtTokenApiAuthRefreshTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError = HTTPValidationError>(params: GetNewJwtTokenApiAuthRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewJwtTokenApiAuthRefreshTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>> = ({ signal }) => getNewJwtTokenApiAuthRefreshTokenGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewJwtTokenApiAuthRefreshTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>>
export type GetNewJwtTokenApiAuthRefreshTokenGetQueryError = HTTPValidationError


export function useGetNewJwtTokenApiAuthRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthRefreshTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewJwtTokenApiAuthRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get New Jwt Token
 */

export function useGetNewJwtTokenApiAuthRefreshTokenGet<TData = Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError = HTTPValidationError>(
 params: GetNewJwtTokenApiAuthRefreshTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewJwtTokenApiAuthRefreshTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewJwtTokenApiAuthRefreshTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to create a new jwt token from an access token.
 * @summary Get Jwt Token From Access Token
 */
export const getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet = (
    params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/jwt/access_token`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryKey = (params?: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams,) => {
    return [
    `/api/auth/jwt/access_token`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>> = ({ signal }) => getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>>
export type GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryError = HTTPValidationError


export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Jwt Token From Access Token
 */

export function useGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet<TData = Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getJwtTokenFromAccessTokenApiAuthJwtAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetJwtTokenFromAccessTokenApiAuthJwtAccessTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to get the info for an access token.
 * @summary Get Access Token Info
 */
export const getAccessTokenInfoApiAuthAccessTokenGet = (
    params: GetAccessTokenInfoApiAuthAccessTokenGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<AccessToken>(
      {url: `/api/auth/access_token`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAccessTokenInfoApiAuthAccessTokenGetQueryKey = (params?: GetAccessTokenInfoApiAuthAccessTokenGetParams,) => {
    return [
    `/api/auth/access_token`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAccessTokenInfoApiAuthAccessTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError = HTTPValidationError>(params: GetAccessTokenInfoApiAuthAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessTokenInfoApiAuthAccessTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>> = ({ signal }) => getAccessTokenInfoApiAuthAccessTokenGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAccessTokenInfoApiAuthAccessTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>>
export type GetAccessTokenInfoApiAuthAccessTokenGetQueryError = HTTPValidationError


export function useGetAccessTokenInfoApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetAccessTokenInfoApiAuthAccessTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAccessTokenInfoApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetAccessTokenInfoApiAuthAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>,
          TError,
          Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAccessTokenInfoApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetAccessTokenInfoApiAuthAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Access Token Info
 */

export function useGetAccessTokenInfoApiAuthAccessTokenGet<TData = Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError = HTTPValidationError>(
 params: GetAccessTokenInfoApiAuthAccessTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessTokenInfoApiAuthAccessTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAccessTokenInfoApiAuthAccessTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to create a new access token.
 * @summary Create Access Token
 */
export const createAccessTokenApiAuthAccessTokenUserTokenNamePost = (
    tokenName: string,
    params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/access_token/user/${tokenName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getCreateAccessTokenApiAuthAccessTokenUserTokenNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams}, TContext> => {

const mutationKey = ['createAccessTokenApiAuthAccessTokenUserTokenNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>, {tokenName: string;params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams}> = (props) => {
          const {tokenName,params} = props ?? {};

          return  createAccessTokenApiAuthAccessTokenUserTokenNamePost(tokenName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAccessTokenApiAuthAccessTokenUserTokenNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>>
    
    export type CreateAccessTokenApiAuthAccessTokenUserTokenNamePostMutationError = HTTPValidationError

    /**
 * @summary Create Access Token
 */
export const useCreateAccessTokenApiAuthAccessTokenUserTokenNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>, TError,{tokenName: string;params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAccessTokenApiAuthAccessTokenUserTokenNamePost>>,
        TError,
        {tokenName: string;params: CreateAccessTokenApiAuthAccessTokenUserTokenNamePostParams},
        TContext
      > => {

      const mutationOptions = getCreateAccessTokenApiAuthAccessTokenUserTokenNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * API to delete an access token.
 * @summary Delete Access Token
 */
export const deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete = (
    tokenName: string,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/access_token/user/${tokenName}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAccessTokenApiAuthAccessTokenUserTokenNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>, TError,{tokenName: string}, TContext> => {

const mutationKey = ['deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>, {tokenName: string}> = (props) => {
          const {tokenName} = props ?? {};

          return  deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete(tokenName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAccessTokenApiAuthAccessTokenUserTokenNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>>
    
    export type DeleteAccessTokenApiAuthAccessTokenUserTokenNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Access Token
 */
export const useDeleteAccessTokenApiAuthAccessTokenUserTokenNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAccessTokenApiAuthAccessTokenUserTokenNameDelete>>,
        TError,
        {tokenName: string},
        TContext
      > => {

      const mutationOptions = getDeleteAccessTokenApiAuthAccessTokenUserTokenNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * API to create a new service access token.
 * @summary Create Service Access Token
 */
export const createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost = (
    tokenName: string,
    params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/access_token/service/${tokenName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getCreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>, TError,{tokenName: string;params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>, TError,{tokenName: string;params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams}, TContext> => {

const mutationKey = ['createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>, {tokenName: string;params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams}> = (props) => {
          const {tokenName,params} = props ?? {};

          return  createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost(tokenName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>>
    
    export type CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostMutationError = HTTPValidationError

    /**
 * @summary Create Service Access Token
 */
export const useCreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>, TError,{tokenName: string;params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createServiceAccessTokenApiAuthAccessTokenServiceTokenNamePost>>,
        TError,
        {tokenName: string;params: CreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostParams},
        TContext
      > => {

      const mutationOptions = getCreateServiceAccessTokenApiAuthAccessTokenServiceTokenNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * API to delete a service access token.
 * @summary Delete Service Access Token
 */
export const deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete = (
    tokenName: string,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/auth/access_token/service/${tokenName}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>, TError,{tokenName: string}, TContext> => {

const mutationKey = ['deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>, {tokenName: string}> = (props) => {
          const {tokenName} = props ?? {};

          return  deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete(tokenName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>>
    
    export type DeleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Service Access Token
 */
export const useDeleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>, TError,{tokenName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDelete>>,
        TError,
        {tokenName: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceAccessTokenApiAuthAccessTokenServiceTokenNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * API to list all access tokens for a user.
 * @summary List Access Tokens
 */
export const listAccessTokensApiAuthAccessTokenUserGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<AccessToken[]>(
      {url: `/api/auth/access_token/user`, method: 'GET', signal
    },
      options);
    }
  



export const getListAccessTokensApiAuthAccessTokenUserGetQueryKey = () => {
    return [
    `/api/auth/access_token/user`
    ] as const;
    }

    
export const getListAccessTokensApiAuthAccessTokenUserGetQueryOptions = <TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAccessTokensApiAuthAccessTokenUserGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>> = ({ signal }) => listAccessTokensApiAuthAccessTokenUserGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAccessTokensApiAuthAccessTokenUserGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>>
export type ListAccessTokensApiAuthAccessTokenUserGetQueryError = HTTPValidationError


export function useListAccessTokensApiAuthAccessTokenUserGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokensApiAuthAccessTokenUserGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>,
          TError,
          Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessTokensApiAuthAccessTokenUserGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Access Tokens
 */

export function useListAccessTokensApiAuthAccessTokenUserGet<TData = Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessTokensApiAuthAccessTokenUserGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAccessTokensApiAuthAccessTokenUserGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * API to list all service access tokens.
 * @summary List Service Access Tokens
 */
export const listServiceAccessTokensApiAuthAccessTokenServiceGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<AccessToken[]>(
      {url: `/api/auth/access_token/service`, method: 'GET', signal
    },
      options);
    }
  



export const getListServiceAccessTokensApiAuthAccessTokenServiceGetQueryKey = () => {
    return [
    `/api/auth/access_token/service`
    ] as const;
    }

    
export const getListServiceAccessTokensApiAuthAccessTokenServiceGetQueryOptions = <TData = Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceAccessTokensApiAuthAccessTokenServiceGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>> = ({ signal }) => listServiceAccessTokensApiAuthAccessTokenServiceGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListServiceAccessTokensApiAuthAccessTokenServiceGetQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>>
export type ListServiceAccessTokensApiAuthAccessTokenServiceGetQueryError = unknown


export function useListServiceAccessTokensApiAuthAccessTokenServiceGet<TData = Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>,
          TError,
          Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServiceAccessTokensApiAuthAccessTokenServiceGet<TData = Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>,
          TError,
          Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListServiceAccessTokensApiAuthAccessTokenServiceGet<TData = Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Service Access Tokens
 */

export function useListServiceAccessTokensApiAuthAccessTokenServiceGet<TData = Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listServiceAccessTokensApiAuthAccessTokenServiceGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListServiceAccessTokensApiAuthAccessTokenServiceGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List Apps
 */
export const listAppsApiAppGet = (
    params?: ListAppsApiAppGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/app`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListAppsApiAppGetQueryKey = (params?: ListAppsApiAppGetParams,) => {
    return [
    `/api/app`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAppsApiAppGetQueryOptions = <TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAppsApiAppGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAppsApiAppGet>>> = ({ signal }) => listAppsApiAppGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAppsApiAppGetQueryResult = NonNullable<Awaited<ReturnType<typeof listAppsApiAppGet>>>
export type ListAppsApiAppGetQueryError = HTTPValidationError


export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params: undefined |  ListAppsApiAppGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppsApiAppGet>>,
          TError,
          Awaited<ReturnType<typeof listAppsApiAppGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAppsApiAppGet>>,
          TError,
          Awaited<ReturnType<typeof listAppsApiAppGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Apps
 */

export function useListAppsApiAppGet<TData = Awaited<ReturnType<typeof listAppsApiAppGet>>, TError = HTTPValidationError>(
 params?: ListAppsApiAppGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAppsApiAppGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAppsApiAppGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get App
 */
export const getAppApiAppUserNameGet = (
    name: string,
    params?: GetAppApiAppUserNameGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/app/user/${name}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAppApiAppUserNameGetQueryKey = (name?: string,
    params?: GetAppApiAppUserNameGetParams,) => {
    return [
    `/api/app/user/${name}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAppApiAppUserNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppApiAppUserNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>> = ({ signal }) => getAppApiAppUserNameGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppApiAppUserNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>>
export type GetAppApiAppUserNameGetQueryError = HTTPValidationError


export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetAppApiAppUserNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>,
          TError,
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>,
          TError,
          Awaited<ReturnType<typeof getAppApiAppUserNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get App
 */

export function useGetAppApiAppUserNameGet<TData = Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppApiAppUserNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppApiAppUserNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAppApiAppUserNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Create App
 */
export const createAppApiAppUserNamePost = (
    name: string,
    createAppApiAppUserNamePostBody: string,
    params: CreateAppApiAppUserNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/app/user/${name}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAppApiAppUserNamePostBody,
        params, signal
    },
      options);
    }
  


export const getCreateAppApiAppUserNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext> => {

const mutationKey = ['createAppApiAppUserNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, {name: string;data: string;params: CreateAppApiAppUserNamePostParams}> = (props) => {
          const {name,data,params} = props ?? {};

          return  createAppApiAppUserNamePost(name,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAppApiAppUserNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>>
    export type CreateAppApiAppUserNamePostMutationBody = string
    export type CreateAppApiAppUserNamePostMutationError = HTTPValidationError

    /**
 * @summary Create App
 */
export const useCreateAppApiAppUserNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAppApiAppUserNamePost>>, TError,{name: string;data: string;params: CreateAppApiAppUserNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAppApiAppUserNamePost>>,
        TError,
        {name: string;data: string;params: CreateAppApiAppUserNamePostParams},
        TContext
      > => {

      const mutationOptions = getCreateAppApiAppUserNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete App
 */
export const deleteAppApiAppUserNameDelete = (
    name: string,
    params?: DeleteAppApiAppUserNameDeleteParams,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<DeleteAppApiAppUserNameDelete200>(
      {url: `/api/app/user/${name}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteAppApiAppUserNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext> => {

const mutationKey = ['deleteAppApiAppUserNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, {name: string;params?: DeleteAppApiAppUserNameDeleteParams}> = (props) => {
          const {name,params} = props ?? {};

          return  deleteAppApiAppUserNameDelete(name,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAppApiAppUserNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>>
    
    export type DeleteAppApiAppUserNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete App
 */
export const useDeleteAppApiAppUserNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>, TError,{name: string;params?: DeleteAppApiAppUserNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAppApiAppUserNameDelete>>,
        TError,
        {name: string;params?: DeleteAppApiAppUserNameDeleteParams},
        TContext
      > => {

      const mutationOptions = getDeleteAppApiAppUserNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Update App
 */
export const updateAppApiAppUserNamePatch = (
    name: string,
    updateAppApiAppUserNamePatchBody: string,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<EditResponse>(
      {url: `/api/app/user/${name}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateAppApiAppUserNamePatchBody
    },
      options);
    }
  


export const getUpdateAppApiAppUserNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext> => {

const mutationKey = ['updateAppApiAppUserNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, {name: string;data: string}> = (props) => {
          const {name,data} = props ?? {};

          return  updateAppApiAppUserNamePatch(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAppApiAppUserNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>>
    export type UpdateAppApiAppUserNamePatchMutationBody = string
    export type UpdateAppApiAppUserNamePatchMutationError = HTTPValidationError

    /**
 * @summary Update App
 */
export const useUpdateAppApiAppUserNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAppApiAppUserNamePatch>>,
        TError,
        {name: string;data: string},
        TContext
      > => {

      const mutationOptions = getUpdateAppApiAppUserNamePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get App Content
 */
export const getAppContentApiAppUserNameSpecGet = (
    name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/app/user/${name}/spec`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAppContentApiAppUserNameSpecGetQueryKey = (name?: string,
    params?: GetAppContentApiAppUserNameSpecGetParams,) => {
    return [
    `/api/app/user/${name}/spec`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAppContentApiAppUserNameSpecGetQueryOptions = <TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppContentApiAppUserNameSpecGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>> = ({ signal }) => getAppContentApiAppUserNameSpecGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppContentApiAppUserNameSpecGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>>
export type GetAppContentApiAppUserNameSpecGetQueryError = HTTPValidationError


export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetAppContentApiAppUserNameSpecGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get App Content
 */

export function useGetAppContentApiAppUserNameSpecGet<TData = Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetAppContentApiAppUserNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppContentApiAppUserNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAppContentApiAppUserNameSpecGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Rename App
 */
export const renameAppApiAppUserNameRenamePost = (
    name: string,
    renameAppApiAppUserNameRenamePostBody: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/app/user/${name}/rename`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: renameAppApiAppUserNameRenamePostBody, signal
    },
      options);
    }
  


export const getRenameAppApiAppUserNameRenamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext> => {

const mutationKey = ['renameAppApiAppUserNameRenamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, {name: string;data: string}> = (props) => {
          const {name,data} = props ?? {};

          return  renameAppApiAppUserNameRenamePost(name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RenameAppApiAppUserNameRenamePostMutationResult = NonNullable<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>>
    export type RenameAppApiAppUserNameRenamePostMutationBody = string
    export type RenameAppApiAppUserNameRenamePostMutationError = HTTPValidationError

    /**
 * @summary Rename App
 */
export const useRenameAppApiAppUserNameRenamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>, TError,{name: string;data: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof renameAppApiAppUserNameRenamePost>>,
        TError,
        {name: string;data: string},
        TContext
      > => {

      const mutationOptions = getRenameAppApiAppUserNameRenamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Cancels the workflow.
 * @summary Cancel Workflow
 */
export const cancelWorkflowApiWorkflowNameCancelPost = (
    name: string,
    params?: CancelWorkflowApiWorkflowNameCancelPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CancelResponse>(
      {url: `/api/workflow/${name}/cancel`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getCancelWorkflowApiWorkflowNameCancelPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext> => {

const mutationKey = ['cancelWorkflowApiWorkflowNameCancelPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, {name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}> = (props) => {
          const {name,params} = props ?? {};

          return  cancelWorkflowApiWorkflowNameCancelPost(name,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelWorkflowApiWorkflowNameCancelPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>>
    
    export type CancelWorkflowApiWorkflowNameCancelPostMutationError = HTTPValidationError

    /**
 * @summary Cancel Workflow
 */
export const useCancelWorkflowApiWorkflowNameCancelPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>, TError,{name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelWorkflowApiWorkflowNameCancelPost>>,
        TError,
        {name: string;params?: CancelWorkflowApiWorkflowNameCancelPostParams},
        TContext
      > => {

      const mutationOptions = getCancelWorkflowApiWorkflowNameCancelPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary List Workflow
 */
export const listWorkflowApiWorkflowGet = (
    params?: ListWorkflowApiWorkflowGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListWorkflowApiWorkflowGetQueryKey = (params?: ListWorkflowApiWorkflowGetParams,) => {
    return [
    `/api/workflow`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListWorkflowApiWorkflowGetQueryOptions = <TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListWorkflowApiWorkflowGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>> = ({ signal }) => listWorkflowApiWorkflowGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListWorkflowApiWorkflowGetQueryResult = NonNullable<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>>
export type ListWorkflowApiWorkflowGetQueryError = HTTPValidationError


export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params: undefined |  ListWorkflowApiWorkflowGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>,
          TError,
          Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Workflow
 */

export function useListWorkflowApiWorkflowGet<TData = Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError = HTTPValidationError>(
 params?: ListWorkflowApiWorkflowGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listWorkflowApiWorkflowGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListWorkflowApiWorkflowGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the task (with the latest retry_id) with the given name in the workflow.
 * @summary Get Workflow Task
 */
export const getWorkflowTaskApiWorkflowNameTaskTaskNameGet = (
    name: string,
    taskName: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}/task/${taskName}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryKey = (name?: string,
    taskName?: string,) => {
    return [
    `/api/workflow/${name}/task/${taskName}`
    ] as const;
    }

    
export const getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryKey(name,taskName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>> = ({ signal }) => getWorkflowTaskApiWorkflowNameTaskTaskNameGet(name,taskName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name && taskName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>>
export type GetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryError = HTTPValidationError


export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Task
 */

export function useGetWorkflowTaskApiWorkflowNameTaskTaskNameGet<TData = Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError = HTTPValidationError>(
 name: string,
    taskName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowTaskApiWorkflowNameTaskTaskNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowTaskApiWorkflowNameTaskTaskNameGetQueryOptions(name,taskName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary List Task
 */
export const listTaskApiTaskGet = (
    params?: ListTaskApiTaskGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/task`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListTaskApiTaskGetQueryKey = (params?: ListTaskApiTaskGetParams,) => {
    return [
    `/api/task`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListTaskApiTaskGetQueryOptions = <TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTaskApiTaskGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTaskApiTaskGet>>> = ({ signal }) => listTaskApiTaskGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTaskApiTaskGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTaskApiTaskGet>>>
export type ListTaskApiTaskGetQueryError = HTTPValidationError


export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params: undefined |  ListTaskApiTaskGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTaskApiTaskGet>>,
          TError,
          Awaited<ReturnType<typeof listTaskApiTaskGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTaskApiTaskGet>>,
          TError,
          Awaited<ReturnType<typeof listTaskApiTaskGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Task
 */

export function useListTaskApiTaskGet<TData = Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError = HTTPValidationError>(
 params?: ListTaskApiTaskGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTaskApiTaskGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTaskApiTaskGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow with the given name in the database.
 * @summary Get Workflow
 */
export const getWorkflowApiWorkflowNameGet = (
    name: string,
    params?: GetWorkflowApiWorkflowNameGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetWorkflowApiWorkflowNameGetQueryKey = (name?: string,
    params?: GetWorkflowApiWorkflowNameGetParams,) => {
    return [
    `/api/workflow/${name}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWorkflowApiWorkflowNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowApiWorkflowNameGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>> = ({ signal }) => getWorkflowApiWorkflowNameGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowApiWorkflowNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>>
export type GetWorkflowApiWorkflowNameGetQueryError = HTTPValidationError


export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowApiWorkflowNameGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow
 */

export function useGetWorkflowApiWorkflowNameGet<TData = Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowApiWorkflowNameGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowApiWorkflowNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowApiWorkflowNameGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow logs.
 * @summary Get Workflow Logs
 */
export const getWorkflowLogsApiWorkflowNameLogsGet = (
    name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}/logs`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetWorkflowLogsApiWorkflowNameLogsGetQueryKey = (name?: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams,) => {
    return [
    `/api/workflow/${name}/logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWorkflowLogsApiWorkflowNameLogsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowLogsApiWorkflowNameLogsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>> = ({ signal }) => getWorkflowLogsApiWorkflowNameLogsGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowLogsApiWorkflowNameLogsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>>
export type GetWorkflowLogsApiWorkflowNameLogsGetQueryError = HTTPValidationError


export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowLogsApiWorkflowNameLogsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Logs
 */

export function useGetWorkflowLogsApiWorkflowNameLogsGet<TData = Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowLogsApiWorkflowNameLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowLogsApiWorkflowNameLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowLogsApiWorkflowNameLogsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow pod conditions.
 * @summary Get Workflow Pod Conditions
 */
export const getWorkflowPodConditionsApiWorkflowNameEventsGet = (
    name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}/events`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryKey = (name?: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams,) => {
    return [
    `/api/workflow/${name}/events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>> = ({ signal }) => getWorkflowPodConditionsApiWorkflowNameEventsGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowPodConditionsApiWorkflowNameEventsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>>
export type GetWorkflowPodConditionsApiWorkflowNameEventsGetQueryError = HTTPValidationError


export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Pod Conditions
 */

export function useGetWorkflowPodConditionsApiWorkflowNameEventsGet<TData = Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowPodConditionsApiWorkflowNameEventsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPodConditionsApiWorkflowNameEventsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowPodConditionsApiWorkflowNameEventsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow error logs.
 * @summary Get Workflow Error Logs
 */
export const getWorkflowErrorLogsApiWorkflowNameErrorLogsGet = (
    name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}/error_logs`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryKey = (name?: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams,) => {
    return [
    `/api/workflow/${name}/error_logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>> = ({ signal }) => getWorkflowErrorLogsApiWorkflowNameErrorLogsGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>>
export type GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryError = HTTPValidationError


export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Error Logs
 */

export function useGetWorkflowErrorLogsApiWorkflowNameErrorLogsGet<TData = Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowErrorLogsApiWorkflowNameErrorLogsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowErrorLogsApiWorkflowNameErrorLogsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowErrorLogsApiWorkflowNameErrorLogsGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow spec.
 * @summary Get Workflow Spec
 */
export const getWorkflowSpecApiWorkflowNameSpecGet = (
    name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/workflow/${name}/spec`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetWorkflowSpecApiWorkflowNameSpecGetQueryKey = (name?: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams,) => {
    return [
    `/api/workflow/${name}/spec`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWorkflowSpecApiWorkflowNameSpecGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowSpecApiWorkflowNameSpecGetQueryKey(name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>> = ({ signal }) => getWorkflowSpecApiWorkflowNameSpecGet(name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowSpecApiWorkflowNameSpecGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>>
export type GetWorkflowSpecApiWorkflowNameSpecGetQueryError = HTTPValidationError


export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params: undefined |  GetWorkflowSpecApiWorkflowNameSpecGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Spec
 */

export function useGetWorkflowSpecApiWorkflowNameSpecGet<TData = Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError = HTTPValidationError>(
 name: string,
    params?: GetWorkflowSpecApiWorkflowNameSpecGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowSpecApiWorkflowNameSpecGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowSpecApiWorkflowNameSpecGetQueryOptions(name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the workflow spec.
 * @summary Tag Workflow
 */
export const tagWorkflowApiWorkflowNameTagPost = (
    name: string,
    params?: TagWorkflowApiWorkflowNameTagPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/workflow/${name}/tag`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getTagWorkflowApiWorkflowNameTagPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext> => {

const mutationKey = ['tagWorkflowApiWorkflowNameTagPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, {name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}> = (props) => {
          const {name,params} = props ?? {};

          return  tagWorkflowApiWorkflowNameTagPost(name,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagWorkflowApiWorkflowNameTagPostMutationResult = NonNullable<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>>
    
    export type TagWorkflowApiWorkflowNameTagPostMutationError = HTTPValidationError

    /**
 * @summary Tag Workflow
 */
export const useTagWorkflowApiWorkflowNameTagPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>, TError,{name: string;params?: TagWorkflowApiWorkflowNameTagPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagWorkflowApiWorkflowNameTagPost>>,
        TError,
        {name: string;params?: TagWorkflowApiWorkflowNameTagPostParams},
        TContext
      > => {

      const mutationOptions = getTagWorkflowApiWorkflowNameTagPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Send command to all tasks in a group.
 * @summary Exec Into Group
 */
export const execIntoGroupApiWorkflowNameExecGroupGroupNamePost = (
    name: string,
    groupName: string,
    params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<ExecIntoGroupApiWorkflowNameExecGroupGroupNamePost200>(
      {url: `/api/workflow/${name}/exec/group/${groupName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext> => {

const mutationKey = ['execIntoGroupApiWorkflowNameExecGroupGroupNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, {name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}> = (props) => {
          const {name,groupName,params} = props ?? {};

          return  execIntoGroupApiWorkflowNameExecGroupGroupNamePost(name,groupName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>>
    
    export type ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationError = HTTPValidationError

    /**
 * @summary Exec Into Group
 */
export const useExecIntoGroupApiWorkflowNameExecGroupGroupNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>, TError,{name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof execIntoGroupApiWorkflowNameExecGroupGroupNamePost>>,
        TError,
        {name: string;groupName: string;params: ExecIntoGroupApiWorkflowNameExecGroupGroupNamePostParams},
        TContext
      > => {

      const mutationOptions = getExecIntoGroupApiWorkflowNameExecGroupGroupNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Exec into a task container.
 * @summary Exec Into Task
 */
export const execIntoTaskApiWorkflowNameExecTaskTaskNamePost = (
    name: string,
    taskName: string,
    params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<RouterResponse>(
      {url: `/api/workflow/${name}/exec/task/${taskName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext> => {

const mutationKey = ['execIntoTaskApiWorkflowNameExecTaskTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, {name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  execIntoTaskApiWorkflowNameExecTaskTaskNamePost(name,taskName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>>
    
    export type ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Exec Into Task
 */
export const useExecIntoTaskApiWorkflowNameExecTaskTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>, TError,{name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof execIntoTaskApiWorkflowNameExecTaskTaskNamePost>>,
        TError,
        {name: string;taskName: string;params: ExecIntoTaskApiWorkflowNameExecTaskTaskNamePostParams},
        TContext
      > => {

      const mutationOptions = getExecIntoTaskApiWorkflowNameExecTaskTaskNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Portforward into a task container.
 * @summary Port Forward Task
 */
export const portForwardTaskApiWorkflowNamePortforwardTaskNamePost = (
    name: string,
    taskName: string,
    params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<PortForwardTaskApiWorkflowNamePortforwardTaskNamePost200>(
      {url: `/api/workflow/${name}/portforward/${taskName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext> => {

const mutationKey = ['portForwardTaskApiWorkflowNamePortforwardTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, {name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  portForwardTaskApiWorkflowNamePortforwardTaskNamePost(name,taskName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>>
    
    export type PortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Port Forward Task
 */
export const usePortForwardTaskApiWorkflowNamePortforwardTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>, TError,{name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof portForwardTaskApiWorkflowNamePortforwardTaskNamePost>>,
        TError,
        {name: string;taskName: string;params?: PortForwardTaskApiWorkflowNamePortforwardTaskNamePostParams},
        TContext
      > => {

      const mutationOptions = getPortForwardTaskApiWorkflowNamePortforwardTaskNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Hold a webserver connection to a task container.
 * @summary Port Forward Webserver
 */
export const portForwardWebserverApiWorkflowNameWebserverTaskNamePost = (
    name: string,
    taskName: string,
    params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<RouterResponse>(
      {url: `/api/workflow/${name}/webserver/${taskName}`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext> => {

const mutationKey = ['portForwardWebserverApiWorkflowNameWebserverTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, {name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}> = (props) => {
          const {name,taskName,params} = props ?? {};

          return  portForwardWebserverApiWorkflowNameWebserverTaskNamePost(name,taskName,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>>
    
    export type PortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Port Forward Webserver
 */
export const usePortForwardWebserverApiWorkflowNameWebserverTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>, TError,{name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof portForwardWebserverApiWorkflowNameWebserverTaskNamePost>>,
        TError,
        {name: string;taskName: string;params: PortForwardWebserverApiWorkflowNameWebserverTaskNamePostParams},
        TContext
      > => {

      const mutationOptions = getPortForwardWebserverApiWorkflowNameWebserverTaskNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Rsync into a task container.
 * @summary Rsync Task
 */
export const rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost = (
    name: string,
    taskName: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<RouterResponse>(
      {url: `/api/workflow/${name}/rsync/task/${taskName}`, method: 'POST', signal
    },
      options);
    }
  


export const getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext> => {

const mutationKey = ['rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, {name: string;taskName: string}> = (props) => {
          const {name,taskName} = props ?? {};

          return  rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost(name,taskName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>>
    
    export type RsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationError = HTTPValidationError

    /**
 * @summary Rsync Task
 */
export const useRsyncTaskApiWorkflowNameRsyncTaskTaskNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>, TError,{name: string;taskName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rsyncTaskApiWorkflowNameRsyncTaskTaskNamePost>>,
        TError,
        {name: string;taskName: string},
        TContext
      > => {

      const mutationOptions = getRsyncTaskApiWorkflowNameRsyncTaskTaskNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get default/all user credentials
 * @summary Get User Credential
 */
export const getUserCredentialApiCredentialsGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/credentials`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUserCredentialApiCredentialsGetQueryKey = () => {
    return [
    `/api/credentials`
    ] as const;
    }

    
export const getGetUserCredentialApiCredentialsGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserCredentialApiCredentialsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>> = ({ signal }) => getUserCredentialApiCredentialsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserCredentialApiCredentialsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>>
export type GetUserCredentialApiCredentialsGetQueryError = HTTPValidationError


export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Credential
 */

export function useGetUserCredentialApiCredentialsGet<TData = Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserCredentialApiCredentialsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserCredentialApiCredentialsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Post/Update user credentials
 * @summary Set User Credential
 */
export const setUserCredentialApiCredentialsCredNamePost = (
    credName: string,
    credentialOptions: CredentialOptions,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/credentials/${credName}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: credentialOptions, signal
    },
      options);
    }
  


export const getSetUserCredentialApiCredentialsCredNamePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext> => {

const mutationKey = ['setUserCredentialApiCredentialsCredNamePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, {credName: string;data: CredentialOptions}> = (props) => {
          const {credName,data} = props ?? {};

          return  setUserCredentialApiCredentialsCredNamePost(credName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetUserCredentialApiCredentialsCredNamePostMutationResult = NonNullable<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>>
    export type SetUserCredentialApiCredentialsCredNamePostMutationBody = CredentialOptions
    export type SetUserCredentialApiCredentialsCredNamePostMutationError = HTTPValidationError

    /**
 * @summary Set User Credential
 */
export const useSetUserCredentialApiCredentialsCredNamePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>, TError,{credName: string;data: CredentialOptions}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setUserCredentialApiCredentialsCredNamePost>>,
        TError,
        {credName: string;data: CredentialOptions},
        TContext
      > => {

      const mutationOptions = getSetUserCredentialApiCredentialsCredNamePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete user credentials given the secret_id
 * @summary Delete Users Credential
 */
export const deleteUsersCredentialApiCredentialsCredNameDelete = (
    credName: string,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<CredentialGetResponse>(
      {url: `/api/credentials/${credName}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUsersCredentialApiCredentialsCredNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext> => {

const mutationKey = ['deleteUsersCredentialApiCredentialsCredNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, {credName: string}> = (props) => {
          const {credName} = props ?? {};

          return  deleteUsersCredentialApiCredentialsCredNameDelete(credName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersCredentialApiCredentialsCredNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>>
    
    export type DeleteUsersCredentialApiCredentialsCredNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Users Credential
 */
export const useDeleteUsersCredentialApiCredentialsCredNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>, TError,{credName: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsersCredentialApiCredentialsCredNameDelete>>,
        TError,
        {credName: string},
        TContext
      > => {

      const mutationOptions = getDeleteUsersCredentialApiCredentialsCredNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns the information of resources available in different pools.
 * @summary Get Resources
 */
export const getResourcesApiResourcesGet = (
    params?: GetResourcesApiResourcesGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/resources`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetResourcesApiResourcesGetQueryKey = (params?: GetResourcesApiResourcesGetParams,) => {
    return [
    `/api/resources`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetResourcesApiResourcesGetQueryOptions = <TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResourcesApiResourcesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>> = ({ signal }) => getResourcesApiResourcesGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResourcesApiResourcesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>>
export type GetResourcesApiResourcesGetQueryError = HTTPValidationError


export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params: undefined |  GetResourcesApiResourcesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>,
          TError,
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>,
          TError,
          Awaited<ReturnType<typeof getResourcesApiResourcesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Resources
 */

export function useGetResourcesApiResourcesGet<TData = Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError = HTTPValidationError>(
 params?: GetResourcesApiResourcesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResourcesApiResourcesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResourcesApiResourcesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the request resource's information.
 * @summary Get One Resource
 */
export const getOneResourceApiResourcesNameGet = (
    name: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/resources/${name}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOneResourceApiResourcesNameGetQueryKey = (name?: string,) => {
    return [
    `/api/resources/${name}`
    ] as const;
    }

    
export const getGetOneResourceApiResourcesNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOneResourceApiResourcesNameGetQueryKey(name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>> = ({ signal }) => getOneResourceApiResourcesNameGet(name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOneResourceApiResourcesNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>>
export type GetOneResourceApiResourcesNameGetQueryError = HTTPValidationError


export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>,
          TError,
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>,
          TError,
          Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get One Resource
 */

export function useGetOneResourceApiResourcesNameGet<TData = Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError = HTTPValidationError>(
 name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOneResourceApiResourcesNameGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOneResourceApiResourcesNameGetQueryOptions(name,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns information regarding pools to users.

If all_pools is set to true, all pools' information will be returned in API response.
Otherwise, only information from pools that the user has access to will be returned
in the response.
 * @summary Get Pools
 */
export const getPoolsApiPoolGet = (
    params?: GetPoolsApiPoolGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/pool`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetPoolsApiPoolGetQueryKey = (params?: GetPoolsApiPoolGetParams,) => {
    return [
    `/api/pool`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPoolsApiPoolGetQueryOptions = <TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPoolsApiPoolGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPoolsApiPoolGet>>> = ({ signal }) => getPoolsApiPoolGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPoolsApiPoolGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPoolsApiPoolGet>>>
export type GetPoolsApiPoolGetQueryError = HTTPValidationError


export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPoolsApiPoolGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolsApiPoolGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pools
 */

export function useGetPoolsApiPoolGet<TData = Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError = HTTPValidationError>(
 params?: GetPoolsApiPoolGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolsApiPoolGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPoolsApiPoolGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Pool Quotas
 */
export const getPoolQuotasApiPoolQuotaGet = (
    params?: GetPoolQuotasApiPoolQuotaGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/pool_quota`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetPoolQuotasApiPoolQuotaGetQueryKey = (params?: GetPoolQuotasApiPoolQuotaGetParams,) => {
    return [
    `/api/pool_quota`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPoolQuotasApiPoolQuotaGetQueryOptions = <TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPoolQuotasApiPoolQuotaGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>> = ({ signal }) => getPoolQuotasApiPoolQuotaGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPoolQuotasApiPoolQuotaGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>>
export type GetPoolQuotasApiPoolQuotaGetQueryError = HTTPValidationError


export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPoolQuotasApiPoolQuotaGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>,
          TError,
          Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pool Quotas
 */

export function useGetPoolQuotasApiPoolQuotaGet<TData = Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError = HTTPValidationError>(
 params?: GetPoolQuotasApiPoolQuotaGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPoolQuotasApiPoolQuotaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPoolQuotasApiPoolQuotaGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This api validates that a workflow is well formed and valid and then submits it.
 * @summary Submit Workflow
 */
export const submitWorkflowApiPoolPoolNameWorkflowPost = (
    poolName: string,
    templateSpec: TemplateSpec,
    params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<SubmitResponse>(
      {url: `/api/pool/${poolName}/workflow`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: templateSpec,
        params, signal
    },
      options);
    }
  


export const getSubmitWorkflowApiPoolPoolNameWorkflowPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext> => {

const mutationKey = ['submitWorkflowApiPoolPoolNameWorkflowPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, {poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}> = (props) => {
          const {poolName,data,params} = props ?? {};

          return  submitWorkflowApiPoolPoolNameWorkflowPost(poolName,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationResult = NonNullable<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>>
    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationBody = TemplateSpec
    export type SubmitWorkflowApiPoolPoolNameWorkflowPostMutationError = HTTPValidationError

    /**
 * @summary Submit Workflow
 */
export const useSubmitWorkflowApiPoolPoolNameWorkflowPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>, TError,{poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof submitWorkflowApiPoolPoolNameWorkflowPost>>,
        TError,
        {poolName: string;data: TemplateSpec;params?: SubmitWorkflowApiPoolPoolNameWorkflowPostParams},
        TContext
      > => {

      const mutationOptions = getSubmitWorkflowApiPoolPoolNameWorkflowPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This api restarts a failed workflow and then submits it.
 * @summary Restart Workflow
 */
export const restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost = (
    poolName: string,
    workflowId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<SubmitResponse>(
      {url: `/api/pool/${poolName}/workflow/${workflowId}/restart`, method: 'POST', signal
    },
      options);
    }
  


export const getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext> => {

const mutationKey = ['restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, {poolName: string;workflowId: string}> = (props) => {
          const {poolName,workflowId} = props ?? {};

          return  restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost(poolName,workflowId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationResult = NonNullable<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>>
    
    export type RestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationError = HTTPValidationError

    /**
 * @summary Restart Workflow
 */
export const useRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>, TError,{poolName: string;workflowId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof restartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPost>>,
        TError,
        {poolName: string;workflowId: string},
        TContext
      > => {

      const mutationOptions = getRestartWorkflowApiPoolPoolNameWorkflowWorkflowIdRestartPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This api allows users to fetch the default bucket and the list of available buckets.
 * @summary Get Bucket Info
 */
export const getBucketInfoApiBucketGet = (
    params?: GetBucketInfoApiBucketGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<BucketInfoResponse>(
      {url: `/api/bucket`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetBucketInfoApiBucketGetQueryKey = (params?: GetBucketInfoApiBucketGetParams,) => {
    return [
    `/api/bucket`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetBucketInfoApiBucketGetQueryOptions = <TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBucketInfoApiBucketGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>> = ({ signal }) => getBucketInfoApiBucketGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBucketInfoApiBucketGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>>
export type GetBucketInfoApiBucketGetQueryError = HTTPValidationError


export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params: undefined |  GetBucketInfoApiBucketGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>,
          TError,
          Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bucket Info
 */

export function useGetBucketInfoApiBucketGet<TData = Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError = HTTPValidationError>(
 params?: GetBucketInfoApiBucketGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBucketInfoApiBucketGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBucketInfoApiBucketGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This api deletes a Dataset.
 * @summary Delete Dataset
 */
export const deleteDatasetApiBucketBucketDatasetNameDelete = (
    bucket: string,
    name: string,
    params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<unknown>(
      {url: `/api/bucket/${bucket}/dataset/${name}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteDatasetApiBucketBucketDatasetNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext> => {

const mutationKey = ['deleteDatasetApiBucketBucketDatasetNameDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, {bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}> = (props) => {
          const {bucket,name,params} = props ?? {};

          return  deleteDatasetApiBucketBucketDatasetNameDelete(bucket,name,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetApiBucketBucketDatasetNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>>
    
    export type DeleteDatasetApiBucketBucketDatasetNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDatasetApiBucketBucketDatasetNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>, TError,{bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDatasetApiBucketBucketDatasetNameDelete>>,
        TError,
        {bucket: string;name: string;params?: DeleteDatasetApiBucketBucketDatasetNameDeleteParams},
        TContext
      > => {

      const mutationOptions = getDeleteDatasetApiBucketBucketDatasetNameDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This api can rename a dataset/collection or set/remove tags/labels/metadata.
If tag is not given, latest tag is selected
 * @summary Change Name Tag Label Metadata
 */
export const changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost = (
    bucket: string,
    name: string,
    bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,
    params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<DataAttributeResponse>(
      {url: `/api/bucket/${bucket}/dataset/${name}/attribute`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost,
        params, signal
    },
      options);
    }
  


export const getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext> => {

const mutationKey = ['changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, {bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}> = (props) => {
          const {bucket,name,data,params} = props ?? {};

          return  changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost(bucket,name,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationResult = NonNullable<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>>
    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationBody = BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost
    export type ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationError = HTTPValidationError

    /**
 * @summary Change Name Tag Label Metadata
 */
export const useChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>, TError,{bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost>>,
        TError,
        {bucket: string;name: string;data: BodyChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePost;params?: ChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostParams},
        TContext
      > => {

      const mutationOptions = getChangeNameTagLabelMetadataApiBucketBucketDatasetNameAttributePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This api gives info about the Dataset or Dataset Version.
 * @summary Get Info
 */
export const getInfoApiBucketBucketDatasetNameInfoGet = (
    bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<DataInfoResponse>(
      {url: `/api/bucket/${bucket}/dataset/${name}/info`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetInfoApiBucketBucketDatasetNameInfoGetQueryKey = (bucket?: string,
    name?: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams,) => {
    return [
    `/api/bucket/${bucket}/dataset/${name}/info`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetInfoApiBucketBucketDatasetNameInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInfoApiBucketBucketDatasetNameInfoGetQueryKey(bucket,name,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>> = ({ signal }) => getInfoApiBucketBucketDatasetNameInfoGet(bucket,name,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(bucket && name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInfoApiBucketBucketDatasetNameInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>>
export type GetInfoApiBucketBucketDatasetNameInfoGetQueryError = HTTPValidationError


export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params: undefined |  GetInfoApiBucketBucketDatasetNameInfoGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Info
 */

export function useGetInfoApiBucketBucketDatasetNameInfoGet<TData = Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError = HTTPValidationError>(
 bucket: string,
    name: string,
    params?: GetInfoApiBucketBucketDatasetNameInfoGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInfoApiBucketBucketDatasetNameInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInfoApiBucketBucketDatasetNameInfoGetQueryOptions(bucket,name,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This api returns the list of datasets/colections.
 * @summary List Dataset From Bucket
 */
export const listDatasetFromBucketApiBucketListDatasetGet = (
    params?: ListDatasetFromBucketApiBucketListDatasetGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<DataListResponse>(
      {url: `/api/bucket/list_dataset`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListDatasetFromBucketApiBucketListDatasetGetQueryKey = (params?: ListDatasetFromBucketApiBucketListDatasetGetParams,) => {
    return [
    `/api/bucket/list_dataset`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListDatasetFromBucketApiBucketListDatasetGetQueryOptions = <TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDatasetFromBucketApiBucketListDatasetGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>> = ({ signal }) => listDatasetFromBucketApiBucketListDatasetGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDatasetFromBucketApiBucketListDatasetGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>>
export type ListDatasetFromBucketApiBucketListDatasetGetQueryError = HTTPValidationError


export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params: undefined |  ListDatasetFromBucketApiBucketListDatasetGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>,
          TError,
          Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Dataset From Bucket
 */

export function useListDatasetFromBucketApiBucketListDatasetGet<TData = Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError = HTTPValidationError>(
 params?: ListDatasetFromBucketApiBucketListDatasetGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDatasetFromBucketApiBucketListDatasetGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDatasetFromBucketApiBucketListDatasetGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * This api creates a collection from datasets.
 * @summary Create Collection
 */
export const createCollectionApiBucketBucketDatasetNameCollectPost = (
    bucket: string,
    name: string,
    bodyCreateCollectionApiBucketBucketDatasetNameCollectPost: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/bucket/${bucket}/dataset/${name}/collect`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyCreateCollectionApiBucketBucketDatasetNameCollectPost, signal
    },
      options);
    }
  


export const getCreateCollectionApiBucketBucketDatasetNameCollectPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext> => {

const mutationKey = ['createCollectionApiBucketBucketDatasetNameCollectPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, {bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}> = (props) => {
          const {bucket,name,data} = props ?? {};

          return  createCollectionApiBucketBucketDatasetNameCollectPost(bucket,name,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>>
    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationBody = BodyCreateCollectionApiBucketBucketDatasetNameCollectPost
    export type CreateCollectionApiBucketBucketDatasetNameCollectPostMutationError = HTTPValidationError

    /**
 * @summary Create Collection
 */
export const useCreateCollectionApiBucketBucketDatasetNameCollectPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>, TError,{bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollectionApiBucketBucketDatasetNameCollectPost>>,
        TError,
        {bucket: string;name: string;data: BodyCreateCollectionApiBucketBucketDatasetNameCollectPost},
        TContext
      > => {

      const mutationOptions = getCreateCollectionApiBucketBucketDatasetNameCollectPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * This api queries dataset.
 * @summary Query Dataset
 */
export const queryDatasetApiBucketBucketQueryGet = (
    bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/bucket/${bucket}/query`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getQueryDatasetApiBucketBucketQueryGetQueryKey = (bucket?: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams,) => {
    return [
    `/api/bucket/${bucket}/query`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getQueryDatasetApiBucketBucketQueryGetQueryOptions = <TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getQueryDatasetApiBucketBucketQueryGetQueryKey(bucket,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>> = ({ signal }) => queryDatasetApiBucketBucketQueryGet(bucket,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(bucket), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type QueryDatasetApiBucketBucketQueryGetQueryResult = NonNullable<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>>
export type QueryDatasetApiBucketBucketQueryGetQueryError = HTTPValidationError


export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params: undefined |  QueryDatasetApiBucketBucketQueryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>,
          TError,
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>,
          TError,
          Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Query Dataset
 */

export function useQueryDatasetApiBucketBucketQueryGet<TData = Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError = HTTPValidationError>(
 bucket: string,
    params?: QueryDatasetApiBucketBucketQueryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof queryDatasetApiBucketBucketQueryGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getQueryDatasetApiBucketBucketQueryGetQueryOptions(bucket,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Notification Settings
 */
export const getNotificationSettingsApiProfileSettingsGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<ProfileResponse>(
      {url: `/api/profile/settings`, method: 'GET', signal
    },
      options);
    }
  



export const getGetNotificationSettingsApiProfileSettingsGetQueryKey = () => {
    return [
    `/api/profile/settings`
    ] as const;
    }

    
export const getGetNotificationSettingsApiProfileSettingsGetQueryOptions = <TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotificationSettingsApiProfileSettingsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>> = ({ signal }) => getNotificationSettingsApiProfileSettingsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNotificationSettingsApiProfileSettingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>>
export type GetNotificationSettingsApiProfileSettingsGetQueryError = HTTPValidationError


export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Notification Settings
 */

export function useGetNotificationSettingsApiProfileSettingsGet<TData = Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationSettingsApiProfileSettingsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNotificationSettingsApiProfileSettingsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Set Notification Settings
 */
export const setNotificationSettingsApiProfileSettingsPost = (
    userProfile: UserProfile,
    params?: SetNotificationSettingsApiProfileSettingsPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/profile/settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userProfile,
        params, signal
    },
      options);
    }
  


export const getSetNotificationSettingsApiProfileSettingsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext> => {

const mutationKey = ['setNotificationSettingsApiProfileSettingsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, {data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  setNotificationSettingsApiProfileSettingsPost(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetNotificationSettingsApiProfileSettingsPostMutationResult = NonNullable<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>>
    export type SetNotificationSettingsApiProfileSettingsPostMutationBody = UserProfile
    export type SetNotificationSettingsApiProfileSettingsPostMutationError = HTTPValidationError

    /**
 * @summary Set Notification Settings
 */
export const useSetNotificationSettingsApiProfileSettingsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>, TError,{data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setNotificationSettingsApiProfileSettingsPost>>,
        TError,
        {data: UserProfile;params?: SetNotificationSettingsApiProfileSettingsPostParams},
        TContext
      > => {

      const mutationOptions = getSetNotificationSettingsApiProfileSettingsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get Osmo Client Version
 */
export const getOsmoClientVersionClientVersionGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/client/version`, method: 'GET', signal
    },
      options);
    }
  



export const getGetOsmoClientVersionClientVersionGetQueryKey = () => {
    return [
    `/client/version`
    ] as const;
    }

    
export const getGetOsmoClientVersionClientVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOsmoClientVersionClientVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>> = ({ signal }) => getOsmoClientVersionClientVersionGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOsmoClientVersionClientVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>>
export type GetOsmoClientVersionClientVersionGetQueryError = unknown


export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Osmo Client Version
 */

export function useGetOsmoClientVersionClientVersionGet<TData = Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOsmoClientVersionClientVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOsmoClientVersionClientVersionGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * To be used for the readiness probe, but not liveness probe. That way, if this method is
slow, no new traffic gets routed, instead of killing the service.
 * @summary Health
 */
export const healthHealthGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      options);
    }
  



export const getHealthHealthGetQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthHealthGet>>> = ({ signal }) => healthHealthGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthHealthGet>>>
export type HealthHealthGetQueryError = unknown


export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health
 */

export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get Version
 */
export const getVersionApiVersionGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/version`, method: 'GET', signal
    },
      options);
    }
  



export const getGetVersionApiVersionGetQueryKey = () => {
    return [
    `/api/version`
    ] as const;
    }

    
export const getGetVersionApiVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVersionApiVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionApiVersionGet>>> = ({ signal }) => getVersionApiVersionGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVersionApiVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVersionApiVersionGet>>>
export type GetVersionApiVersionGetQueryError = unknown


export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionApiVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getVersionApiVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVersionApiVersionGet>>,
          TError,
          Awaited<ReturnType<typeof getVersionApiVersionGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Version
 */

export function useGetVersionApiVersionGet<TData = Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVersionApiVersionGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVersionApiVersionGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the values of all users who have submitted a workflow.
 * @summary Get Users
 */
export const getUsersApiUsersGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/users`, method: 'GET', signal
    },
      options);
    }
  



export const getGetUsersApiUsersGetQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getGetUsersApiUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersApiUsersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersApiUsersGet>>> = ({ signal }) => getUsersApiUsersGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersApiUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersApiUsersGet>>>
export type GetUsersApiUsersGetQueryError = unknown


export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiUsersGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Users
 */

export function useGetUsersApiUsersGet<TData = Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiUsersGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersApiUsersGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns all workflow tags.
 * @summary Get Available Workflow Tags
 */
export const getAvailableWorkflowTagsApiTagGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/tag`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAvailableWorkflowTagsApiTagGetQueryKey = () => {
    return [
    `/api/tag`
    ] as const;
    }

    
export const getGetAvailableWorkflowTagsApiTagGetQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableWorkflowTagsApiTagGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>> = ({ signal }) => getAvailableWorkflowTagsApiTagGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAvailableWorkflowTagsApiTagGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>>
export type GetAvailableWorkflowTagsApiTagGetQueryError = unknown


export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Available Workflow Tags
 */

export function useGetAvailableWorkflowTagsApiTagGet<TData = Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAvailableWorkflowTagsApiTagGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAvailableWorkflowTagsApiTagGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all the workflow plugins configurations
 * @summary Get Workflow Plugins Configs
 */
export const getWorkflowPluginsConfigsApiPluginsConfigsGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<string>(
      {url: `/api/plugins/configs`, method: 'GET', signal
    },
      options);
    }
  



export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryKey = () => {
    return [
    `/api/plugins/configs`
    ] as const;
    }

    
export const getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>> = ({ signal }) => getWorkflowPluginsConfigsApiPluginsConfigsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowPluginsConfigsApiPluginsConfigsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>>
export type GetWorkflowPluginsConfigsApiPluginsConfigsGetQueryError = unknown


export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workflow Plugins Configs
 */

export function useGetWorkflowPluginsConfigsApiPluginsConfigsGet<TData = Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowPluginsConfigsApiPluginsConfigsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowPluginsConfigsApiPluginsConfigsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
